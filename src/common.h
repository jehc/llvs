// **********************************************************************
//
// Generated by the Orbix/E IDL-to-C++ Translator
//
// Copyright (c) 2003
// IONA Technologies, Inc.
// Waltham, MA, USA
//
// All Rights Reserved
//
// **********************************************************************

// Version: 2.2.0

#ifndef ___common_h__
#define ___common_h__

#ifndef OPENHRP_API
#   ifdef OBE_DLL
#      define OPENHRP_API __declspec(dllimport)
#   else
#      define OPENHRP_API /**/
#   endif
#endif


#ifndef OBEC_INTEGER_VERSION
#   error No Orbix/E version defined! Is <OBE/CORBA.h> included?
#endif

#ifndef OBEC_NO_VERSION_CHECK
#   if (OBEC_INTEGER_VERSION != 2020000L)
#       error Orbix/E version mismatch!
#   endif
#endif

class SensorInfo;
typedef SensorInfo* SensorInfo_ptr;
typedef SensorInfo* SensorInfoRef;
OPENHRP_API extern CORBA::TypeCode_ptr _tc_SensorInfo;

class ParserModelObject;
typedef ParserModelObject* ParserModelObject_ptr;
typedef ParserModelObject* ParserModelObjectRef;
OPENHRP_API extern CORBA::TypeCode_ptr _tc_ParserModelObject;

class ParserCharObject;
typedef ParserCharObject* ParserCharObject_ptr;
typedef ParserCharObject* ParserCharObjectRef;
OPENHRP_API extern CORBA::TypeCode_ptr _tc_ParserCharObject;

class ModelInfo;
typedef ModelInfo* ModelInfo_ptr;
typedef ModelInfo* ModelInfoRef;
OPENHRP_API extern CORBA::TypeCode_ptr _tc_ModelInfo;

class OpenHRPObject;
typedef OpenHRPObject* OpenHRPObject_ptr;
typedef OpenHRPObject* OpenHRPObjectRef;
OPENHRP_API extern CORBA::TypeCode_ptr _tc_OpenHRPObject;

class CommandReceiver;
typedef CommandReceiver* CommandReceiver_ptr;
typedef CommandReceiver* CommandReceiverRef;
OPENHRP_API extern CORBA::TypeCode_ptr _tc_CommandReceiver;

class Plugin;
typedef Plugin* Plugin_ptr;
typedef Plugin* PluginRef;
OPENHRP_API extern CORBA::TypeCode_ptr _tc_Plugin;

class PluginManager;
typedef PluginManager* PluginManager_ptr;
typedef PluginManager* PluginManagerRef;
OPENHRP_API extern CORBA::TypeCode_ptr _tc_PluginManager;

OPENHRP_API void OBDuplicate(SensorInfo_ptr);
OPENHRP_API void OBRelease(SensorInfo_ptr);

OPENHRP_API void OBMarshal(SensorInfo_ptr, OBEC_OutputStreamImpl*, CORBA_Environment*);
OPENHRP_API void OBUnmarshal(SensorInfo_ptr&, OBEC_InputStreamImpl*, CORBA_Environment*);

OPENHRP_API void OBDuplicate(ParserModelObject_ptr);
OPENHRP_API void OBRelease(ParserModelObject_ptr);

OPENHRP_API void OBMarshal(ParserModelObject_ptr, OBEC_OutputStreamImpl*, CORBA_Environment*);
OPENHRP_API void OBUnmarshal(ParserModelObject_ptr&, OBEC_InputStreamImpl*, CORBA_Environment*);

OPENHRP_API void OBDuplicate(ParserCharObject_ptr);
OPENHRP_API void OBRelease(ParserCharObject_ptr);

OPENHRP_API void OBMarshal(ParserCharObject_ptr, OBEC_OutputStreamImpl*, CORBA_Environment*);
OPENHRP_API void OBUnmarshal(ParserCharObject_ptr&, OBEC_InputStreamImpl*, CORBA_Environment*);

OPENHRP_API void OBDuplicate(ModelInfo_ptr);
OPENHRP_API void OBRelease(ModelInfo_ptr);

OPENHRP_API void OBMarshal(ModelInfo_ptr, OBEC_OutputStreamImpl*, CORBA_Environment*);
OPENHRP_API void OBUnmarshal(ModelInfo_ptr&, OBEC_InputStreamImpl*, CORBA_Environment*);

OPENHRP_API void OBDuplicate(OpenHRPObject_ptr);
OPENHRP_API void OBRelease(OpenHRPObject_ptr);

OPENHRP_API void OBMarshal(OpenHRPObject_ptr, OBEC_OutputStreamImpl*, CORBA_Environment*);
OPENHRP_API void OBUnmarshal(OpenHRPObject_ptr&, OBEC_InputStreamImpl*, CORBA_Environment*);

OPENHRP_API void OBDuplicate(CommandReceiver_ptr);
OPENHRP_API void OBRelease(CommandReceiver_ptr);

OPENHRP_API void OBMarshal(CommandReceiver_ptr, OBEC_OutputStreamImpl*, CORBA_Environment*);
OPENHRP_API void OBUnmarshal(CommandReceiver_ptr&, OBEC_InputStreamImpl*, CORBA_Environment*);

OPENHRP_API void OBDuplicate(Plugin_ptr);
OPENHRP_API void OBRelease(Plugin_ptr);

OPENHRP_API void OBMarshal(Plugin_ptr, OBEC_OutputStreamImpl*, CORBA_Environment*);
OPENHRP_API void OBUnmarshal(Plugin_ptr&, OBEC_InputStreamImpl*, CORBA_Environment*);

OPENHRP_API void OBDuplicate(PluginManager_ptr);
OPENHRP_API void OBRelease(PluginManager_ptr);

OPENHRP_API void OBMarshal(PluginManager_ptr, OBEC_OutputStreamImpl*, CORBA_Environment*);
OPENHRP_API void OBUnmarshal(PluginManager_ptr&, OBEC_InputStreamImpl*, CORBA_Environment*);

#ifdef OBEA_DLL
#   ifndef HAVE_NO_EXPLICIT_TEMPLATES
template class OPENHRP_API OB::ObjVar< SensorInfo >;
#   endif
#endif
typedef OB::ObjVar< SensorInfo > SensorInfo_var;
#ifdef OBEA_DLL
#   ifndef HAVE_NO_EXPLICIT_TEMPLATES
template class OPENHRP_API OB::ObjOut< SensorInfo >;
#   endif
#endif
typedef OB::ObjOut< SensorInfo > SensorInfo_out;

#ifdef OBEA_DLL
#   ifndef HAVE_NO_EXPLICIT_TEMPLATES
template class OPENHRP_API OB::ObjVar< ParserModelObject >;
#   endif
#endif
typedef OB::ObjVar< ParserModelObject > ParserModelObject_var;
#ifdef OBEA_DLL
#   ifndef HAVE_NO_EXPLICIT_TEMPLATES
template class OPENHRP_API OB::ObjOut< ParserModelObject >;
#   endif
#endif
typedef OB::ObjOut< ParserModelObject > ParserModelObject_out;

#ifdef OBEA_DLL
#   ifndef HAVE_NO_EXPLICIT_TEMPLATES
template class OPENHRP_API OB::ObjVar< ParserCharObject >;
#   endif
#endif
typedef OB::ObjVar< ParserCharObject > ParserCharObject_var;
#ifdef OBEA_DLL
#   ifndef HAVE_NO_EXPLICIT_TEMPLATES
template class OPENHRP_API OB::ObjOut< ParserCharObject >;
#   endif
#endif
typedef OB::ObjOut< ParserCharObject > ParserCharObject_out;

#ifdef OBEA_DLL
#   ifndef HAVE_NO_EXPLICIT_TEMPLATES
template class OPENHRP_API OB::ObjVar< ModelInfo >;
#   endif
#endif
typedef OB::ObjVar< ModelInfo > ModelInfo_var;
#ifdef OBEA_DLL
#   ifndef HAVE_NO_EXPLICIT_TEMPLATES
template class OPENHRP_API OB::ObjOut< ModelInfo >;
#   endif
#endif
typedef OB::ObjOut< ModelInfo > ModelInfo_out;

#ifdef OBEA_DLL
#   ifndef HAVE_NO_EXPLICIT_TEMPLATES
template class OPENHRP_API OB::ObjVar< OpenHRPObject >;
#   endif
#endif
typedef OB::ObjVar< OpenHRPObject > OpenHRPObject_var;
#ifdef OBEA_DLL
#   ifndef HAVE_NO_EXPLICIT_TEMPLATES
template class OPENHRP_API OB::ObjOut< OpenHRPObject >;
#   endif
#endif
typedef OB::ObjOut< OpenHRPObject > OpenHRPObject_out;

#ifdef OBEA_DLL
#   ifndef HAVE_NO_EXPLICIT_TEMPLATES
template class OPENHRP_API OB::ObjVar< CommandReceiver >;
#   endif
#endif
typedef OB::ObjVar< CommandReceiver > CommandReceiver_var;
#ifdef OBEA_DLL
#   ifndef HAVE_NO_EXPLICIT_TEMPLATES
template class OPENHRP_API OB::ObjOut< CommandReceiver >;
#   endif
#endif
typedef OB::ObjOut< CommandReceiver > CommandReceiver_out;

#ifdef OBEA_DLL
#   ifndef HAVE_NO_EXPLICIT_TEMPLATES
template class OPENHRP_API OB::ObjVar< Plugin >;
#   endif
#endif
typedef OB::ObjVar< Plugin > Plugin_var;
#ifdef OBEA_DLL
#   ifndef HAVE_NO_EXPLICIT_TEMPLATES
template class OPENHRP_API OB::ObjOut< Plugin >;
#   endif
#endif
typedef OB::ObjOut< Plugin > Plugin_out;

#ifdef OBEA_DLL
#   ifndef HAVE_NO_EXPLICIT_TEMPLATES
template class OPENHRP_API OB::ObjVar< PluginManager >;
#   endif
#endif
typedef OB::ObjVar< PluginManager > PluginManager_var;
#ifdef OBEA_DLL
#   ifndef HAVE_NO_EXPLICIT_TEMPLATES
template class OPENHRP_API OB::ObjOut< PluginManager >;
#   endif
#endif
typedef OB::ObjOut< PluginManager > PluginManager_out;

//
// IDL:TorqueSeq:1.0
//
class OBUnique_TorqueSeq { };

#ifdef OBEA_DLL
template class OPENHRP_API OB::FixSeq< CORBA::Double, OBUnique_TorqueSeq >;
#endif
typedef OB::FixSeq< CORBA::Double, OBUnique_TorqueSeq > TorqueSeq;
#ifdef OBEA_DLL
template class OPENHRP_API OB::SeqVar< OB::FixSeq< CORBA::Double, OBUnique_TorqueSeq > >;
#endif
typedef OB::SeqVar< OB::FixSeq< CORBA::Double, OBUnique_TorqueSeq > > TorqueSeq_var;
#ifdef OBEA_DLL
template class OPENHRP_API OB::SeqOut< OB::FixSeq< CORBA::Double, OBUnique_TorqueSeq > >;
#endif
typedef OB::SeqOut< OB::FixSeq< CORBA::Double, OBUnique_TorqueSeq > > TorqueSeq_out;
extern CORBA::TypeCode_ptr _tc_TorqueSeq;

//
// IDL:DataId:1.0
//
enum DataId
{
    ANGLE,
    VELOCITY,
    ACCELERATION
};

typedef DataId& DataId_out;

extern CORBA::TypeCode_ptr _tc_DataId;

//
// IDL:LinkData:1.0
//
class OBUnique_LinkData { };

typedef CORBA::Double LinkData[3];
typedef CORBA::Double LinkData_slice;
typedef OB::FixArrayVar< CORBA::Double, CORBA::Double, 3 > LinkData_var;
typedef CORBA::Double LinkData_out[3];
typedef OB::FixArrayForAny< CORBA::Double, CORBA::Double, 3, OBUnique_LinkData > LinkData_forany;
extern CORBA::TypeCode_ptr _tc_LinkData;

inline LinkData_slice*
LinkData_alloc()
{
    return (LinkData_slice*) new CORBA::Double[3];
}

inline LinkData_slice*
LinkData_dup(const LinkData_slice* s)
{
    LinkData_slice* to = (LinkData_slice*) new CORBA::Double[3];
    memcpy(to, s, 3 * sizeof(CORBA::Double));
    return to;
}

inline void
LinkData_copy(LinkData_slice* to, const LinkData_slice* from)
{
    memcpy(to, from, 3 * sizeof(CORBA::Double));
}

inline void
LinkData_free(LinkData_slice* s)
{
    delete [] (CORBA::Double*)s;
}

#ifdef HAVE_VCPLUSPLUS_BUGS

inline LinkData_slice*
LinkData_dup(LinkData_slice* s)
{
    return LinkData_dup((const LinkData_slice*)s);
}

inline void
LinkData_copy(LinkData_slice* to, LinkData_slice* from)
{
    LinkData_copy(to, (const LinkData_slice*)from);
}

#endif

//
// IDL:LinkDataSeq:1.0
//
class OBUnique_LinkDataSeq { };

#ifdef OBEA_DLL
template class OPENHRP_API OB::FixArraySeq< CORBA::Double, CORBA::Double, 3, OBUnique_LinkDataSeq >;
#endif
typedef OB::FixArraySeq< CORBA::Double, CORBA::Double, 3, OBUnique_LinkDataSeq > LinkDataSeq;
#ifdef OBEA_DLL
template class OPENHRP_API OB::SeqVar< OB::FixArraySeq< CORBA::Double, CORBA::Double, 3, OBUnique_LinkDataSeq > >;
#endif
typedef OB::SeqVar< OB::FixArraySeq< CORBA::Double, CORBA::Double, 3, OBUnique_LinkDataSeq > > LinkDataSeq_var;
#ifdef OBEA_DLL
template class OPENHRP_API OB::SeqOut< OB::FixArraySeq< CORBA::Double, CORBA::Double, 3, OBUnique_LinkDataSeq > >;
#endif
typedef OB::SeqOut< OB::FixArraySeq< CORBA::Double, CORBA::Double, 3, OBUnique_LinkDataSeq > > LinkDataSeq_out;
extern CORBA::TypeCode_ptr _tc_LinkDataSeq;

//
// IDL:Value:1.0
//
class OBUnique_Value { };

#ifdef OBEA_DLL
template class OPENHRP_API OB::BndFixSeq< CORBA::Double, 9, OBUnique_Value >;
#endif
typedef OB::BndFixSeq< CORBA::Double, 9, OBUnique_Value > Value;
#ifdef OBEA_DLL
template class OPENHRP_API OB::SeqVar< OB::BndFixSeq< CORBA::Double, 9, OBUnique_Value > >;
#endif
typedef OB::SeqVar< OB::BndFixSeq< CORBA::Double, 9, OBUnique_Value > > Value_var;
#ifdef OBEA_DLL
template class OPENHRP_API OB::SeqOut< OB::BndFixSeq< CORBA::Double, 9, OBUnique_Value > >;
#endif
typedef OB::SeqOut< OB::BndFixSeq< CORBA::Double, 9, OBUnique_Value > > Value_out;
extern CORBA::TypeCode_ptr _tc_Value;

//
// IDL:FSValue:1.0
//
class OBUnique_FSValue { };

#ifdef OBEA_DLL
template class OPENHRP_API OB::BndFixSeq< CORBA::Double, 6, OBUnique_FSValue >;
#endif
typedef OB::BndFixSeq< CORBA::Double, 6, OBUnique_FSValue > FSValue;
#ifdef OBEA_DLL
template class OPENHRP_API OB::SeqVar< OB::BndFixSeq< CORBA::Double, 6, OBUnique_FSValue > >;
#endif
typedef OB::SeqVar< OB::BndFixSeq< CORBA::Double, 6, OBUnique_FSValue > > FSValue_var;
#ifdef OBEA_DLL
template class OPENHRP_API OB::SeqOut< OB::BndFixSeq< CORBA::Double, 6, OBUnique_FSValue > >;
#endif
typedef OB::SeqOut< OB::BndFixSeq< CORBA::Double, 6, OBUnique_FSValue > > FSValue_out;
extern CORBA::TypeCode_ptr _tc_FSValue;

//
// IDL:LinkNameSeq:1.0
//
class OBUnique_LinkNameSeq { };

#ifdef OBEA_DLL
template class OPENHRP_API OB::StrSeq< OBUnique_LinkNameSeq >;
#endif
typedef OB::StrSeq< OBUnique_LinkNameSeq > LinkNameSeq;
#ifdef OBEA_DLL
template class OPENHRP_API OB::SeqVar< OB::StrSeq< OBUnique_LinkNameSeq > >;
#endif
typedef OB::SeqVar< OB::StrSeq< OBUnique_LinkNameSeq > > LinkNameSeq_var;
#ifdef OBEA_DLL
template class OPENHRP_API OB::SeqOut< OB::StrSeq< OBUnique_LinkNameSeq > >;
#endif
typedef OB::SeqOut< OB::StrSeq< OBUnique_LinkNameSeq > > LinkNameSeq_out;
extern CORBA::TypeCode_ptr _tc_LinkNameSeq;

//
// IDL:Transform:1.0
//
struct OPENHRP_API Transform;
#ifdef OBEA_DLL
template class OPENHRP_API OB::FixVar< Transform >;
#endif
typedef OB::FixVar< Transform > Transform_var;
typedef Transform& Transform_out;

struct OPENHRP_API Transform
{
    typedef Transform_var _var_type;

    CORBA::Float posX;
    CORBA::Float posY;
    CORBA::Float posZ;
    CORBA::Float axisX;
    CORBA::Float axisY;
    CORBA::Float axisZ;
    CORBA::Float angle;

    void _OB_marshal(
        OBEC_OutputStreamImpl* _ob_out,
        CORBA_Environment* _ob_cev
    ) const;
    static void _OB_unmarshal(
        Transform& _ob_v,
        OBEC_InputStreamImpl* _ob_in,
        CORBA_Environment* _ob_cev
    );

    void
    _OB_convert_to(
        void* _ob_data
    ) const;

    static void
    _OB_convert_from(
        Transform& _ob_v,
        void* _ob_data
    );
};

extern CORBA::TypeCode_ptr _tc_Transform;

//
// IDL:TransformQuaternion:1.0
//
struct OPENHRP_API TransformQuaternion;
#ifdef OBEA_DLL
template class OPENHRP_API OB::FixVar< TransformQuaternion >;
#endif
typedef OB::FixVar< TransformQuaternion > TransformQuaternion_var;
typedef TransformQuaternion& TransformQuaternion_out;

struct OPENHRP_API TransformQuaternion
{
    typedef TransformQuaternion_var _var_type;

    CORBA::Float px;
    CORBA::Float py;
    CORBA::Float pz;
    CORBA::Float qx;
    CORBA::Float qy;
    CORBA::Float qz;
    CORBA::Float qw;

    void _OB_marshal(
        OBEC_OutputStreamImpl* _ob_out,
        CORBA_Environment* _ob_cev
    ) const;
    static void _OB_unmarshal(
        TransformQuaternion& _ob_v,
        OBEC_InputStreamImpl* _ob_in,
        CORBA_Environment* _ob_cev
    );

    void
    _OB_convert_to(
        void* _ob_data
    ) const;

    static void
    _OB_convert_from(
        TransformQuaternion& _ob_v,
        void* _ob_data
    );
};

extern CORBA::TypeCode_ptr _tc_TransformQuaternion;

//
// IDL:LinkInfo:1.0
//
struct OPENHRP_API LinkInfo;
#ifdef OBEA_DLL
template class OPENHRP_API OB::VarVar< LinkInfo >;
#endif
typedef OB::VarVar< LinkInfo > LinkInfo_var;
#ifdef OBEA_DLL
template class OPENHRP_API OB::VarOut< LinkInfo >;
#endif
typedef OB::VarOut< LinkInfo > LinkInfo_out;

struct OPENHRP_API LinkInfo
{
#ifdef OB_PURIFY_CLEAN
    LinkInfo();
#else
    LinkInfo() { }
#endif
    LinkInfo(const LinkInfo&);
    LinkInfo& operator=(const LinkInfo&);

    typedef LinkInfo_var _var_type;

    OB::StrForStruct name;
    ::Value pos;
    ::Value rot;
    CORBA::Double JointValue;
    CORBA::Double JointVel;
    CORBA::Double JointAcc;
    ::Value jpos;
    ::Value jatt;
    ::Value vel;
    ::Value acc;

    void _OB_marshal(
        OBEC_OutputStreamImpl* _ob_out,
        CORBA_Environment* _ob_cev
    ) const;
    static void _OB_unmarshal(
        LinkInfo& _ob_v,
        OBEC_InputStreamImpl* _ob_in,
        CORBA_Environment* _ob_cev
    );

    void
    _OB_convert_to(
        void* _ob_data
    ) const;

    static void
    _OB_convert_from(
        LinkInfo& _ob_v,
        void* _ob_data
    );
};

extern CORBA::TypeCode_ptr _tc_LinkInfo;

//
// IDL:LinkValue:1.0
//
struct OPENHRP_API LinkValue;
#ifdef OBEA_DLL
template class OPENHRP_API OB::VarVar< LinkValue >;
#endif
typedef OB::VarVar< LinkValue > LinkValue_var;
#ifdef OBEA_DLL
template class OPENHRP_API OB::VarOut< LinkValue >;
#endif
typedef OB::VarOut< LinkValue > LinkValue_out;

struct OPENHRP_API LinkValue
{
    LinkValue() { }
    LinkValue(const LinkValue&);
    LinkValue& operator=(const LinkValue&);

    typedef LinkValue_var _var_type;

    OB::StrForStruct name;
    OB::StrForStruct param;
    ::Value data;

    void _OB_marshal(
        OBEC_OutputStreamImpl* _ob_out,
        CORBA_Environment* _ob_cev
    ) const;
    static void _OB_unmarshal(
        LinkValue& _ob_v,
        OBEC_InputStreamImpl* _ob_in,
        CORBA_Environment* _ob_cev
    );

    void
    _OB_convert_to(
        void* _ob_data
    ) const;

    static void
    _OB_convert_from(
        LinkValue& _ob_v,
        void* _ob_data
    );
};

extern CORBA::TypeCode_ptr _tc_LinkValue;

//
// IDL:LinkValueSeq:1.0
//
class OBUnique_LinkValueSeq { };

#ifdef OBEA_DLL
template class OPENHRP_API OB::VarSeq< ::LinkValue, OBUnique_LinkValueSeq >;
#endif
typedef OB::VarSeq< ::LinkValue, OBUnique_LinkValueSeq > LinkValueSeq;
#ifdef OBEA_DLL
template class OPENHRP_API OB::SeqVar< OB::VarSeq< ::LinkValue, OBUnique_LinkValueSeq > >;
#endif
typedef OB::SeqVar< OB::VarSeq< ::LinkValue, OBUnique_LinkValueSeq > > LinkValueSeq_var;
#ifdef OBEA_DLL
template class OPENHRP_API OB::SeqOut< OB::VarSeq< ::LinkValue, OBUnique_LinkValueSeq > >;
#endif
typedef OB::SeqOut< OB::VarSeq< ::LinkValue, OBUnique_LinkValueSeq > > LinkValueSeq_out;
extern CORBA::TypeCode_ptr _tc_LinkValueSeq;

//
// IDL:LinkInfoSeq:1.0
//
class OBUnique_LinkInfoSeq { };

#ifdef OBEA_DLL
template class OPENHRP_API OB::VarSeq< ::LinkInfo, OBUnique_LinkInfoSeq >;
#endif
typedef OB::VarSeq< ::LinkInfo, OBUnique_LinkInfoSeq > LinkInfoSeq;
#ifdef OBEA_DLL
template class OPENHRP_API OB::SeqVar< OB::VarSeq< ::LinkInfo, OBUnique_LinkInfoSeq > >;
#endif
typedef OB::SeqVar< OB::VarSeq< ::LinkInfo, OBUnique_LinkInfoSeq > > LinkInfoSeq_var;
#ifdef OBEA_DLL
template class OPENHRP_API OB::SeqOut< OB::VarSeq< ::LinkInfo, OBUnique_LinkInfoSeq > >;
#endif
typedef OB::SeqOut< OB::VarSeq< ::LinkInfo, OBUnique_LinkInfoSeq > > LinkInfoSeq_out;
extern CORBA::TypeCode_ptr _tc_LinkInfoSeq;

//
// IDL:Vector3:1.0
//
class OBUnique_Vector3 { };

typedef CORBA::Float Vector3[3];
typedef CORBA::Float Vector3_slice;
typedef OB::FixArrayVar< CORBA::Float, CORBA::Float, 3 > Vector3_var;
typedef CORBA::Float Vector3_out[3];
typedef OB::FixArrayForAny< CORBA::Float, CORBA::Float, 3, OBUnique_Vector3 > Vector3_forany;
extern CORBA::TypeCode_ptr _tc_Vector3;

inline Vector3_slice*
Vector3_alloc()
{
    return (Vector3_slice*) new CORBA::Float[3];
}

inline Vector3_slice*
Vector3_dup(const Vector3_slice* s)
{
    Vector3_slice* to = (Vector3_slice*) new CORBA::Float[3];
    memcpy(to, s, 3 * sizeof(CORBA::Float));
    return to;
}

inline void
Vector3_copy(Vector3_slice* to, const Vector3_slice* from)
{
    memcpy(to, from, 3 * sizeof(CORBA::Float));
}

inline void
Vector3_free(Vector3_slice* s)
{
    delete [] (CORBA::Float*)s;
}

#ifdef HAVE_VCPLUSPLUS_BUGS

inline Vector3_slice*
Vector3_dup(Vector3_slice* s)
{
    return Vector3_dup((const Vector3_slice*)s);
}

inline void
Vector3_copy(Vector3_slice* to, Vector3_slice* from)
{
    Vector3_copy(to, (const Vector3_slice*)from);
}

#endif

//
// IDL:CollisionData:1.0
//
struct OPENHRP_API CollisionData;
#ifdef OBEA_DLL
template class OPENHRP_API OB::FixVar< CollisionData >;
#endif
typedef OB::FixVar< CollisionData > CollisionData_var;
typedef CollisionData& CollisionData_out;

struct OPENHRP_API CollisionData
{
    typedef CollisionData_var _var_type;

    ::Vector3 coord;
    ::Vector3 normal;
    CORBA::Double idepth;

    void _OB_marshal(
        OBEC_OutputStreamImpl* _ob_out,
        CORBA_Environment* _ob_cev
    ) const;
    static void _OB_unmarshal(
        CollisionData& _ob_v,
        OBEC_InputStreamImpl* _ob_in,
        CORBA_Environment* _ob_cev
    );

    void
    _OB_convert_to(
        void* _ob_data
    ) const;

    static void
    _OB_convert_from(
        CollisionData& _ob_v,
        void* _ob_data
    );
};

extern CORBA::TypeCode_ptr _tc_CollisionData;

//
// IDL:CollisionDataSeq:1.0
//
class OBUnique_CollisionDataSeq { };

#ifdef OBEA_DLL
template class OPENHRP_API OB::FixSeq< ::CollisionData, OBUnique_CollisionDataSeq >;
#endif
typedef OB::FixSeq< ::CollisionData, OBUnique_CollisionDataSeq > CollisionDataSeq;
#ifdef OBEA_DLL
template class OPENHRP_API OB::SeqVar< OB::FixSeq< ::CollisionData, OBUnique_CollisionDataSeq > >;
#endif
typedef OB::SeqVar< OB::FixSeq< ::CollisionData, OBUnique_CollisionDataSeq > > CollisionDataSeq_var;
#ifdef OBEA_DLL
template class OPENHRP_API OB::SeqOut< OB::FixSeq< ::CollisionData, OBUnique_CollisionDataSeq > >;
#endif
typedef OB::SeqOut< OB::FixSeq< ::CollisionData, OBUnique_CollisionDataSeq > > CollisionDataSeq_out;
extern CORBA::TypeCode_ptr _tc_CollisionDataSeq;

//
// IDL:WorldState:1.0
//
struct OPENHRP_API WorldState;
#ifdef OBEA_DLL
template class OPENHRP_API OB::VarVar< WorldState >;
#endif
typedef OB::VarVar< WorldState > WorldState_var;
#ifdef OBEA_DLL
template class OPENHRP_API OB::VarOut< WorldState >;
#endif
typedef OB::VarOut< WorldState > WorldState_out;

struct OPENHRP_API WorldState
{
#ifdef OB_PURIFY_CLEAN
    WorldState();
#else
    WorldState() { }
#endif
    WorldState(const WorldState&);
    WorldState& operator=(const WorldState&);

    typedef WorldState_var _var_type;

    CORBA::Double time;
    ::LinkInfoSeq linkinfo;
    ::CollisionDataSeq collision;

    void _OB_marshal(
        OBEC_OutputStreamImpl* _ob_out,
        CORBA_Environment* _ob_cev
    ) const;
    static void _OB_unmarshal(
        WorldState& _ob_v,
        OBEC_InputStreamImpl* _ob_in,
        CORBA_Environment* _ob_cev
    );

    void
    _OB_convert_to(
        void* _ob_data
    ) const;

    static void
    _OB_convert_from(
        WorldState& _ob_v,
        void* _ob_data
    );
};

extern CORBA::TypeCode_ptr _tc_WorldState;

//
// IDL:dsequence:1.0
//
class OBUnique_dsequence { };

#ifdef OBEA_DLL
template class OPENHRP_API OB::FixSeq< CORBA::Double, OBUnique_dsequence >;
#endif
typedef OB::FixSeq< CORBA::Double, OBUnique_dsequence > dsequence;
#ifdef OBEA_DLL
template class OPENHRP_API OB::SeqVar< OB::FixSeq< CORBA::Double, OBUnique_dsequence > >;
#endif
typedef OB::SeqVar< OB::FixSeq< CORBA::Double, OBUnique_dsequence > > dsequence_var;
#ifdef OBEA_DLL
template class OPENHRP_API OB::SeqOut< OB::FixSeq< CORBA::Double, OBUnique_dsequence > >;
#endif
typedef OB::SeqOut< OB::FixSeq< CORBA::Double, OBUnique_dsequence > > dsequence_out;
extern CORBA::TypeCode_ptr _tc_dsequence;

//
// IDL:PixelFormat:1.0
//
enum PixelFormat
{
    ARGB,
    GRAY,
    DEPTH,
    RGB
};

typedef PixelFormat& PixelFormat_out;

extern CORBA::TypeCode_ptr _tc_PixelFormat;

//
// IDL:ImageData:1.0
//
struct OPENHRP_API ImageData;
#ifdef OBEA_DLL
template class OPENHRP_API OB::VarVar< ImageData >;
#endif
typedef OB::VarVar< ImageData > ImageData_var;
#ifdef OBEA_DLL
template class OPENHRP_API OB::VarOut< ImageData >;
#endif
typedef OB::VarOut< ImageData > ImageData_out;

struct OPENHRP_API ImageData
{
#ifdef OB_PURIFY_CLEAN
    ImageData();
#else
    ImageData() { }
#endif
    ImageData(const ImageData&);
    ImageData& operator=(const ImageData&);

    typedef ImageData_var _var_type;

    ::PixelFormat format;
    CORBA::Long width;
    CORBA::Long height;
    class OBUnique_octetData { };
    #ifdef OBEA_DLL
    template class OPENHRP_API OB::FixSeq< CORBA::Octet, OBUnique_octetData >;
    #endif
    typedef OB::FixSeq< CORBA::Octet, OBUnique_octetData > _octetData_seq;
    _octetData_seq octetData;
    class OBUnique_longData { };
    #ifdef OBEA_DLL
    template class OPENHRP_API OB::FixSeq< CORBA::Long, OBUnique_longData >;
    #endif
    typedef OB::FixSeq< CORBA::Long, OBUnique_longData > _longData_seq;
    _longData_seq longData;
    class OBUnique_floatData { };
    #ifdef OBEA_DLL
    template class OPENHRP_API OB::FixSeq< CORBA::Float, OBUnique_floatData >;
    #endif
    typedef OB::FixSeq< CORBA::Float, OBUnique_floatData > _floatData_seq;
    _floatData_seq floatData;

    void _OB_marshal(
        OBEC_OutputStreamImpl* _ob_out,
        CORBA_Environment* _ob_cev
    ) const;
    static void _OB_unmarshal(
        ImageData& _ob_v,
        OBEC_InputStreamImpl* _ob_in,
        CORBA_Environment* _ob_cev
    );

    void
    _OB_convert_to(
        void* _ob_data
    ) const;

    static void
    _OB_convert_from(
        ImageData& _ob_v,
        void* _ob_data
    );
};

extern CORBA::TypeCode_ptr _tc_ImageData;

//
// IDL:RobotState:1.0
//
struct OPENHRP_API RobotState;
#ifdef OBEA_DLL
template class OPENHRP_API OB::VarVar< RobotState >;
#endif
typedef OB::VarVar< RobotState > RobotState_var;
#ifdef OBEA_DLL
template class OPENHRP_API OB::VarOut< RobotState >;
#endif
typedef OB::VarOut< RobotState > RobotState_out;

struct OPENHRP_API RobotState
{
    RobotState() { }
    RobotState(const RobotState&);
    RobotState& operator=(const RobotState&);

    typedef RobotState_var _var_type;

    ::dsequence angle;
    ::dsequence velocity;
    ::dsequence torque;
    class OBUnique_force { };
    #ifdef OBEA_DLL
    template class OPENHRP_API OB::VarSeq< ::dsequence, OBUnique_force >;
    #endif
    typedef OB::VarSeq< ::dsequence, OBUnique_force > _force_seq;
    _force_seq force;
    class OBUnique_rate { };
    #ifdef OBEA_DLL
    template class OPENHRP_API OB::VarSeq< ::dsequence, OBUnique_rate >;
    #endif
    typedef OB::VarSeq< ::dsequence, OBUnique_rate > _rate_seq;
    _rate_seq rate;
    class OBUnique_accel { };
    #ifdef OBEA_DLL
    template class OPENHRP_API OB::VarSeq< ::dsequence, OBUnique_accel >;
    #endif
    typedef OB::VarSeq< ::dsequence, OBUnique_accel > _accel_seq;
    _accel_seq accel;
    class OBUnique_attitude { };
    #ifdef OBEA_DLL
    template class OPENHRP_API OB::VarSeq< ::dsequence, OBUnique_attitude >;
    #endif
    typedef OB::VarSeq< ::dsequence, OBUnique_attitude > _attitude_seq;
    _attitude_seq attitude;
    ::dsequence zmp;
    ::dsequence waistPos;
    ::dsequence waistRpy;
    class OBUnique_image { };
    #ifdef OBEA_DLL
    template class OPENHRP_API OB::VarSeq< ::ImageData, OBUnique_image >;
    #endif
    typedef OB::VarSeq< ::ImageData, OBUnique_image > _image_seq;
    _image_seq image;
    class OBUnique_dio { };
    #ifdef OBEA_DLL
    template class OPENHRP_API OB::FixSeq< CORBA::Long, OBUnique_dio >;
    #endif
    typedef OB::FixSeq< CORBA::Long, OBUnique_dio > _dio_seq;
    _dio_seq dio;

    void _OB_marshal(
        OBEC_OutputStreamImpl* _ob_out,
        CORBA_Environment* _ob_cev
    ) const;
    static void _OB_unmarshal(
        RobotState& _ob_v,
        OBEC_InputStreamImpl* _ob_in,
        CORBA_Environment* _ob_cev
    );

    void
    _OB_convert_to(
        void* _ob_data
    ) const;

    static void
    _OB_convert_from(
        RobotState& _ob_v,
        void* _ob_data
    );
};

extern CORBA::TypeCode_ptr _tc_RobotState;

//
// IDL:ValueMatrix:1.0
//
typedef OB::BndFixSeq< CORBA::Double, 9, OBUnique_Value > ValueMatrix;
typedef OB::SeqVar< OB::BndFixSeq< CORBA::Double, 9, OBUnique_Value > > ValueMatrix_var;
typedef OB::SeqOut< OB::BndFixSeq< CORBA::Double, 9, OBUnique_Value > > ValueMatrix_out;
extern CORBA::TypeCode_ptr _tc_ValueMatrix;

//
// IDL:SensorType:1.0
//
enum SensorType
{
    FORCE_SENSOR,
    GYRO,
    ACCELERATION_SENSOR,
    PRESSURE_SENSOR,
    PHOTO_INTERRUPTER,
    VISION_SENSOR,
    TORQUE_SENSOR
};

typedef SensorType& SensorType_out;

extern CORBA::TypeCode_ptr _tc_SensorType;

//
// IDL:SensorInfo:1.0
//
class OPENHRP_API SensorInfo : public OBCORBA::Object
{
    SensorInfo(const SensorInfo&);
    void operator=(const SensorInfo&);

protected:

    static const char* ids_[];

public:

    SensorInfo() { }
    virtual ~SensorInfo() { }

    typedef SensorInfo_ptr _ptr_type;
    typedef SensorInfo_var _var_type;

    static inline SensorInfo_ptr
    _duplicate(SensorInfo_ptr p)
    {
        if (p)
            p -> _OB_incRef();
        return p;
    }

    static inline SensorInfo_ptr
    _nil()
    {
        return 0;
    }

    static SensorInfo_ptr _narrow(CORBA::Object_ptr);

    static const char** _OB_staticIds();
    virtual const char** _OB_ids() const;

    //
    // IDL:SensorInfo/id:1.0
    //
    CORBA::Long id();

    //
    // IDL:SensorInfo/name:1.0
    //
    char* name();

    //
    // IDL:SensorInfo/type:1.0
    //
    ::SensorType type();

    //
    // IDL:SensorInfo/relPos:1.0
    //
    ::ValueMatrix* relPos();

    //
    // IDL:SensorInfo/relAttitude:1.0
    //
    ::ValueMatrix* relAttitude();

    //
    // IDL:SensorInfo/maxValue:1.0
    //
    ::ValueMatrix* maxValue();

protected:

    //
    // IDL:SensorInfo/id:1.0
    //
    CORBA::Long
    _OB_att_id(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:SensorInfo/name:1.0
    //
    char*
    _OB_att_name(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:SensorInfo/type:1.0
    //
    SensorType
    _OB_att_type(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:SensorInfo/relPos:1.0
    //
    ValueMatrix*
    _OB_att_relPos(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:SensorInfo/relAttitude:1.0
    //
    ValueMatrix*
    _OB_att_relAttitude(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:SensorInfo/maxValue:1.0
    //
    ValueMatrix*
    _OB_att_maxValue(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );
};

//
// IDL:SensorInfoSeq:1.0
//
class OBUnique_SensorInfoSeq { };

#ifdef OBEA_DLL
template class OPENHRP_API OB::ObjSeq< ::SensorInfo, OBUnique_SensorInfoSeq >;
#endif
typedef OB::ObjSeq< ::SensorInfo, OBUnique_SensorInfoSeq > SensorInfoSeq;
#ifdef OBEA_DLL
template class OPENHRP_API OB::SeqVar< OB::ObjSeq< ::SensorInfo, OBUnique_SensorInfoSeq > >;
#endif
typedef OB::SeqVar< OB::ObjSeq< ::SensorInfo, OBUnique_SensorInfoSeq > > SensorInfoSeq_var;
#ifdef OBEA_DLL
template class OPENHRP_API OB::SeqOut< OB::ObjSeq< ::SensorInfo, OBUnique_SensorInfoSeq > >;
#endif
typedef OB::SeqOut< OB::ObjSeq< ::SensorInfo, OBUnique_SensorInfoSeq > > SensorInfoSeq_out;
extern CORBA::TypeCode_ptr _tc_SensorInfoSeq;

//
// IDL:ParserModelObject:1.0
//
class OPENHRP_API ParserModelObject : public OBCORBA::Object
{
    ParserModelObject(const ParserModelObject&);
    void operator=(const ParserModelObject&);

protected:

    static const char* ids_[];

public:

    ParserModelObject() { }
    virtual ~ParserModelObject() { }

    typedef ParserModelObject_ptr _ptr_type;
    typedef ParserModelObject_var _var_type;

    static inline ParserModelObject_ptr
    _duplicate(ParserModelObject_ptr p)
    {
        if (p)
            p -> _OB_incRef();
        return p;
    }

    static inline ParserModelObject_ptr
    _nil()
    {
        return 0;
    }

    static ParserModelObject_ptr _narrow(CORBA::Object_ptr);

    static const char** _OB_staticIds();
    virtual const char** _OB_ids() const;

    //
    // IDL:ParserModelObject/positionGiven:1.0
    //
    CORBA::Boolean positionGiven();

    //
    // IDL:ParserModelObject/rotateJoint:1.0
    //
    CORBA::Boolean rotateJoint();

    //
    // IDL:ParserModelObject/mass:1.0
    //
    CORBA::Double mass();

    //
    // IDL:ParserModelObject/jointValue:1.0
    //
    CORBA::Double jointValue();

    //
    // IDL:ParserModelObject/jointVel:1.0
    //
    CORBA::Double jointVel();

    //
    // IDL:ParserModelObject/jointAcc:1.0
    //
    CORBA::Double jointAcc();

    //
    // IDL:ParserModelObject/absPos:1.0
    //
    ::ValueMatrix* absPos();

    //
    // IDL:ParserModelObject/relPos:1.0
    //
    ::ValueMatrix* relPos();

    //
    // IDL:ParserModelObject/relComPos:1.0
    //
    ::ValueMatrix* relComPos();

    //
    // IDL:ParserModelObject/absComPos:1.0
    //
    ::ValueMatrix* absComPos();

    //
    // IDL:ParserModelObject/relComAcc:1.0
    //
    ::ValueMatrix* relComAcc();

    //
    // IDL:ParserModelObject/omega:1.0
    //
    ::ValueMatrix* omega();

    //
    // IDL:ParserModelObject/omega_d:1.0
    //
    ::ValueMatrix* omega_d();

    //
    // IDL:ParserModelObject/relAcc:1.0
    //
    ::ValueMatrix* relAcc();

    //
    // IDL:ParserModelObject/absVel:1.0
    //
    ::ValueMatrix* absVel();

    //
    // IDL:ParserModelObject/absComVel:1.0
    //
    ::ValueMatrix* absComVel();

    //
    // IDL:ParserModelObject/relForce:1.0
    //
    ::ValueMatrix* relForce();

    //
    // IDL:ParserModelObject/relTorque:1.0
    //
    ::ValueMatrix* relTorque();

    //
    // IDL:ParserModelObject/absAttitude:1.0
    //
    ::ValueMatrix* absAttitude();

    //
    // IDL:ParserModelObject/relAttitude:1.0
    //
    ::ValueMatrix* relAttitude();

    //
    // IDL:ParserModelObject/inertia:1.0
    //
    ::ValueMatrix* inertia();

    //
    // IDL:ParserModelObject/dh:1.0
    //
    ::Value* dh();

    //
    // IDL:ParserModelObject/ulimit:1.0
    //
    ::Value* ulimit();

    //
    // IDL:ParserModelObject/llimit:1.0
    //
    ::Value* llimit();

    //
    // IDL:ParserModelObject/uvlimit:1.0
    //
    ::Value* uvlimit();

    //
    // IDL:ParserModelObject/lvlimit:1.0
    //
    ::Value* lvlimit();

    //
    // IDL:ParserModelObject/rotorInertia:1.0
    //
    CORBA::Double rotorInertia();

    //
    // IDL:ParserModelObject/rotorResistor:1.0
    //
    CORBA::Double rotorResistor();

    //
    // IDL:ParserModelObject/gearRatio:1.0
    //
    CORBA::Double gearRatio();

    //
    // IDL:ParserModelObject/torqueConst:1.0
    //
    CORBA::Double torqueConst();

    //
    // IDL:ParserModelObject/encoderPulse:1.0
    //
    CORBA::Double encoderPulse();

    //
    // IDL:ParserModelObject/bboxCenter:1.0
    //
    ::Value* bboxCenter();

    //
    // IDL:ParserModelObject/bboxSize:1.0
    //
    ::Value* bboxSize();

    //
    // IDL:ParserModelObject/name:1.0
    //
    char* name();

    //
    // IDL:ParserModelObject/jointType:1.0
    //
    char* jointType();

    //
    // IDL:ParserModelObject/jointId:1.0
    //
    CORBA::Short jointId();

    //
    // IDL:ParserModelObject/jointAxis:1.0
    //
    char* jointAxis();

    //
    // IDL:ParserModelObject/mother:1.0
    //
    CORBA::Long mother();

    //
    // IDL:ParserModelObject/sister:1.0
    //
    CORBA::Long sister();

    //
    // IDL:ParserModelObject/daughter:1.0
    //
    CORBA::Long daughter();

    //
    // IDL:ParserModelObject/sensors:1.0
    //
    ::SensorInfoSeq* sensors();

protected:

    //
    // IDL:ParserModelObject/positionGiven:1.0
    //
    CORBA::Boolean
    _OB_att_positionGiven(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/rotateJoint:1.0
    //
    CORBA::Boolean
    _OB_att_rotateJoint(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/mass:1.0
    //
    CORBA::Double
    _OB_att_mass(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/jointValue:1.0
    //
    CORBA::Double
    _OB_att_jointValue(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/jointVel:1.0
    //
    CORBA::Double
    _OB_att_jointVel(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/jointAcc:1.0
    //
    CORBA::Double
    _OB_att_jointAcc(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/absPos:1.0
    //
    ValueMatrix*
    _OB_att_absPos(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/relPos:1.0
    //
    ValueMatrix*
    _OB_att_relPos(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/relComPos:1.0
    //
    ValueMatrix*
    _OB_att_relComPos(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/absComPos:1.0
    //
    ValueMatrix*
    _OB_att_absComPos(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/relComAcc:1.0
    //
    ValueMatrix*
    _OB_att_relComAcc(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/omega:1.0
    //
    ValueMatrix*
    _OB_att_omega(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/omega_d:1.0
    //
    ValueMatrix*
    _OB_att_omega_d(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/relAcc:1.0
    //
    ValueMatrix*
    _OB_att_relAcc(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/absVel:1.0
    //
    ValueMatrix*
    _OB_att_absVel(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/absComVel:1.0
    //
    ValueMatrix*
    _OB_att_absComVel(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/relForce:1.0
    //
    ValueMatrix*
    _OB_att_relForce(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/relTorque:1.0
    //
    ValueMatrix*
    _OB_att_relTorque(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/absAttitude:1.0
    //
    ValueMatrix*
    _OB_att_absAttitude(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/relAttitude:1.0
    //
    ValueMatrix*
    _OB_att_relAttitude(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/inertia:1.0
    //
    ValueMatrix*
    _OB_att_inertia(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/dh:1.0
    //
    Value*
    _OB_att_dh(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/ulimit:1.0
    //
    Value*
    _OB_att_ulimit(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/llimit:1.0
    //
    Value*
    _OB_att_llimit(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/uvlimit:1.0
    //
    Value*
    _OB_att_uvlimit(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/lvlimit:1.0
    //
    Value*
    _OB_att_lvlimit(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/rotorInertia:1.0
    //
    CORBA::Double
    _OB_att_rotorInertia(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/rotorResistor:1.0
    //
    CORBA::Double
    _OB_att_rotorResistor(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/gearRatio:1.0
    //
    CORBA::Double
    _OB_att_gearRatio(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/torqueConst:1.0
    //
    CORBA::Double
    _OB_att_torqueConst(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/encoderPulse:1.0
    //
    CORBA::Double
    _OB_att_encoderPulse(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/bboxCenter:1.0
    //
    Value*
    _OB_att_bboxCenter(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/bboxSize:1.0
    //
    Value*
    _OB_att_bboxSize(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/name:1.0
    //
    char*
    _OB_att_name(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/jointType:1.0
    //
    char*
    _OB_att_jointType(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/jointId:1.0
    //
    CORBA::Short
    _OB_att_jointId(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/jointAxis:1.0
    //
    char*
    _OB_att_jointAxis(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/mother:1.0
    //
    CORBA::Long
    _OB_att_mother(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/sister:1.0
    //
    CORBA::Long
    _OB_att_sister(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/daughter:1.0
    //
    CORBA::Long
    _OB_att_daughter(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserModelObject/sensors:1.0
    //
    SensorInfoSeq*
    _OB_att_sensors(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );
};

//
// IDL:stringSeq:1.0
//
class OBUnique_stringSeq { };

#ifdef OBEA_DLL
template class OPENHRP_API OB::StrSeq< OBUnique_stringSeq >;
#endif
typedef OB::StrSeq< OBUnique_stringSeq > stringSeq;
#ifdef OBEA_DLL
template class OPENHRP_API OB::SeqVar< OB::StrSeq< OBUnique_stringSeq > >;
#endif
typedef OB::SeqVar< OB::StrSeq< OBUnique_stringSeq > > stringSeq_var;
#ifdef OBEA_DLL
template class OPENHRP_API OB::SeqOut< OB::StrSeq< OBUnique_stringSeq > >;
#endif
typedef OB::SeqOut< OB::StrSeq< OBUnique_stringSeq > > stringSeq_out;
extern CORBA::TypeCode_ptr _tc_stringSeq;

//
// IDL:ParserModelObjectSeq:1.0
//
class OBUnique_ParserModelObjectSeq { };

#ifdef OBEA_DLL
template class OPENHRP_API OB::ObjSeq< ::ParserModelObject, OBUnique_ParserModelObjectSeq >;
#endif
typedef OB::ObjSeq< ::ParserModelObject, OBUnique_ParserModelObjectSeq > ParserModelObjectSeq;
#ifdef OBEA_DLL
template class OPENHRP_API OB::SeqVar< OB::ObjSeq< ::ParserModelObject, OBUnique_ParserModelObjectSeq > >;
#endif
typedef OB::SeqVar< OB::ObjSeq< ::ParserModelObject, OBUnique_ParserModelObjectSeq > > ParserModelObjectSeq_var;
#ifdef OBEA_DLL
template class OPENHRP_API OB::SeqOut< OB::ObjSeq< ::ParserModelObject, OBUnique_ParserModelObjectSeq > >;
#endif
typedef OB::SeqOut< OB::ObjSeq< ::ParserModelObject, OBUnique_ParserModelObjectSeq > > ParserModelObjectSeq_out;
extern CORBA::TypeCode_ptr _tc_ParserModelObjectSeq;

//
// IDL:ParserCharObject:1.0
//
class OPENHRP_API ParserCharObject : public OBCORBA::Object
{
    ParserCharObject(const ParserCharObject&);
    void operator=(const ParserCharObject&);

protected:

    static const char* ids_[];

public:

    ParserCharObject() { }
    virtual ~ParserCharObject() { }

    typedef ParserCharObject_ptr _ptr_type;
    typedef ParserCharObject_var _var_type;

    static inline ParserCharObject_ptr
    _duplicate(ParserCharObject_ptr p)
    {
        if (p)
            p -> _OB_incRef();
        return p;
    }

    static inline ParserCharObject_ptr
    _nil()
    {
        return 0;
    }

    static ParserCharObject_ptr _narrow(CORBA::Object_ptr);

    static const char** _OB_staticIds();
    virtual const char** _OB_ids() const;

    //
    // IDL:ParserCharObject/name:1.0
    //
    char* name();

    //
    // IDL:ParserCharObject/info:1.0
    //
    ::stringSeq* info();

    //
    // IDL:ParserCharObject/modelObjectSeq:1.0
    //
    ::ParserModelObjectSeq* modelObjectSeq();

protected:

    //
    // IDL:ParserCharObject/name:1.0
    //
    char*
    _OB_att_name(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserCharObject/info:1.0
    //
    stringSeq*
    _OB_att_info(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ParserCharObject/modelObjectSeq:1.0
    //
    ParserModelObjectSeq*
    _OB_att_modelObjectSeq(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );
};

//
// IDL:ModelInfo:1.0
//
class OPENHRP_API ModelInfo : public OBCORBA::Object
{
    ModelInfo(const ModelInfo&);
    void operator=(const ModelInfo&);

protected:

    static const char* ids_[];

public:

    ModelInfo() { }
    virtual ~ModelInfo() { }

    typedef ModelInfo_ptr _ptr_type;
    typedef ModelInfo_var _var_type;

    static inline ModelInfo_ptr
    _duplicate(ModelInfo_ptr p)
    {
        if (p)
            p -> _OB_incRef();
        return p;
    }

    static inline ModelInfo_ptr
    _nil()
    {
        return 0;
    }

    static ModelInfo_ptr _narrow(CORBA::Object_ptr);

    static const char** _OB_staticIds();
    virtual const char** _OB_ids() const;

    //
    // IDL:ModelInfo/floatSeq:1.0
    //
    class OBUnique_floatSeq { };

    #ifdef OBEA_DLL
    template class OPENHRP_API OB::FixSeq< CORBA::Float, OBUnique_floatSeq >;
    #endif
    typedef OB::FixSeq< CORBA::Float, OBUnique_floatSeq > floatSeq;
    #ifdef OBEA_DLL
    template class OPENHRP_API OB::SeqVar< OB::FixSeq< CORBA::Float, OBUnique_floatSeq > >;
    #endif
    typedef OB::SeqVar< OB::FixSeq< CORBA::Float, OBUnique_floatSeq > > floatSeq_var;
    #ifdef OBEA_DLL
    template class OPENHRP_API OB::SeqOut< OB::FixSeq< CORBA::Float, OBUnique_floatSeq > >;
    #endif
    typedef OB::SeqOut< OB::FixSeq< CORBA::Float, OBUnique_floatSeq > > floatSeq_out;
    static CORBA::TypeCode_ptr _tc_floatSeq;

    //
    // IDL:ModelInfo/NameSeq:1.0
    //
    class OBUnique_NameSeq { };

    #ifdef OBEA_DLL
    template class OPENHRP_API OB::StrSeq< OBUnique_NameSeq >;
    #endif
    typedef OB::StrSeq< OBUnique_NameSeq > NameSeq;
    #ifdef OBEA_DLL
    template class OPENHRP_API OB::SeqVar< OB::StrSeq< OBUnique_NameSeq > >;
    #endif
    typedef OB::SeqVar< OB::StrSeq< OBUnique_NameSeq > > NameSeq_var;
    #ifdef OBEA_DLL
    template class OPENHRP_API OB::SeqOut< OB::StrSeq< OBUnique_NameSeq > >;
    #endif
    typedef OB::SeqOut< OB::StrSeq< OBUnique_NameSeq > > NameSeq_out;
    static CORBA::TypeCode_ptr _tc_NameSeq;

    //
    // IDL:ModelInfo/getUrl:1.0
    //
    char* getUrl();

    //
    // IDL:ModelInfo/getCharObject:1.0
    //
    ::ParserCharObject_ptr getCharObject();

    //
    // IDL:ModelInfo/getJointList:1.0
    //
    ::ModelInfo::NameSeq* getJointList();

    //
    // IDL:ModelInfo/readTriangles:1.0
    //
    ::ModelInfo::floatSeq* readTriangles(const char* jointName,
                                         CORBA::Long count);

    //
    // IDL:ModelInfo/destroy:1.0
    //
    void destroy();

protected:

    //
    // IDL:ModelInfo/getUrl:1.0
    //
    char*
    _OB_op_getUrl(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ModelInfo/getCharObject:1.0
    //
    ::ParserCharObject_ptr
    _OB_op_getCharObject(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ModelInfo/getJointList:1.0
    //
    ::ModelInfo::NameSeq*
    _OB_op_getJointList(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ModelInfo/readTriangles:1.0
    //
    ::ModelInfo::floatSeq*
    _OB_op_readTriangles(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        const char* jointName,
        CORBA::Long count,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:ModelInfo/destroy:1.0
    //
    void
    _OB_op_destroy(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );
};

//
// IDL:OpenHRPObject:1.0
//
class OPENHRP_API OpenHRPObject : public OBCORBA::Object
{
    OpenHRPObject(const OpenHRPObject&);
    void operator=(const OpenHRPObject&);

protected:

    static const char* ids_[];

public:

    OpenHRPObject() { }
    virtual ~OpenHRPObject() { }

    typedef OpenHRPObject_ptr _ptr_type;
    typedef OpenHRPObject_var _var_type;

    static inline OpenHRPObject_ptr
    _duplicate(OpenHRPObject_ptr p)
    {
        if (p)
            p -> _OB_incRef();
        return p;
    }

    static inline OpenHRPObject_ptr
    _nil()
    {
        return 0;
    }

    static OpenHRPObject_ptr _narrow(CORBA::Object_ptr);

    static const char** _OB_staticIds();
    virtual const char** _OB_ids() const;

    //
    // IDL:OpenHRPObject/shutdown:1.0
    //
    void shutdown();

protected:

    //
    // IDL:OpenHRPObject/shutdown:1.0
    //
    void
    _OB_op_shutdown(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );
};

//
// IDL:CommandReceiver:1.0
//
class OPENHRP_API CommandReceiver : public OBCORBA::Object
{
    CommandReceiver(const CommandReceiver&);
    void operator=(const CommandReceiver&);

protected:

    static const char* ids_[];

public:

    CommandReceiver() { }
    virtual ~CommandReceiver() { }

    typedef CommandReceiver_ptr _ptr_type;
    typedef CommandReceiver_var _var_type;

    static inline CommandReceiver_ptr
    _duplicate(CommandReceiver_ptr p)
    {
        if (p)
            p -> _OB_incRef();
        return p;
    }

    static inline CommandReceiver_ptr
    _nil()
    {
        return 0;
    }

    static CommandReceiver_ptr _narrow(CORBA::Object_ptr);

    static const char** _OB_staticIds();
    virtual const char** _OB_ids() const;

    //
    // IDL:CommandReceiver/sendMsg:1.0
    //
    void sendMsg(const char* msg);

protected:

    //
    // IDL:CommandReceiver/sendMsg:1.0
    //
    void
    _OB_op_sendMsg(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        const char* msg,
        CORBA_Environment* _ob_cev
    );
};

//
// IDL:Plugin:1.0
//
class OPENHRP_API Plugin : public ::CommandReceiver
{
    Plugin(const Plugin&);
    void operator=(const Plugin&);

protected:

    static const char* ids_[];

public:

    Plugin() { }
    virtual ~Plugin() { }

    typedef Plugin_ptr _ptr_type;
    typedef Plugin_var _var_type;

    static inline Plugin_ptr
    _duplicate(Plugin_ptr p)
    {
        if (p)
            p -> _OB_incRef();
        return p;
    }

    static inline Plugin_ptr
    _nil()
    {
        return 0;
    }

    static Plugin_ptr _narrow(CORBA::Object_ptr);

    static const char** _OB_staticIds();
    virtual const char** _OB_ids() const;

    //
    // IDL:Plugin/start:1.0
    //
    void start();

    //
    // IDL:Plugin/stop:1.0
    //
    void stop();

protected:

    //
    // IDL:Plugin/start:1.0
    //
    void
    _OB_op_start(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:Plugin/stop:1.0
    //
    void
    _OB_op_stop(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );
};

//
// IDL:PluginManager:1.0
//
class OPENHRP_API PluginManager : public ::CommandReceiver
{
    PluginManager(const PluginManager&);
    void operator=(const PluginManager&);

protected:

    static const char* ids_[];

public:

    PluginManager() { }
    virtual ~PluginManager() { }

    typedef PluginManager_ptr _ptr_type;
    typedef PluginManager_var _var_type;

    static inline PluginManager_ptr
    _duplicate(PluginManager_ptr p)
    {
        if (p)
            p -> _OB_incRef();
        return p;
    }

    static inline PluginManager_ptr
    _nil()
    {
        return 0;
    }

    static PluginManager_ptr _narrow(CORBA::Object_ptr);

    static const char** _OB_staticIds();
    virtual const char** _OB_ids() const;

    //
    // IDL:PluginManager/load:1.0
    //
    void load(const char* name);

    //
    // IDL:PluginManager/create:1.0
    //
    ::Plugin_ptr create(const char* pclass,
                        const char* name,
                        const char* args);

    //
    // IDL:PluginManager/getPluginNames:1.0
    //
    ::stringSeq* getPluginNames();

protected:

    //
    // IDL:PluginManager/load:1.0
    //
    void
    _OB_op_load(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        const char* name,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:PluginManager/create:1.0
    //
    ::Plugin_ptr
    _OB_op_create(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        const char* pclass,
        const char* name,
        const char* args,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:PluginManager/getPluginNames:1.0
    //
    ::stringSeq*
    _OB_op_getPluginNames(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );
};

//
// IDL:TorqueSeq:1.0
//
void operator<<=(CORBA::Any&, TorqueSeq*);
void operator<<=(CORBA::Any&, const TorqueSeq&);
CORBA::Boolean operator>>=(const CORBA::Any&, const TorqueSeq*&);

inline void
operator<<=(CORBA::Any_var& any, TorqueSeq* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const TorqueSeq& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const TorqueSeq*& val)
{
    return any.in() >>= val;
}

//
// IDL:DataId:1.0
//
void operator<<=(CORBA::Any&, DataId);
CORBA::Boolean operator>>=(const CORBA::Any&, DataId&);

inline void
operator<<=(CORBA::Any_var& any, DataId val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, DataId& val)
{
    return any.in() >>= val;
}

//
// IDL:LinkData:1.0
//
void operator<<=(CORBA::Any&, const LinkData_forany&);
CORBA::Boolean operator>>=(const CORBA::Any&, LinkData_forany&);

inline void
operator<<=(CORBA::Any_var& any, const LinkData_forany& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, LinkData_forany& val)
{
    return any.in() >>= val;
}

//
// IDL:LinkDataSeq:1.0
//
void operator<<=(CORBA::Any&, LinkDataSeq*);
void operator<<=(CORBA::Any&, const LinkDataSeq&);
CORBA::Boolean operator>>=(const CORBA::Any&, const LinkDataSeq*&);

inline void
operator<<=(CORBA::Any_var& any, LinkDataSeq* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const LinkDataSeq& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const LinkDataSeq*& val)
{
    return any.in() >>= val;
}

//
// IDL:Value:1.0
//
void operator<<=(CORBA::Any&, Value*);
void operator<<=(CORBA::Any&, const Value&);
CORBA::Boolean operator>>=(const CORBA::Any&, const Value*&);

inline void
operator<<=(CORBA::Any_var& any, Value* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const Value& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const Value*& val)
{
    return any.in() >>= val;
}

//
// IDL:FSValue:1.0
//
void operator<<=(CORBA::Any&, FSValue*);
void operator<<=(CORBA::Any&, const FSValue&);
CORBA::Boolean operator>>=(const CORBA::Any&, const FSValue*&);

inline void
operator<<=(CORBA::Any_var& any, FSValue* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const FSValue& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const FSValue*& val)
{
    return any.in() >>= val;
}

//
// IDL:LinkNameSeq:1.0
//
void operator<<=(CORBA::Any&, LinkNameSeq*);
void operator<<=(CORBA::Any&, const LinkNameSeq&);
CORBA::Boolean operator>>=(const CORBA::Any&, const LinkNameSeq*&);

inline void
operator<<=(CORBA::Any_var& any, LinkNameSeq* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const LinkNameSeq& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const LinkNameSeq*& val)
{
    return any.in() >>= val;
}

//
// IDL:Transform:1.0
//
void operator<<=(CORBA::Any&, Transform*);
void operator<<=(CORBA::Any&, const Transform&);
CORBA::Boolean operator>>=(const CORBA::Any&, const Transform*&);

inline void
operator<<=(CORBA::Any_var& any, Transform* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const Transform& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const Transform*& val)
{
    return any.in() >>= val;
}

//
// IDL:TransformQuaternion:1.0
//
void operator<<=(CORBA::Any&, TransformQuaternion*);
void operator<<=(CORBA::Any&, const TransformQuaternion&);
CORBA::Boolean operator>>=(const CORBA::Any&, const TransformQuaternion*&);

inline void
operator<<=(CORBA::Any_var& any, TransformQuaternion* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const TransformQuaternion& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const TransformQuaternion*& val)
{
    return any.in() >>= val;
}

//
// IDL:LinkInfo:1.0
//
void operator<<=(CORBA::Any&, LinkInfo*);
void operator<<=(CORBA::Any&, const LinkInfo&);
CORBA::Boolean operator>>=(const CORBA::Any&, const LinkInfo*&);

inline void
operator<<=(CORBA::Any_var& any, LinkInfo* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const LinkInfo& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const LinkInfo*& val)
{
    return any.in() >>= val;
}

//
// IDL:LinkValue:1.0
//
void operator<<=(CORBA::Any&, LinkValue*);
void operator<<=(CORBA::Any&, const LinkValue&);
CORBA::Boolean operator>>=(const CORBA::Any&, const LinkValue*&);

inline void
operator<<=(CORBA::Any_var& any, LinkValue* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const LinkValue& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const LinkValue*& val)
{
    return any.in() >>= val;
}

//
// IDL:LinkValueSeq:1.0
//
void operator<<=(CORBA::Any&, LinkValueSeq*);
void operator<<=(CORBA::Any&, const LinkValueSeq&);
CORBA::Boolean operator>>=(const CORBA::Any&, const LinkValueSeq*&);

inline void
operator<<=(CORBA::Any_var& any, LinkValueSeq* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const LinkValueSeq& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const LinkValueSeq*& val)
{
    return any.in() >>= val;
}

//
// IDL:LinkInfoSeq:1.0
//
void operator<<=(CORBA::Any&, LinkInfoSeq*);
void operator<<=(CORBA::Any&, const LinkInfoSeq&);
CORBA::Boolean operator>>=(const CORBA::Any&, const LinkInfoSeq*&);

inline void
operator<<=(CORBA::Any_var& any, LinkInfoSeq* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const LinkInfoSeq& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const LinkInfoSeq*& val)
{
    return any.in() >>= val;
}

//
// IDL:Vector3:1.0
//
void operator<<=(CORBA::Any&, const Vector3_forany&);
CORBA::Boolean operator>>=(const CORBA::Any&, Vector3_forany&);

inline void
operator<<=(CORBA::Any_var& any, const Vector3_forany& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, Vector3_forany& val)
{
    return any.in() >>= val;
}

//
// IDL:CollisionData:1.0
//
void operator<<=(CORBA::Any&, CollisionData*);
void operator<<=(CORBA::Any&, const CollisionData&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CollisionData*&);

inline void
operator<<=(CORBA::Any_var& any, CollisionData* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CollisionData& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CollisionData*& val)
{
    return any.in() >>= val;
}

//
// IDL:CollisionDataSeq:1.0
//
void operator<<=(CORBA::Any&, CollisionDataSeq*);
void operator<<=(CORBA::Any&, const CollisionDataSeq&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CollisionDataSeq*&);

inline void
operator<<=(CORBA::Any_var& any, CollisionDataSeq* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CollisionDataSeq& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CollisionDataSeq*& val)
{
    return any.in() >>= val;
}

//
// IDL:WorldState:1.0
//
void operator<<=(CORBA::Any&, WorldState*);
void operator<<=(CORBA::Any&, const WorldState&);
CORBA::Boolean operator>>=(const CORBA::Any&, const WorldState*&);

inline void
operator<<=(CORBA::Any_var& any, WorldState* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const WorldState& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const WorldState*& val)
{
    return any.in() >>= val;
}

//
// IDL:dsequence:1.0
//
void operator<<=(CORBA::Any&, dsequence*);
void operator<<=(CORBA::Any&, const dsequence&);
CORBA::Boolean operator>>=(const CORBA::Any&, const dsequence*&);

inline void
operator<<=(CORBA::Any_var& any, dsequence* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const dsequence& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const dsequence*& val)
{
    return any.in() >>= val;
}

//
// IDL:PixelFormat:1.0
//
void operator<<=(CORBA::Any&, PixelFormat);
CORBA::Boolean operator>>=(const CORBA::Any&, PixelFormat&);

inline void
operator<<=(CORBA::Any_var& any, PixelFormat val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, PixelFormat& val)
{
    return any.in() >>= val;
}

//
// IDL:ImageData:1.0
//
void operator<<=(CORBA::Any&, ImageData*);
void operator<<=(CORBA::Any&, const ImageData&);
CORBA::Boolean operator>>=(const CORBA::Any&, const ImageData*&);

inline void
operator<<=(CORBA::Any_var& any, ImageData* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const ImageData& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const ImageData*& val)
{
    return any.in() >>= val;
}

//
// IDL:RobotState:1.0
//
void operator<<=(CORBA::Any&, RobotState*);
void operator<<=(CORBA::Any&, const RobotState&);
CORBA::Boolean operator>>=(const CORBA::Any&, const RobotState*&);

inline void
operator<<=(CORBA::Any_var& any, RobotState* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const RobotState& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const RobotState*& val)
{
    return any.in() >>= val;
}

//
// IDL:SensorType:1.0
//
void operator<<=(CORBA::Any&, SensorType);
CORBA::Boolean operator>>=(const CORBA::Any&, SensorType&);

inline void
operator<<=(CORBA::Any_var& any, SensorType val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, SensorType& val)
{
    return any.in() >>= val;
}

//
// IDL:SensorInfo:1.0
//
namespace CORBA
{

inline void
release(::SensorInfo_ptr p)
{
    if (p)
        p -> _OB_decRef();
}

inline Boolean
is_nil(::SensorInfo_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(CORBA::Any&, SensorInfo_ptr*);
void operator<<=(CORBA::Any&, SensorInfo_ptr);
CORBA::Boolean operator>>=(const CORBA::Any&, SensorInfo_ptr&);

inline void
operator<<=(CORBA::Any_var& any, SensorInfo_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, SensorInfo_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, SensorInfo_ptr& val)
{
    return any.in() >>= val;
}

//
// IDL:SensorInfoSeq:1.0
//
void operator<<=(CORBA::Any&, SensorInfoSeq*);
void operator<<=(CORBA::Any&, const SensorInfoSeq&);
CORBA::Boolean operator>>=(const CORBA::Any&, const SensorInfoSeq*&);

inline void
operator<<=(CORBA::Any_var& any, SensorInfoSeq* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const SensorInfoSeq& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const SensorInfoSeq*& val)
{
    return any.in() >>= val;
}

//
// IDL:ParserModelObject:1.0
//
namespace CORBA
{

inline void
release(::ParserModelObject_ptr p)
{
    if (p)
        p -> _OB_decRef();
}

inline Boolean
is_nil(::ParserModelObject_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(CORBA::Any&, ParserModelObject_ptr*);
void operator<<=(CORBA::Any&, ParserModelObject_ptr);
CORBA::Boolean operator>>=(const CORBA::Any&, ParserModelObject_ptr&);

inline void
operator<<=(CORBA::Any_var& any, ParserModelObject_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, ParserModelObject_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, ParserModelObject_ptr& val)
{
    return any.in() >>= val;
}

//
// IDL:stringSeq:1.0
//
void operator<<=(CORBA::Any&, stringSeq*);
void operator<<=(CORBA::Any&, const stringSeq&);
CORBA::Boolean operator>>=(const CORBA::Any&, const stringSeq*&);

inline void
operator<<=(CORBA::Any_var& any, stringSeq* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const stringSeq& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const stringSeq*& val)
{
    return any.in() >>= val;
}

//
// IDL:ParserModelObjectSeq:1.0
//
void operator<<=(CORBA::Any&, ParserModelObjectSeq*);
void operator<<=(CORBA::Any&, const ParserModelObjectSeq&);
CORBA::Boolean operator>>=(const CORBA::Any&, const ParserModelObjectSeq*&);

inline void
operator<<=(CORBA::Any_var& any, ParserModelObjectSeq* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const ParserModelObjectSeq& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const ParserModelObjectSeq*& val)
{
    return any.in() >>= val;
}

//
// IDL:ParserCharObject:1.0
//
namespace CORBA
{

inline void
release(::ParserCharObject_ptr p)
{
    if (p)
        p -> _OB_decRef();
}

inline Boolean
is_nil(::ParserCharObject_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(CORBA::Any&, ParserCharObject_ptr*);
void operator<<=(CORBA::Any&, ParserCharObject_ptr);
CORBA::Boolean operator>>=(const CORBA::Any&, ParserCharObject_ptr&);

inline void
operator<<=(CORBA::Any_var& any, ParserCharObject_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, ParserCharObject_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, ParserCharObject_ptr& val)
{
    return any.in() >>= val;
}

//
// IDL:ModelInfo:1.0
//
namespace CORBA
{

inline void
release(::ModelInfo_ptr p)
{
    if (p)
        p -> _OB_decRef();
}

inline Boolean
is_nil(::ModelInfo_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(CORBA::Any&, ModelInfo_ptr*);
void operator<<=(CORBA::Any&, ModelInfo_ptr);
CORBA::Boolean operator>>=(const CORBA::Any&, ModelInfo_ptr&);

inline void
operator<<=(CORBA::Any_var& any, ModelInfo_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, ModelInfo_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, ModelInfo_ptr& val)
{
    return any.in() >>= val;
}

//
// IDL:ModelInfo/floatSeq:1.0
//
void operator<<=(CORBA::Any&, ModelInfo::floatSeq*);
void operator<<=(CORBA::Any&, const ModelInfo::floatSeq&);
CORBA::Boolean operator>>=(const CORBA::Any&, const ModelInfo::floatSeq*&);

inline void
operator<<=(CORBA::Any_var& any, ModelInfo::floatSeq* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const ModelInfo::floatSeq& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const ModelInfo::floatSeq*& val)
{
    return any.in() >>= val;
}

//
// IDL:ModelInfo/NameSeq:1.0
//
void operator<<=(CORBA::Any&, ModelInfo::NameSeq*);
void operator<<=(CORBA::Any&, const ModelInfo::NameSeq&);
CORBA::Boolean operator>>=(const CORBA::Any&, const ModelInfo::NameSeq*&);

inline void
operator<<=(CORBA::Any_var& any, ModelInfo::NameSeq* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const ModelInfo::NameSeq& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const ModelInfo::NameSeq*& val)
{
    return any.in() >>= val;
}

//
// IDL:OpenHRPObject:1.0
//
namespace CORBA
{

inline void
release(::OpenHRPObject_ptr p)
{
    if (p)
        p -> _OB_decRef();
}

inline Boolean
is_nil(::OpenHRPObject_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(CORBA::Any&, OpenHRPObject_ptr*);
void operator<<=(CORBA::Any&, OpenHRPObject_ptr);
CORBA::Boolean operator>>=(const CORBA::Any&, OpenHRPObject_ptr&);

inline void
operator<<=(CORBA::Any_var& any, OpenHRPObject_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, OpenHRPObject_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, OpenHRPObject_ptr& val)
{
    return any.in() >>= val;
}

//
// IDL:CommandReceiver:1.0
//
namespace CORBA
{

inline void
release(::CommandReceiver_ptr p)
{
    if (p)
        p -> _OB_decRef();
}

inline Boolean
is_nil(::CommandReceiver_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(CORBA::Any&, CommandReceiver_ptr*);
void operator<<=(CORBA::Any&, CommandReceiver_ptr);
CORBA::Boolean operator>>=(const CORBA::Any&, CommandReceiver_ptr&);

inline void
operator<<=(CORBA::Any_var& any, CommandReceiver_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, CommandReceiver_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, CommandReceiver_ptr& val)
{
    return any.in() >>= val;
}

//
// IDL:Plugin:1.0
//
namespace CORBA
{

inline void
release(::Plugin_ptr p)
{
    if (p)
        p -> _OB_decRef();
}

inline Boolean
is_nil(::Plugin_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(CORBA::Any&, Plugin_ptr*);
void operator<<=(CORBA::Any&, Plugin_ptr);
CORBA::Boolean operator>>=(const CORBA::Any&, Plugin_ptr&);

inline void
operator<<=(CORBA::Any_var& any, Plugin_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, Plugin_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, Plugin_ptr& val)
{
    return any.in() >>= val;
}

//
// IDL:PluginManager:1.0
//
namespace CORBA
{

inline void
release(::PluginManager_ptr p)
{
    if (p)
        p -> _OB_decRef();
}

inline Boolean
is_nil(::PluginManager_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(CORBA::Any&, PluginManager_ptr*);
void operator<<=(CORBA::Any&, PluginManager_ptr);
CORBA::Boolean operator>>=(const CORBA::Any&, PluginManager_ptr&);

inline void
operator<<=(CORBA::Any_var& any, PluginManager_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, PluginManager_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, PluginManager_ptr& val)
{
    return any.in() >>= val;
}

#endif
