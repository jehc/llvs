// **********************************************************************
//
// Generated by the Orbix/E IDL-to-C++ Translator
//
// Copyright (c) 2003
// IONA Technologies, Inc.
// Waltham, MA, USA
//
// All Rights Reserved
//
// **********************************************************************

// Version: 2.2.0

#include <OBE/CORBAClient.h>
#include <Scene.h>

#ifndef OBEC_INTEGER_VERSION
#   error No Orbix/E version defined! Is <OBE/CORBA.h> included?
#endif

#ifndef OBEC_NO_VERSION_CHECK
#   if (OBEC_INTEGER_VERSION != 2020000L)
#       error Orbix/E version mismatch!
#   endif
#endif

extern "C"
{

typedef struct _OBE_C_DoubleMatrix _OBE_C_DoubleMatrix;


#ifndef __OBE_C_CORBA_sequence_double_defined
#define __OBE_C_CORBA_sequence_double_defined
typedef struct
{
    CORBA_unsigned_long _maximum;
    CORBA_unsigned_long _length;
    CORBA_double* _buffer;
    CORBA_boolean _release;
} _OBE_C_CORBA_sequence_double;
#endif

struct _OBE_C_DoubleMatrix
{
    CORBA_long nrows;
    CORBA_long ncols;
    _OBE_C_CORBA_sequence_double data;
};

#ifndef __OBE_C_CORBA_sequence_octet_defined
#define __OBE_C_CORBA_sequence_octet_defined
typedef struct
{
    CORBA_unsigned_long _maximum;
    CORBA_unsigned_long _length;
    CORBA_octet* _buffer;
    CORBA_boolean _release;
} _OBE_C_CORBA_sequence_octet;
#endif

typedef _OBE_C_CORBA_sequence_octet _OBE_C_IdentifierInformation;

typedef struct _OBE_C_SceneFeature _OBE_C_SceneFeature;

struct _OBE_C_SceneFeature
{
    _OBE_C_DoubleMatrix y;
    _OBE_C_DoubleMatrix Pyy;
    CORBA_long label;
    CORBA_boolean SuccessfulMeasurementFlag;
    CORBA_boolean SelectedFlag;
    _OBE_C_DoubleMatrix h;
    _OBE_C_DoubleMatrix z;
    _OBE_C_DoubleMatrix S;
    _OBE_C_IdentifierInformation Identifier;
};

#ifndef __OBE_C_CORBA_sequence__OBE_C_SceneFeature_defined
#define __OBE_C_CORBA_sequence__OBE_C_SceneFeature_defined
typedef struct
{
    CORBA_unsigned_long _maximum;
    CORBA_unsigned_long _length;
    _OBE_C_SceneFeature* _buffer;
    CORBA_boolean _release;
} _OBE_C_CORBA_sequence__OBE_C_SceneFeature;
#endif

typedef _OBE_C_CORBA_sequence__OBE_C_SceneFeature _OBE_C_SceneFeatureSeq;

typedef struct _OBE_C_SceneObject _OBE_C_SceneObject;

struct _OBE_C_SceneObject
{
    _OBE_C_SceneFeatureSeq Features;
    _OBE_C_DoubleMatrix xv;
    _OBE_C_DoubleMatrix Pxx;
    CORBA_long NoFeatures;
    CORBA_long NoSelected;
};
}

//
// IDL:DoubleMatrix:1.0
//

extern _CORBA_TypeCode _OB_TC__OBE_C_DoubleMatrix;

static _CORBA_TypeCode _OB_TC_0__OBE_C_DoubleMatrix =
{
    CORBA_tk_long,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC_1__OBE_C_DoubleMatrix =
{
    CORBA_tk_double,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC_2__OBE_C_DoubleMatrix =
{
    CORBA_tk_sequence,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_1__OBE_C_DoubleMatrix,
    OBEC_TRUE
};

static _CORBA_TypeCode* _OB_TC__OBE_C_DoubleMatrix__OB_tc_member_types[] =
{
    &_OB_TC_0__OBE_C_DoubleMatrix,
    &_OB_TC_0__OBE_C_DoubleMatrix,
    &_OB_TC_2__OBE_C_DoubleMatrix
};

static char* _OB_TC__OBE_C_DoubleMatrix__OB_tc_member_names[] =
{
    (char*)"nrows",
    (char*)"ncols",
    (char*)"data"
};

_CORBA_TypeCode _OB_TC__OBE_C_DoubleMatrix =
{
    CORBA_tk_struct,
    (char*)"IDL:DoubleMatrix:1.0",
    (char*)"DoubleMatrix",
    3,
    _OB_TC__OBE_C_DoubleMatrix__OB_tc_member_names,
    _OB_TC__OBE_C_DoubleMatrix__OB_tc_member_types,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_DoubleMatrix(&_OB_TC__OBE_C_DoubleMatrix);

//
// IDL:IdentifierInformation:1.0
//

static _CORBA_TypeCode _OB_TC_0__OBE_C_IdentifierInformation =
{
    CORBA_tk_octet,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC_1__OBE_C_IdentifierInformation =
{
    CORBA_tk_sequence,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_0__OBE_C_IdentifierInformation,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC__OBE_C_IdentifierInformation =
{
    CORBA_tk_alias,
    (char*)"IDL:IdentifierInformation:1.0",
    (char*)"IdentifierInformation",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_1__OBE_C_IdentifierInformation,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_IdentifierInformation(&_OB_TC__OBE_C_IdentifierInformation);

//
// IDL:SceneFeature:1.0
//

extern _CORBA_TypeCode _OB_TC__OBE_C_SceneFeature;

static _CORBA_TypeCode _OB_TC_0__OBE_C_SceneFeature =
{
    CORBA_tk_boolean,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static _CORBA_TypeCode* _OB_TC__OBE_C_SceneFeature__OB_tc_member_types[] =
{
    &_OB_TC__OBE_C_DoubleMatrix,
    &_OB_TC__OBE_C_DoubleMatrix,
    &_OB_TC_0__OBE_C_DoubleMatrix,
    &_OB_TC_0__OBE_C_SceneFeature,
    &_OB_TC_0__OBE_C_SceneFeature,
    &_OB_TC__OBE_C_DoubleMatrix,
    &_OB_TC__OBE_C_DoubleMatrix,
    &_OB_TC__OBE_C_DoubleMatrix,
    &_OB_TC__OBE_C_IdentifierInformation
};

static char* _OB_TC__OBE_C_SceneFeature__OB_tc_member_names[] =
{
    (char*)"y",
    (char*)"Pyy",
    (char*)"label",
    (char*)"SuccessfulMeasurementFlag",
    (char*)"SelectedFlag",
    (char*)"h",
    (char*)"z",
    (char*)"S",
    (char*)"Identifier"
};

_CORBA_TypeCode _OB_TC__OBE_C_SceneFeature =
{
    CORBA_tk_struct,
    (char*)"IDL:SceneFeature:1.0",
    (char*)"SceneFeature",
    9,
    _OB_TC__OBE_C_SceneFeature__OB_tc_member_names,
    _OB_TC__OBE_C_SceneFeature__OB_tc_member_types,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_SceneFeature(&_OB_TC__OBE_C_SceneFeature);

//
// IDL:SceneFeatureSeq:1.0
//

static _CORBA_TypeCode _OB_TC_0__OBE_C_SceneFeatureSeq =
{
    CORBA_tk_sequence,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC__OBE_C_SceneFeature,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC__OBE_C_SceneFeatureSeq =
{
    CORBA_tk_alias,
    (char*)"IDL:SceneFeatureSeq:1.0",
    (char*)"SceneFeatureSeq",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_0__OBE_C_SceneFeatureSeq,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_SceneFeatureSeq(&_OB_TC__OBE_C_SceneFeatureSeq);

//
// IDL:SceneObject:1.0
//

extern _CORBA_TypeCode _OB_TC__OBE_C_SceneObject;

static _CORBA_TypeCode* _OB_TC__OBE_C_SceneObject__OB_tc_member_types[] =
{
    &_OB_TC__OBE_C_SceneFeatureSeq,
    &_OB_TC__OBE_C_DoubleMatrix,
    &_OB_TC__OBE_C_DoubleMatrix,
    &_OB_TC_0__OBE_C_DoubleMatrix,
    &_OB_TC_0__OBE_C_DoubleMatrix
};

static char* _OB_TC__OBE_C_SceneObject__OB_tc_member_names[] =
{
    (char*)"Features",
    (char*)"xv",
    (char*)"Pxx",
    (char*)"NoFeatures",
    (char*)"NoSelected"
};

_CORBA_TypeCode _OB_TC__OBE_C_SceneObject =
{
    CORBA_tk_struct,
    (char*)"IDL:SceneObject:1.0",
    (char*)"SceneObject",
    5,
    _OB_TC__OBE_C_SceneObject__OB_tc_member_names,
    _OB_TC__OBE_C_SceneObject__OB_tc_member_types,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_SceneObject(&_OB_TC__OBE_C_SceneObject);

CORBA::TypeCode_ptr _tc_DoubleMatrix = &_OBE_TC_DoubleMatrix;

CORBA::TypeCode_ptr _tc_IdentifierInformation = &_OBE_TC_IdentifierInformation;

CORBA::TypeCode_ptr _tc_SceneFeature = &_OBE_TC_SceneFeature;

CORBA::TypeCode_ptr _tc_SceneFeatureSeq = &_OBE_TC_SceneFeatureSeq;

CORBA::TypeCode_ptr _tc_SceneObject = &_OBE_TC_SceneObject;

//
// IDL:DoubleMatrix:1.0
//
#ifdef OB_PURIFY_CLEAN
DoubleMatrix::DoubleMatrix()
{
    memset(&nrows, 0, sizeof(nrows));
    memset(&ncols, 0, sizeof(ncols));
}
#endif

DoubleMatrix::DoubleMatrix(const DoubleMatrix& _ob_a)
    : nrows(_ob_a.nrows),
      ncols(_ob_a.ncols),
      data(_ob_a.data)
{
}

DoubleMatrix&
DoubleMatrix::operator=(const DoubleMatrix& _ob_a)
{
    if(this != &_ob_a)
    {
        nrows = _ob_a.nrows;
        ncols = _ob_a.ncols;
        data = _ob_a.data;
    }
    return *this;
}

void
DoubleMatrix::_OB_marshal(
    OBEC_OutputStreamImpl* _ob_out,
    CORBA_Environment* _ob_cev
) const
{
    OBEC_OutputStreamImpl_write_long(_ob_out, nrows, _ob_cev);
    OBEC_OutputStreamImpl_write_long(_ob_out, ncols, _ob_cev);
    CORBA::ULong _ob_len0 = data.length();
    OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len0, _ob_cev);
    OBEC_OutputStreamImpl_write_double_array(_ob_out, data.get_buffer(), _ob_len0, _ob_cev);
}

void
DoubleMatrix::_OB_unmarshal(
    DoubleMatrix& _ob_v,
    OBEC_InputStreamImpl* _ob_in,
    CORBA_Environment* _ob_cev
)
{
    _ob_v.nrows = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    _ob_v.ncols = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.data.length(_ob_len0);
    OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_v.data.get_buffer(), _ob_len0, _ob_cev);
}

void
DoubleMatrix::_OB_convert_to(
    void* _ob_data
) const
{
    _OBE_C_DoubleMatrix* _ob_p = (_OBE_C_DoubleMatrix*)_ob_data;
    _ob_p->nrows = nrows;
    _ob_p->ncols = ncols;
    _ob_p->data._length = data.length();
    _ob_p->data._maximum = data.length();
    _ob_p->data._release = OBEC_TRUE;
    _ob_p->data._buffer = (CORBA_double*)OBEC_allocate_buffer(NULL, sizeof(CORBA_double) * _ob_p->data._length, _ob_p->data._length, OBEC_FALSE);

    memcpy(_ob_p->data._buffer, data.get_buffer(), sizeof(CORBA_double) * _ob_p->data._length);
}

void
DoubleMatrix::_OB_convert_from(
    DoubleMatrix& _ob_v,
    void* _ob_data
)
{
    _OBE_C_DoubleMatrix* _ob_p = (_OBE_C_DoubleMatrix*)_ob_data;
    _ob_v.nrows = _ob_p->nrows;
    _ob_v.ncols = _ob_p->ncols;
    _ob_v.data.length(_ob_p->data._length);

    memcpy(_ob_v.data.get_buffer(), _ob_p->data._buffer, sizeof(CORBA_double) * _ob_p->data._length);
}

static CORBA::AnyContentDestroyerDelete<DoubleMatrix> OBAnyContentDestroyerInstance_DoubleMatrix;

void
operator<<=(CORBA::Any& any, DoubleMatrix* v)
{
    _OBE_C_DoubleMatrix* p = (_OBE_C_DoubleMatrix*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_DoubleMatrix->_OB_impl_nodup(), sizeof(_OBE_C_DoubleMatrix));
    (*v)._OB_convert_to(&(*p));
    any.replace(_tc_DoubleMatrix, p, false, v, &OBAnyContentDestroyerInstance_DoubleMatrix);
}

void
operator<<=(CORBA::Any& any, const DoubleMatrix& v)
{
    _OBE_C_DoubleMatrix* p = (_OBE_C_DoubleMatrix*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_DoubleMatrix->_OB_impl_nodup(), sizeof(_OBE_C_DoubleMatrix));
    v._OB_convert_to(&(*p));
    any.replace(_tc_DoubleMatrix, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const DoubleMatrix*& v)
{
    if (!any.check_type(_tc_DoubleMatrix))
        return 0;

    v = (const DoubleMatrix*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_DoubleMatrix* p = (_OBE_C_DoubleMatrix*)any.value();
        assert(p != NULL);
        DoubleMatrix* val = new DoubleMatrix;
        DoubleMatrix::_OB_convert_from((*val), &(*p));
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_DoubleMatrix);
        v = val;
    }

    return 1;
}

//
// IDL:IdentifierInformation:1.0
//
static CORBA::AnyContentDestroyerDelete<IdentifierInformation> OBAnyContentDestroyerInstance_IdentifierInformation;

void
operator<<=(CORBA::Any& any, IdentifierInformation* v)
{
    _OBE_C_CORBA_sequence_octet* p = (_OBE_C_CORBA_sequence_octet*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_IdentifierInformation->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence_octet));
    (*p)._length = (*v).length();
    (*p)._maximum = (*v).length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (CORBA_octet*)OBEC_allocate_buffer(NULL, sizeof(CORBA_octet) * (*p)._length, (*p)._length, OBEC_FALSE);

    memcpy((*p)._buffer, (*v).get_buffer(), sizeof(CORBA_octet) * (*p)._length);
    any.replace(_tc_IdentifierInformation, p, false, v, &OBAnyContentDestroyerInstance_IdentifierInformation);
}

void
operator<<=(CORBA::Any& any, const IdentifierInformation& v)
{
    _OBE_C_CORBA_sequence_octet* p = (_OBE_C_CORBA_sequence_octet*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_IdentifierInformation->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence_octet));
    (*p)._length = v.length();
    (*p)._maximum = v.length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (CORBA_octet*)OBEC_allocate_buffer(NULL, sizeof(CORBA_octet) * (*p)._length, (*p)._length, OBEC_FALSE);

    memcpy((*p)._buffer, v.get_buffer(), sizeof(CORBA_octet) * (*p)._length);
    any.replace(_tc_IdentifierInformation, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const IdentifierInformation*& v)
{
    if (!any.check_type(_tc_IdentifierInformation))
        return false;

    v = (const IdentifierInformation*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_CORBA_sequence_octet* p = (_OBE_C_CORBA_sequence_octet*)any.value();
        assert(p != NULL);
        IdentifierInformation* val = new IdentifierInformation;
        (*val).length((*p)._length);

        memcpy((*val).get_buffer(), (*p)._buffer, sizeof(CORBA_octet) * (*p)._length);
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_IdentifierInformation);
        v = val;
    }

    return true;
}

//
// IDL:SceneFeature:1.0
//
#ifdef OB_PURIFY_CLEAN
SceneFeature::SceneFeature()
{
    memset(&label, 0, sizeof(label));
    memset(&SuccessfulMeasurementFlag, 0, sizeof(SuccessfulMeasurementFlag));
    memset(&SelectedFlag, 0, sizeof(SelectedFlag));
}
#endif

SceneFeature::SceneFeature(const SceneFeature& _ob_a)
    : y(_ob_a.y),
      Pyy(_ob_a.Pyy),
      label(_ob_a.label),
      SuccessfulMeasurementFlag(_ob_a.SuccessfulMeasurementFlag),
      SelectedFlag(_ob_a.SelectedFlag),
      h(_ob_a.h),
      z(_ob_a.z),
      S(_ob_a.S),
      Identifier(_ob_a.Identifier)
{
}

SceneFeature&
SceneFeature::operator=(const SceneFeature& _ob_a)
{
    if(this != &_ob_a)
    {
        y = _ob_a.y;
        Pyy = _ob_a.Pyy;
        label = _ob_a.label;
        SuccessfulMeasurementFlag = _ob_a.SuccessfulMeasurementFlag;
        SelectedFlag = _ob_a.SelectedFlag;
        h = _ob_a.h;
        z = _ob_a.z;
        S = _ob_a.S;
        Identifier = _ob_a.Identifier;
    }
    return *this;
}

void
SceneFeature::_OB_marshal(
    OBEC_OutputStreamImpl* _ob_out,
    CORBA_Environment* _ob_cev
) const
{
    y._OB_marshal(_ob_out, _ob_cev);
    Pyy._OB_marshal(_ob_out, _ob_cev);
    OBEC_OutputStreamImpl_write_long(_ob_out, label, _ob_cev);
    OBEC_OutputStreamImpl_write_boolean(_ob_out, SuccessfulMeasurementFlag, _ob_cev);
    OBEC_OutputStreamImpl_write_boolean(_ob_out, SelectedFlag, _ob_cev);
    h._OB_marshal(_ob_out, _ob_cev);
    z._OB_marshal(_ob_out, _ob_cev);
    S._OB_marshal(_ob_out, _ob_cev);
    CORBA::ULong _ob_len0 = Identifier.length();
    OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len0, _ob_cev);
    OBEC_OutputStreamImpl_write_octet_array(_ob_out, Identifier.get_buffer(), _ob_len0, _ob_cev);
}

void
SceneFeature::_OB_unmarshal(
    SceneFeature& _ob_v,
    OBEC_InputStreamImpl* _ob_in,
    CORBA_Environment* _ob_cev
)
{
    ::DoubleMatrix::_OB_unmarshal(_ob_v.y, _ob_in, _ob_cev);
    ::DoubleMatrix::_OB_unmarshal(_ob_v.Pyy, _ob_in, _ob_cev);
    _ob_v.label = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    _ob_v.SuccessfulMeasurementFlag = OBEC_InputStreamImpl_read_boolean(_ob_in, _ob_cev);
    _ob_v.SelectedFlag = OBEC_InputStreamImpl_read_boolean(_ob_in, _ob_cev);
    ::DoubleMatrix::_OB_unmarshal(_ob_v.h, _ob_in, _ob_cev);
    ::DoubleMatrix::_OB_unmarshal(_ob_v.z, _ob_in, _ob_cev);
    ::DoubleMatrix::_OB_unmarshal(_ob_v.S, _ob_in, _ob_cev);
    CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.Identifier.length(_ob_len0);
    OBEC_InputStreamImpl_read_octet_array(_ob_in, _ob_v.Identifier.get_buffer(), _ob_len0, _ob_cev);
}

void
SceneFeature::_OB_convert_to(
    void* _ob_data
) const
{
    _OBE_C_SceneFeature* _ob_p = (_OBE_C_SceneFeature*)_ob_data;
    y._OB_convert_to(&_ob_p->y);
    Pyy._OB_convert_to(&_ob_p->Pyy);
    _ob_p->label = label;
    _ob_p->SuccessfulMeasurementFlag = SuccessfulMeasurementFlag;
    _ob_p->SelectedFlag = SelectedFlag;
    h._OB_convert_to(&_ob_p->h);
    z._OB_convert_to(&_ob_p->z);
    S._OB_convert_to(&_ob_p->S);
    _ob_p->Identifier._length = Identifier.length();
    _ob_p->Identifier._maximum = Identifier.length();
    _ob_p->Identifier._release = OBEC_TRUE;
    _ob_p->Identifier._buffer = (CORBA_octet*)OBEC_allocate_buffer(NULL, sizeof(CORBA_octet) * _ob_p->Identifier._length, _ob_p->Identifier._length, OBEC_FALSE);

    memcpy(_ob_p->Identifier._buffer, Identifier.get_buffer(), sizeof(CORBA_octet) * _ob_p->Identifier._length);
}

void
SceneFeature::_OB_convert_from(
    SceneFeature& _ob_v,
    void* _ob_data
)
{
    _OBE_C_SceneFeature* _ob_p = (_OBE_C_SceneFeature*)_ob_data;
    DoubleMatrix::_OB_convert_from(_ob_v.y, &_ob_p->y);
    DoubleMatrix::_OB_convert_from(_ob_v.Pyy, &_ob_p->Pyy);
    _ob_v.label = _ob_p->label;
    _ob_v.SuccessfulMeasurementFlag = _ob_p->SuccessfulMeasurementFlag;
    _ob_v.SelectedFlag = _ob_p->SelectedFlag;
    DoubleMatrix::_OB_convert_from(_ob_v.h, &_ob_p->h);
    DoubleMatrix::_OB_convert_from(_ob_v.z, &_ob_p->z);
    DoubleMatrix::_OB_convert_from(_ob_v.S, &_ob_p->S);
    _ob_v.Identifier.length(_ob_p->Identifier._length);

    memcpy(_ob_v.Identifier.get_buffer(), _ob_p->Identifier._buffer, sizeof(CORBA_octet) * _ob_p->Identifier._length);
}

static CORBA::AnyContentDestroyerDelete<SceneFeature> OBAnyContentDestroyerInstance_SceneFeature;

void
operator<<=(CORBA::Any& any, SceneFeature* v)
{
    _OBE_C_SceneFeature* p = (_OBE_C_SceneFeature*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_SceneFeature->_OB_impl_nodup(), sizeof(_OBE_C_SceneFeature));
    (*v)._OB_convert_to(&(*p));
    any.replace(_tc_SceneFeature, p, false, v, &OBAnyContentDestroyerInstance_SceneFeature);
}

void
operator<<=(CORBA::Any& any, const SceneFeature& v)
{
    _OBE_C_SceneFeature* p = (_OBE_C_SceneFeature*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_SceneFeature->_OB_impl_nodup(), sizeof(_OBE_C_SceneFeature));
    v._OB_convert_to(&(*p));
    any.replace(_tc_SceneFeature, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const SceneFeature*& v)
{
    if (!any.check_type(_tc_SceneFeature))
        return 0;

    v = (const SceneFeature*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_SceneFeature* p = (_OBE_C_SceneFeature*)any.value();
        assert(p != NULL);
        SceneFeature* val = new SceneFeature;
        SceneFeature::_OB_convert_from((*val), &(*p));
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_SceneFeature);
        v = val;
    }

    return 1;
}

//
// IDL:SceneFeatureSeq:1.0
//
static CORBA::AnyContentDestroyerDelete<SceneFeatureSeq> OBAnyContentDestroyerInstance_SceneFeatureSeq;

void
operator<<=(CORBA::Any& any, SceneFeatureSeq* v)
{
    _OBE_C_CORBA_sequence__OBE_C_SceneFeature* p = (_OBE_C_CORBA_sequence__OBE_C_SceneFeature*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_SceneFeatureSeq->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence__OBE_C_SceneFeature));
    (*p)._length = (*v).length();
    (*p)._maximum = (*v).length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (_OBE_C_SceneFeature*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_SceneFeature) * (*p)._length, (*p)._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
    {
        (*v)[_ob_i0]._OB_convert_to(&(*p)._buffer[_ob_i0]);
    }
    any.replace(_tc_SceneFeatureSeq, p, false, v, &OBAnyContentDestroyerInstance_SceneFeatureSeq);
}

void
operator<<=(CORBA::Any& any, const SceneFeatureSeq& v)
{
    _OBE_C_CORBA_sequence__OBE_C_SceneFeature* p = (_OBE_C_CORBA_sequence__OBE_C_SceneFeature*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_SceneFeatureSeq->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence__OBE_C_SceneFeature));
    (*p)._length = v.length();
    (*p)._maximum = v.length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (_OBE_C_SceneFeature*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_SceneFeature) * (*p)._length, (*p)._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
    {
        v[_ob_i0]._OB_convert_to(&(*p)._buffer[_ob_i0]);
    }
    any.replace(_tc_SceneFeatureSeq, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const SceneFeatureSeq*& v)
{
    if (!any.check_type(_tc_SceneFeatureSeq))
        return false;

    v = (const SceneFeatureSeq*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_CORBA_sequence__OBE_C_SceneFeature* p = (_OBE_C_CORBA_sequence__OBE_C_SceneFeature*)any.value();
        assert(p != NULL);
        SceneFeatureSeq* val = new SceneFeatureSeq;
        (*val).length((*p)._length);

        for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
        {
            SceneFeature::_OB_convert_from((*val)[_ob_i0], &(*p)._buffer[_ob_i0]);
        }
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_SceneFeatureSeq);
        v = val;
    }

    return true;
}

//
// IDL:SceneObject:1.0
//
#ifdef OB_PURIFY_CLEAN
SceneObject::SceneObject()
{
    memset(&NoFeatures, 0, sizeof(NoFeatures));
    memset(&NoSelected, 0, sizeof(NoSelected));
}
#endif

SceneObject::SceneObject(const SceneObject& _ob_a)
    : Features(_ob_a.Features),
      xv(_ob_a.xv),
      Pxx(_ob_a.Pxx),
      NoFeatures(_ob_a.NoFeatures),
      NoSelected(_ob_a.NoSelected)
{
}

SceneObject&
SceneObject::operator=(const SceneObject& _ob_a)
{
    if(this != &_ob_a)
    {
        Features = _ob_a.Features;
        xv = _ob_a.xv;
        Pxx = _ob_a.Pxx;
        NoFeatures = _ob_a.NoFeatures;
        NoSelected = _ob_a.NoSelected;
    }
    return *this;
}

void
SceneObject::_OB_marshal(
    OBEC_OutputStreamImpl* _ob_out,
    CORBA_Environment* _ob_cev
) const
{
    CORBA::ULong _ob_len0 = Features.length();
    OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len0, _ob_cev);
    ::SceneFeature const * _ob_buf0 = Features.get_buffer();
    for(CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
    {
        _ob_buf0[_ob_i0]._OB_marshal(_ob_out, _ob_cev);
    }
    xv._OB_marshal(_ob_out, _ob_cev);
    Pxx._OB_marshal(_ob_out, _ob_cev);
    OBEC_OutputStreamImpl_write_long(_ob_out, NoFeatures, _ob_cev);
    OBEC_OutputStreamImpl_write_long(_ob_out, NoSelected, _ob_cev);
}

void
SceneObject::_OB_unmarshal(
    SceneObject& _ob_v,
    OBEC_InputStreamImpl* _ob_in,
    CORBA_Environment* _ob_cev
)
{
    CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.Features.length(_ob_len0);
    ::SceneFeature * _ob_buf0 = _ob_v.Features.get_buffer();
    for(CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
    {
        ::SceneFeature::_OB_unmarshal(_ob_buf0[_ob_i0], _ob_in, _ob_cev);
    }
    ::DoubleMatrix::_OB_unmarshal(_ob_v.xv, _ob_in, _ob_cev);
    ::DoubleMatrix::_OB_unmarshal(_ob_v.Pxx, _ob_in, _ob_cev);
    _ob_v.NoFeatures = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    _ob_v.NoSelected = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
}

void
SceneObject::_OB_convert_to(
    void* _ob_data
) const
{
    _OBE_C_SceneObject* _ob_p = (_OBE_C_SceneObject*)_ob_data;
    _ob_p->Features._length = Features.length();
    _ob_p->Features._maximum = Features.length();
    _ob_p->Features._release = OBEC_TRUE;
    _ob_p->Features._buffer = (_OBE_C_SceneFeature*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_SceneFeature) * _ob_p->Features._length, _ob_p->Features._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i0 = 0; _ob_i0 < _ob_p->Features._length; _ob_i0++)
    {
        Features[_ob_i0]._OB_convert_to(&_ob_p->Features._buffer[_ob_i0]);
    }
    xv._OB_convert_to(&_ob_p->xv);
    Pxx._OB_convert_to(&_ob_p->Pxx);
    _ob_p->NoFeatures = NoFeatures;
    _ob_p->NoSelected = NoSelected;
}

void
SceneObject::_OB_convert_from(
    SceneObject& _ob_v,
    void* _ob_data
)
{
    _OBE_C_SceneObject* _ob_p = (_OBE_C_SceneObject*)_ob_data;
    _ob_v.Features.length(_ob_p->Features._length);

    for (CORBA::ULong _ob_i0 = 0; _ob_i0 < _ob_p->Features._length; _ob_i0++)
    {
        SceneFeature::_OB_convert_from(_ob_v.Features[_ob_i0], &_ob_p->Features._buffer[_ob_i0]);
    }
    DoubleMatrix::_OB_convert_from(_ob_v.xv, &_ob_p->xv);
    DoubleMatrix::_OB_convert_from(_ob_v.Pxx, &_ob_p->Pxx);
    _ob_v.NoFeatures = _ob_p->NoFeatures;
    _ob_v.NoSelected = _ob_p->NoSelected;
}

static CORBA::AnyContentDestroyerDelete<SceneObject> OBAnyContentDestroyerInstance_SceneObject;

void
operator<<=(CORBA::Any& any, SceneObject* v)
{
    _OBE_C_SceneObject* p = (_OBE_C_SceneObject*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_SceneObject->_OB_impl_nodup(), sizeof(_OBE_C_SceneObject));
    (*v)._OB_convert_to(&(*p));
    any.replace(_tc_SceneObject, p, false, v, &OBAnyContentDestroyerInstance_SceneObject);
}

void
operator<<=(CORBA::Any& any, const SceneObject& v)
{
    _OBE_C_SceneObject* p = (_OBE_C_SceneObject*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_SceneObject->_OB_impl_nodup(), sizeof(_OBE_C_SceneObject));
    v._OB_convert_to(&(*p));
    any.replace(_tc_SceneObject, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const SceneObject*& v)
{
    if (!any.check_type(_tc_SceneObject))
        return 0;

    v = (const SceneObject*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_SceneObject* p = (_OBE_C_SceneObject*)any.value();
        assert(p != NULL);
        SceneObject* val = new SceneObject;
        SceneObject::_OB_convert_from((*val), &(*p));
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_SceneObject);
        v = val;
    }

    return 1;
}
