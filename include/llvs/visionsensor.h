// **********************************************************************
//
// Generated by the Orbix/E IDL-to-C++ Translator
//
// Copyright (c) 2003
// IONA Technologies, Inc.
// Waltham, MA, USA
//
// All Rights Reserved
//
// **********************************************************************

// Version: 2.2.0

#ifndef ___visionsensor_h__
#define ___visionsensor_h__

#ifndef OPENHRP_API
#   ifdef OBE_DLL
#      define OPENHRP_API __declspec(dllimport)
#   else
#      define OPENHRP_API /**/
#   endif
#endif


#include <common.h>

#ifndef OBEC_INTEGER_VERSION
#   error No Orbix/E version defined! Is <OBE/CORBA.h> included?
#endif

#ifndef OBEC_NO_VERSION_CHECK
#   if (OBEC_INTEGER_VERSION != 2020000L)
#       error Orbix/E version mismatch!
#   endif
#endif

class Camera;
typedef Camera* Camera_ptr;
typedef Camera* CameraRef;
OPENHRP_API extern CORBA::TypeCode_ptr _tc_Camera;

class VisionSensor;
typedef VisionSensor* VisionSensor_ptr;
typedef VisionSensor* VisionSensorRef;
OPENHRP_API extern CORBA::TypeCode_ptr _tc_VisionSensor;

class VisionSensorFactory;
typedef VisionSensorFactory* VisionSensorFactory_ptr;
typedef VisionSensorFactory* VisionSensorFactoryRef;
OPENHRP_API extern CORBA::TypeCode_ptr _tc_VisionSensorFactory;

OPENHRP_API void OBDuplicate(Camera_ptr);
OPENHRP_API void OBRelease(Camera_ptr);

OPENHRP_API void OBMarshal(Camera_ptr, OBEC_OutputStreamImpl*, CORBA_Environment*);
OPENHRP_API void OBUnmarshal(Camera_ptr&, OBEC_InputStreamImpl*, CORBA_Environment*);

OPENHRP_API void OBDuplicate(VisionSensor_ptr);
OPENHRP_API void OBRelease(VisionSensor_ptr);

OPENHRP_API void OBMarshal(VisionSensor_ptr, OBEC_OutputStreamImpl*, CORBA_Environment*);
OPENHRP_API void OBUnmarshal(VisionSensor_ptr&, OBEC_InputStreamImpl*, CORBA_Environment*);

OPENHRP_API void OBDuplicate(VisionSensorFactory_ptr);
OPENHRP_API void OBRelease(VisionSensorFactory_ptr);

OPENHRP_API void OBMarshal(VisionSensorFactory_ptr, OBEC_OutputStreamImpl*, CORBA_Environment*);
OPENHRP_API void OBUnmarshal(VisionSensorFactory_ptr&, OBEC_InputStreamImpl*, CORBA_Environment*);

#ifdef OBEA_DLL
#   ifndef HAVE_NO_EXPLICIT_TEMPLATES
template class OPENHRP_API OB::ObjVar< Camera >;
#   endif
#endif
typedef OB::ObjVar< Camera > Camera_var;
#ifdef OBEA_DLL
#   ifndef HAVE_NO_EXPLICIT_TEMPLATES
template class OPENHRP_API OB::ObjOut< Camera >;
#   endif
#endif
typedef OB::ObjOut< Camera > Camera_out;

#ifdef OBEA_DLL
#   ifndef HAVE_NO_EXPLICIT_TEMPLATES
template class OPENHRP_API OB::ObjVar< VisionSensor >;
#   endif
#endif
typedef OB::ObjVar< VisionSensor > VisionSensor_var;
#ifdef OBEA_DLL
#   ifndef HAVE_NO_EXPLICIT_TEMPLATES
template class OPENHRP_API OB::ObjOut< VisionSensor >;
#   endif
#endif
typedef OB::ObjOut< VisionSensor > VisionSensor_out;

#ifdef OBEA_DLL
#   ifndef HAVE_NO_EXPLICIT_TEMPLATES
template class OPENHRP_API OB::ObjVar< VisionSensorFactory >;
#   endif
#endif
typedef OB::ObjVar< VisionSensorFactory > VisionSensorFactory_var;
#ifdef OBEA_DLL
#   ifndef HAVE_NO_EXPLICIT_TEMPLATES
template class OPENHRP_API OB::ObjOut< VisionSensorFactory >;
#   endif
#endif
typedef OB::ObjOut< VisionSensorFactory > VisionSensorFactory_out;

//
// IDL:FloatBuffer:1.0
//
class OBUnique_FloatBuffer { };

#ifdef OBEA_DLL
template class OPENHRP_API OB::FixSeq< CORBA::Float, OBUnique_FloatBuffer >;
#endif
typedef OB::FixSeq< CORBA::Float, OBUnique_FloatBuffer > FloatBuffer;
#ifdef OBEA_DLL
template class OPENHRP_API OB::SeqVar< OB::FixSeq< CORBA::Float, OBUnique_FloatBuffer > >;
#endif
typedef OB::SeqVar< OB::FixSeq< CORBA::Float, OBUnique_FloatBuffer > > FloatBuffer_var;
#ifdef OBEA_DLL
template class OPENHRP_API OB::SeqOut< OB::FixSeq< CORBA::Float, OBUnique_FloatBuffer > >;
#endif
typedef OB::SeqOut< OB::FixSeq< CORBA::Float, OBUnique_FloatBuffer > > FloatBuffer_out;
extern CORBA::TypeCode_ptr _tc_FloatBuffer;

//
// IDL:IntBuffer:1.0
//
class OBUnique_IntBuffer { };

#ifdef OBEA_DLL
template class OPENHRP_API OB::FixSeq< CORBA::Long, OBUnique_IntBuffer >;
#endif
typedef OB::FixSeq< CORBA::Long, OBUnique_IntBuffer > IntBuffer;
#ifdef OBEA_DLL
template class OPENHRP_API OB::SeqVar< OB::FixSeq< CORBA::Long, OBUnique_IntBuffer > >;
#endif
typedef OB::SeqVar< OB::FixSeq< CORBA::Long, OBUnique_IntBuffer > > IntBuffer_var;
#ifdef OBEA_DLL
template class OPENHRP_API OB::SeqOut< OB::FixSeq< CORBA::Long, OBUnique_IntBuffer > >;
#endif
typedef OB::SeqOut< OB::FixSeq< CORBA::Long, OBUnique_IntBuffer > > IntBuffer_out;
extern CORBA::TypeCode_ptr _tc_IntBuffer;

//
// IDL:DepthBuffer:1.0
//
typedef OB::FixSeq< CORBA::Float, OBUnique_FloatBuffer > DepthBuffer;
typedef OB::SeqVar< OB::FixSeq< CORBA::Float, OBUnique_FloatBuffer > > DepthBuffer_var;
typedef OB::SeqOut< OB::FixSeq< CORBA::Float, OBUnique_FloatBuffer > > DepthBuffer_out;
extern CORBA::TypeCode_ptr _tc_DepthBuffer;

//
// IDL:ColorBuffer:1.0
//
typedef OB::FixSeq< CORBA::Long, OBUnique_IntBuffer > ColorBuffer;
typedef OB::SeqVar< OB::FixSeq< CORBA::Long, OBUnique_IntBuffer > > ColorBuffer_var;
typedef OB::SeqOut< OB::FixSeq< CORBA::Long, OBUnique_IntBuffer > > ColorBuffer_out;
extern CORBA::TypeCode_ptr _tc_ColorBuffer;

//
// IDL:LinkAngles:1.0
//
typedef OB::FixSeq< CORBA::Float, OBUnique_FloatBuffer > LinkAngles;
typedef OB::SeqVar< OB::FixSeq< CORBA::Float, OBUnique_FloatBuffer > > LinkAngles_var;
typedef OB::SeqOut< OB::FixSeq< CORBA::Float, OBUnique_FloatBuffer > > LinkAngles_out;
extern CORBA::TypeCode_ptr _tc_LinkAngles;

//
// IDL:Camera:1.0
//
class OPENHRP_API Camera : public OBCORBA::Object
{
    Camera(const Camera&);
    void operator=(const Camera&);

protected:

    static const char* ids_[];

public:

    Camera() { }
    virtual ~Camera() { }

    typedef Camera_ptr _ptr_type;
    typedef Camera_var _var_type;

    static inline Camera_ptr
    _duplicate(Camera_ptr p)
    {
        if (p)
            p -> _OB_incRef();
        return p;
    }

    static inline Camera_ptr
    _nil()
    {
        return 0;
    }

    static Camera_ptr _narrow(CORBA::Object_ptr);

    static const char** _OB_staticIds();
    virtual const char** _OB_ids() const;

    //
    // IDL:Camera/CameraType:1.0
    //
    enum CameraType
    {
        NONE,
        COLOR,
        MONO,
        DEPTH,
        COLOR_DEPTH,
        MONO_DEPTH
    };

    typedef CameraType& CameraType_out;

    static CORBA::TypeCode_ptr _tc_CameraType;

    //
    // IDL:Camera/CameraParameter:1.0
    //
    struct OPENHRP_API CameraParameter;
    #ifdef OBEA_DLL
    template class OPENHRP_API OB::VarVar< CameraParameter >;
    #endif
    typedef OB::VarVar< CameraParameter > CameraParameter_var;
    #ifdef OBEA_DLL
    template class OPENHRP_API OB::VarOut< CameraParameter >;
    #endif
    typedef OB::VarOut< CameraParameter > CameraParameter_out;

    struct OPENHRP_API CameraParameter
    {
#ifdef OB_PURIFY_CLEAN
        CameraParameter();
#else
        CameraParameter() { }
#endif
        CameraParameter(const CameraParameter&);
        CameraParameter& operator=(const CameraParameter&);

        typedef CameraParameter_var _var_type;

        CameraType type;
        CORBA::Float frontClipDistance;
        CORBA::Float backClipDistance;
        CORBA::Float fieldOfView;
        CORBA::Long sensorId;
        OB::StrForStruct sensorName;
        OB::StrForStruct defName;
        CORBA::Long width;
        CORBA::Long height;

        void _OB_marshal(
            OBEC_OutputStreamImpl* _ob_out,
            CORBA_Environment* _ob_cev
        ) const;
        static void _OB_unmarshal(
            CameraParameter& _ob_v,
            OBEC_InputStreamImpl* _ob_in,
            CORBA_Environment* _ob_cev
        );

        void
        _OB_convert_to(
            void* _ob_data
        ) const;

        static void
        _OB_convert_from(
            CameraParameter& _ob_v,
            void* _ob_data
        );
    };

    static CORBA::TypeCode_ptr _tc_CameraParameter;

    //
    // IDL:Camera/destroy:1.0
    //
    void destroy();

    //
    // IDL:Camera/getCameraParameter:1.0
    //
    ::Camera::CameraParameter* getCameraParameter();

    //
    // IDL:Camera/getColorBuffer:1.0
    //
    ::ColorBuffer* getColorBuffer();

    //
    // IDL:Camera/getDepthBuffer:1.0
    //
    ::DepthBuffer* getDepthBuffer();

    //
    // IDL:Camera/getImageData:1.0
    //
    ::ImageData* getImageData();

protected:

    //
    // IDL:Camera/destroy:1.0
    //
    void
    _OB_op_destroy(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:Camera/getCameraParameter:1.0
    //
    ::Camera::CameraParameter*
    _OB_op_getCameraParameter(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:Camera/getColorBuffer:1.0
    //
    ::ColorBuffer*
    _OB_op_getColorBuffer(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:Camera/getDepthBuffer:1.0
    //
    ::DepthBuffer*
    _OB_op_getDepthBuffer(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:Camera/getImageData:1.0
    //
    ::ImageData*
    _OB_op_getImageData(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );
};

//
// IDL:CameraSeq:1.0
//
class OBUnique_CameraSeq { };

#ifdef OBEA_DLL
template class OPENHRP_API OB::ObjSeq< ::Camera, OBUnique_CameraSeq >;
#endif
typedef OB::ObjSeq< ::Camera, OBUnique_CameraSeq > CameraSeq;
#ifdef OBEA_DLL
template class OPENHRP_API OB::SeqVar< OB::ObjSeq< ::Camera, OBUnique_CameraSeq > >;
#endif
typedef OB::SeqVar< OB::ObjSeq< ::Camera, OBUnique_CameraSeq > > CameraSeq_var;
#ifdef OBEA_DLL
template class OPENHRP_API OB::SeqOut< OB::ObjSeq< ::Camera, OBUnique_CameraSeq > >;
#endif
typedef OB::SeqOut< OB::ObjSeq< ::Camera, OBUnique_CameraSeq > > CameraSeq_out;
extern CORBA::TypeCode_ptr _tc_CameraSeq;

//
// IDL:VisionSensor:1.0
//
class OPENHRP_API VisionSensor : public OBCORBA::Object
{
    VisionSensor(const VisionSensor&);
    void operator=(const VisionSensor&);

protected:

    static const char* ids_[];

public:

    VisionSensor() { }
    virtual ~VisionSensor() { }

    typedef VisionSensor_ptr _ptr_type;
    typedef VisionSensor_var _var_type;

    static inline VisionSensor_ptr
    _duplicate(VisionSensor_ptr p)
    {
        if (p)
            p -> _OB_incRef();
        return p;
    }

    static inline VisionSensor_ptr
    _nil()
    {
        return 0;
    }

    static VisionSensor_ptr _narrow(CORBA::Object_ptr);

    static const char** _OB_staticIds();
    virtual const char** _OB_ids() const;

    //
    // IDL:VisionSensor/VisionSensorException:1.0
    //
    struct OPENHRP_API VisionSensorException : public CORBA::UserException
    {
        VisionSensorException() { }
        VisionSensorException(const VisionSensorException&);
        VisionSensorException& operator=(const VisionSensorException&);

        virtual void _raise() const { throw *this; }
        virtual const char* _rep_id() const;

        virtual CORBA::Exception* _OB_clone() const;

        OB::StrForStruct description;

        VisionSensorException(const char*);

        virtual void _OB_marshal(
            OBEC_OutputStreamImpl* _ob_out,
            CORBA_Environment* _ob_cev
        ) const;
        static void _OB_unmarshal(
            VisionSensorException& _ob_v,
            OBEC_InputStreamImpl* _ob_in,
            CORBA_Environment* _ob_cev
        );

        void
        _OB_convert_to(
            void* _ob_data
        ) const;

        static void
        _OB_convert_from(
            VisionSensorException& _ob_v,
            void* _ob_data
        );
    };

    static CORBA::TypeCode_ptr _tc_VisionSensorException;

    //
    // IDL:VisionSensor/destroy:1.0
    //
    void destroy();

    //
    // IDL:VisionSensor/loadObject:1.0
    //
    void loadObject(const char* src,
                    const char* objectName);

    //
    // IDL:VisionSensor/showObject:1.0
    //
    void showObject(const char* objectName);

    //
    // IDL:VisionSensor/getCameraSeq:1.0
    //
    CORBA::Long getCameraSeq(::CameraSeq_out cameras);

    //
    // IDL:VisionSensor/getCameraSeqOf:1.0
    //
    CORBA::Long getCameraSeqOf(const char* objectName,
                               ::CameraSeq_out cameras);

    //
    // IDL:VisionSensor/addCamera:1.0
    //
    ::Camera_ptr addCamera(const char* objectName,
                           const char* jointName,
                           const ::Transform& transformation,
                           const ::Camera::CameraParameter& cameraParam);

    //
    // IDL:VisionSensor/updateScene:1.0
    //
    void updateScene(const ::WorldState& state);

protected:

    //
    // IDL:VisionSensor/destroy:1.0
    //
    void
    _OB_op_destroy(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:VisionSensor/loadObject:1.0
    //
    void
    _OB_op_loadObject(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        const char* src,
        const char* objectName,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:VisionSensor/showObject:1.0
    //
    void
    _OB_op_showObject(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        const char* objectName,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:VisionSensor/getCameraSeq:1.0
    //
    CORBA::Long
    _OB_op_getCameraSeq(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CameraSeq_out cameras,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:VisionSensor/getCameraSeqOf:1.0
    //
    CORBA::Long
    _OB_op_getCameraSeqOf(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        const char* objectName,
        CameraSeq_out cameras,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:VisionSensor/addCamera:1.0
    //
    ::Camera_ptr
    _OB_op_addCamera(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        const char* objectName,
        const char* jointName,
        const Transform& transformation,
        const Camera::CameraParameter& cameraParam,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:VisionSensor/updateScene:1.0
    //
    void
    _OB_op_updateScene(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        const WorldState& state,
        CORBA_Environment* _ob_cev
    );
};

//
// IDL:VisionSensorFactory:1.0
//
class OPENHRP_API VisionSensorFactory : public ::OpenHRPObject
{
    VisionSensorFactory(const VisionSensorFactory&);
    void operator=(const VisionSensorFactory&);

protected:

    static const char* ids_[];

public:

    VisionSensorFactory() { }
    virtual ~VisionSensorFactory() { }

    typedef VisionSensorFactory_ptr _ptr_type;
    typedef VisionSensorFactory_var _var_type;

    static inline VisionSensorFactory_ptr
    _duplicate(VisionSensorFactory_ptr p)
    {
        if (p)
            p -> _OB_incRef();
        return p;
    }

    static inline VisionSensorFactory_ptr
    _nil()
    {
        return 0;
    }

    static VisionSensorFactory_ptr _narrow(CORBA::Object_ptr);

    static const char** _OB_staticIds();
    virtual const char** _OB_ids() const;

    //
    // IDL:VisionSensorFactory/createVisionSensor:1.0
    //
    ::VisionSensor_ptr createVisionSensor();

protected:

    //
    // IDL:VisionSensorFactory/createVisionSensor:1.0
    //
    ::VisionSensor_ptr
    _OB_op_createVisionSensor(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );
};

//
// IDL:FloatBuffer:1.0
//
void operator<<=(CORBA::Any&, FloatBuffer*);
void operator<<=(CORBA::Any&, const FloatBuffer&);
CORBA::Boolean operator>>=(const CORBA::Any&, const FloatBuffer*&);

inline void
operator<<=(CORBA::Any_var& any, FloatBuffer* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const FloatBuffer& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const FloatBuffer*& val)
{
    return any.in() >>= val;
}

//
// IDL:IntBuffer:1.0
//
void operator<<=(CORBA::Any&, IntBuffer*);
void operator<<=(CORBA::Any&, const IntBuffer&);
CORBA::Boolean operator>>=(const CORBA::Any&, const IntBuffer*&);

inline void
operator<<=(CORBA::Any_var& any, IntBuffer* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const IntBuffer& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const IntBuffer*& val)
{
    return any.in() >>= val;
}

//
// IDL:Camera:1.0
//
namespace CORBA
{

inline void
release(::Camera_ptr p)
{
    if (p)
        p -> _OB_decRef();
}

inline Boolean
is_nil(::Camera_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(CORBA::Any&, Camera_ptr*);
void operator<<=(CORBA::Any&, Camera_ptr);
CORBA::Boolean operator>>=(const CORBA::Any&, Camera_ptr&);

inline void
operator<<=(CORBA::Any_var& any, Camera_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, Camera_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, Camera_ptr& val)
{
    return any.in() >>= val;
}

//
// IDL:Camera/CameraType:1.0
//
void operator<<=(CORBA::Any&, Camera::CameraType);
CORBA::Boolean operator>>=(const CORBA::Any&, Camera::CameraType&);

inline void
operator<<=(CORBA::Any_var& any, Camera::CameraType val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, Camera::CameraType& val)
{
    return any.in() >>= val;
}

//
// IDL:Camera/CameraParameter:1.0
//
void operator<<=(CORBA::Any&, Camera::CameraParameter*);
void operator<<=(CORBA::Any&, const Camera::CameraParameter&);
CORBA::Boolean operator>>=(const CORBA::Any&, const Camera::CameraParameter*&);

inline void
operator<<=(CORBA::Any_var& any, Camera::CameraParameter* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const Camera::CameraParameter& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const Camera::CameraParameter*& val)
{
    return any.in() >>= val;
}

//
// IDL:CameraSeq:1.0
//
void operator<<=(CORBA::Any&, CameraSeq*);
void operator<<=(CORBA::Any&, const CameraSeq&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CameraSeq*&);

inline void
operator<<=(CORBA::Any_var& any, CameraSeq* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CameraSeq& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CameraSeq*& val)
{
    return any.in() >>= val;
}

//
// IDL:VisionSensor:1.0
//
namespace CORBA
{

inline void
release(::VisionSensor_ptr p)
{
    if (p)
        p -> _OB_decRef();
}

inline Boolean
is_nil(::VisionSensor_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(CORBA::Any&, VisionSensor_ptr*);
void operator<<=(CORBA::Any&, VisionSensor_ptr);
CORBA::Boolean operator>>=(const CORBA::Any&, VisionSensor_ptr&);

inline void
operator<<=(CORBA::Any_var& any, VisionSensor_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, VisionSensor_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, VisionSensor_ptr& val)
{
    return any.in() >>= val;
}

//
// IDL:VisionSensor/VisionSensorException:1.0
//
void operator<<=(CORBA::Any&, VisionSensor::VisionSensorException*);
void operator<<=(CORBA::Any&, const VisionSensor::VisionSensorException&);
CORBA::Boolean operator>>=(const CORBA::Any&, const VisionSensor::VisionSensorException*&);

inline void
operator<<=(CORBA::Any_var& any, VisionSensor::VisionSensorException* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const VisionSensor::VisionSensorException& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const VisionSensor::VisionSensorException*& val)
{
    return any.in() >>= val;
}

//
// IDL:VisionSensorFactory:1.0
//
namespace CORBA
{

inline void
release(::VisionSensorFactory_ptr p)
{
    if (p)
        p -> _OB_decRef();
}

inline Boolean
is_nil(::VisionSensorFactory_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(CORBA::Any&, VisionSensorFactory_ptr*);
void operator<<=(CORBA::Any&, VisionSensorFactory_ptr);
CORBA::Boolean operator>>=(const CORBA::Any&, VisionSensorFactory_ptr&);

inline void
operator<<=(CORBA::Any_var& any, VisionSensorFactory_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, VisionSensorFactory_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, VisionSensorFactory_ptr& val)
{
    return any.in() >>= val;
}

#endif
