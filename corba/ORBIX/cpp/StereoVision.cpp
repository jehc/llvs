// **********************************************************************
//
// Generated by the Orbix/E IDL-to-C++ Translator
//
// Copyright (c) 2003
// IONA Technologies, Inc.
// Waltham, MA, USA
//
// All Rights Reserved
//
// **********************************************************************

// Version: 2.2.0

#include <OBE/CORBAClient.h>
#include <StereoVision.h>

#ifndef OBEC_INTEGER_VERSION
#   error No Orbix/E version defined! Is <OBE/CORBA.h> included?
#endif

#ifndef OBEC_NO_VERSION_CHECK
#   if (OBEC_INTEGER_VERSION != 2020000L)
#       error Orbix/E version mismatch!
#   endif
#endif

extern "C"
{

typedef CORBA_Object _OBE_C_StereoVision;

#ifndef __OBE_C_CORBA_sequence_float_defined
#define __OBE_C_CORBA_sequence_float_defined
typedef struct
{
    CORBA_unsigned_long _maximum;
    CORBA_unsigned_long _length;
    CORBA_float* _buffer;
    CORBA_boolean _release;
} _OBE_C_CORBA_sequence_float;
#endif

typedef _OBE_C_CORBA_sequence_float _OBE_C_FloatBuffer;

typedef _OBE_C_FloatBuffer _OBE_C_RangeMap;
}

//
// IDL:RangeMap:1.0
//

static _CORBA_TypeCode _OB_TC_1__OBE_C_RangeMap =
{
    CORBA_tk_float,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC_2__OBE_C_RangeMap =
{
    CORBA_tk_sequence,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_1__OBE_C_RangeMap,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC_0__OBE_C_RangeMap =
{
    CORBA_tk_alias,
    (char*)"IDL:FloatBuffer:1.0",
    (char*)"FloatBuffer",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_2__OBE_C_RangeMap,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC__OBE_C_RangeMap =
{
    CORBA_tk_alias,
    (char*)"IDL:RangeMap:1.0",
    (char*)"RangeMap",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_0__OBE_C_RangeMap,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_RangeMap(&_OB_TC__OBE_C_RangeMap);

//
// IDL:StereoVision:1.0
//
static _CORBA_TypeCode _OB_TC__OBE_C_StereoVision =
{
    CORBA_tk_objref,
    (char*)"IDL:StereoVision:1.0",
    (char*)"StereoVision",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_StereoVision(&_OB_TC__OBE_C_StereoVision);

CORBA::TypeCode_ptr _tc_RangeMap = &_OBE_TC_RangeMap;

CORBA::TypeCode_ptr _tc_StereoVision = &_OBE_TC_StereoVision;

//
// IDL:StereoVision:1.0
//
const char* StereoVision::ids_[] =
{
    "IDL:StereoVision:1.0",
    0
};

void
OBDuplicate(StereoVision_ptr p)
{
    if(p)
        p -> _OB_incRef();
}

void
OBRelease(StereoVision_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

StereoVision_ptr
StereoVision::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        StereoVision_ptr v = dynamic_cast<StereoVision_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            ::StereoVision* val = new ::StereoVision;
            val -> _OB_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

const char**
StereoVision::_OB_staticIds()
{
    return ids_;
}

const char**
StereoVision::_OB_ids() const
{
    return ::StereoVision::ids_;
}

void
OBMarshal(
    StereoVision_ptr _ob_v,
    OBEC_OutputStreamImpl* _ob_out,
    CORBA_Environment* _ob_cev
)
{
    CORBA_Object _ob_cobj = NULL;
    if (_ob_v)
    {
        _ob_cobj = _ob_v->_OB_impl_nodup();
        assert(_ob_cobj != NULL);
    }
    OBEC_OutputStreamImpl_write_Object(_ob_out, _ob_cobj, _ob_cev);
}

void
OBUnmarshal(
    StereoVision_ptr& _ob_v,
    OBEC_InputStreamImpl* _ob_in,
    CORBA_Environment* _ob_cev
)
{
    StereoVision_var old = _ob_v;
    CORBA_Object _ob_cobj = OBEC_InputStreamImpl_read_Object(_ob_in, _ob_cev);

    if (_ob_cobj != NULL && _ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_v = new StereoVision;
        _ob_v->_OB_setup(_ob_cobj);
        CORBA_Object_release(_ob_cobj);
    }
    else
        _ob_v = StereoVision::_nil();
}

//
// IDL:StereoVision/rbt2scmCalibStart:1.0
//
CORBA::Boolean
StereoVision::_OB_op_rbt2scmCalibStart(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    CORBA::Boolean _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    _ob_r = 0;
    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile, _ob_stub_impl->m_policies, "rbt2scmCalibStart", 17, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }
            else
            {
                _ob_r = OBEC_InputStreamImpl_read_boolean(_ob_in, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }

                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r;
}

//
// IDL:StereoVision/rbt2scmCalibEnd:1.0
//
CORBA::Boolean
StereoVision::_OB_op_rbt2scmCalibEnd(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    CORBA::Boolean _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    _ob_r = 0;
    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile, _ob_stub_impl->m_policies, "rbt2scmCalibEnd", 15, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }
            else
            {
                _ob_r = OBEC_InputStreamImpl_read_boolean(_ob_in, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }

                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r;
}

//
// IDL:StereoVision/detectCrossMark:1.0
//
CORBA::Boolean
StereoVision::_OB_op_detectCrossMark(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    const ::TransformQuaternion& robotHeadPos,
    const ::TransformQuaternion& robotHandPos,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    CORBA::Boolean _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    _ob_r = 0;
    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_OutputStreamImpl* _ob_out;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile, _ob_stub_impl->m_policies, "detectCrossMark", 15, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            _ob_out = OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            robotHeadPos._OB_marshal(_ob_out, _ob_cev);
            robotHandPos._OB_marshal(_ob_out, _ob_cev);
            if (_ob_cev->_major == CORBA_SYSTEM_EXCEPTION)
            {
                OBEC_DowncallImpl_marshalEx(&_ob_down, _ob_cev);
                break;
            }

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }
            else
            {
                _ob_r = OBEC_InputStreamImpl_read_boolean(_ob_in, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }

                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r;
}

//
// IDL:StereoVision/getObjectPosition:1.0
//
CORBA::Boolean
StereoVision::_OB_op_getObjectPosition(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    const char* name,
    const ::TransformQuaternion& robotHeadPos,
    ::TransformQuaternion_out ObjectPosition,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    CORBA::Boolean _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    _ob_r = 0;
    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_OutputStreamImpl* _ob_out;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile, _ob_stub_impl->m_policies, "getObjectPosition", 17, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            _ob_out = OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            OBEC_OutputStreamImpl_write_string(_ob_out, name, _ob_cev);
            robotHeadPos._OB_marshal(_ob_out, _ob_cev);
            if (_ob_cev->_major == CORBA_SYSTEM_EXCEPTION)
            {
                OBEC_DowncallImpl_marshalEx(&_ob_down, _ob_cev);
                break;
            }

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }
            else
            {
                _ob_r = OBEC_InputStreamImpl_read_boolean(_ob_in, _ob_cev);
                ::TransformQuaternion::_OB_unmarshal(ObjectPosition, _ob_in, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }

                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r;
}

//
// IDL:StereoVision/StartProcess:1.0
//
CORBA::Boolean
StereoVision::_OB_op_StartProcess(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    const char* ProcessName,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    CORBA::Boolean _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    _ob_r = 0;
    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_OutputStreamImpl* _ob_out;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile, _ob_stub_impl->m_policies, "StartProcess", 12, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            _ob_out = OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            OBEC_OutputStreamImpl_write_string(_ob_out, ProcessName, _ob_cev);
            if (_ob_cev->_major == CORBA_SYSTEM_EXCEPTION)
            {
                OBEC_DowncallImpl_marshalEx(&_ob_down, _ob_cev);
                break;
            }

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }
            else
            {
                _ob_r = OBEC_InputStreamImpl_read_boolean(_ob_in, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }

                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r;
}

//
// IDL:StereoVision/StopProcess:1.0
//
CORBA::Boolean
StereoVision::_OB_op_StopProcess(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    const char* ProcessName,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    CORBA::Boolean _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    _ob_r = 0;
    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_OutputStreamImpl* _ob_out;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile, _ob_stub_impl->m_policies, "StopProcess", 11, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            _ob_out = OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            OBEC_OutputStreamImpl_write_string(_ob_out, ProcessName, _ob_cev);
            if (_ob_cev->_major == CORBA_SYSTEM_EXCEPTION)
            {
                OBEC_DowncallImpl_marshalEx(&_ob_down, _ob_cev);
                break;
            }

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }
            else
            {
                _ob_r = OBEC_InputStreamImpl_read_boolean(_ob_in, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }

                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r;
}

//
// IDL:StereoVision/getImage:1.0
//
CORBA::Long
StereoVision::_OB_op_getImage(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA::Long CameraID,
    ::ImageData_out anImage,
    char*& Format,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    CORBA::Long _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    _ob_r = 0;
    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_OutputStreamImpl* _ob_out;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile, _ob_stub_impl->m_policies, "getImage", 8, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            _ob_out = OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            OBEC_OutputStreamImpl_write_long(_ob_out, CameraID, _ob_cev);
            OBEC_OutputStreamImpl_write_string(_ob_out, Format, _ob_cev);
            if (_ob_cev->_major == CORBA_SYSTEM_EXCEPTION)
            {
                OBEC_DowncallImpl_marshalEx(&_ob_down, _ob_cev);
                break;
            }

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }
            else
            {
                _ob_r = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
                anImage = new ::ImageData;
                ::ImageData::_OB_unmarshal(*anImage.ptr(), _ob_in, _ob_cev);
                CORBA::string_free(Format);
                Format = 0;
                Format = OBEC_InputStreamImpl_read_string(_ob_in, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }

                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r;
}

//
// IDL:StereoVision/getRangeMap:1.0
//
CORBA::Long
StereoVision::_OB_op_getRangeMap(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    ::RangeMap_out aRangeMap,
    char*& Format,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    CORBA::Long _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    _ob_r = 0;
    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_OutputStreamImpl* _ob_out;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile, _ob_stub_impl->m_policies, "getRangeMap", 11, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            _ob_out = OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            OBEC_OutputStreamImpl_write_string(_ob_out, Format, _ob_cev);
            if (_ob_cev->_major == CORBA_SYSTEM_EXCEPTION)
            {
                OBEC_DowncallImpl_marshalEx(&_ob_down, _ob_cev);
                break;
            }

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }
            else
            {
                _ob_r = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
                aRangeMap = new ::RangeMap;
                CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
                aRangeMap -> length(_ob_len0);
                OBEC_InputStreamImpl_read_float_array(_ob_in, aRangeMap -> get_buffer(), _ob_len0, _ob_cev);
                CORBA::string_free(Format);
                Format = 0;
                Format = OBEC_InputStreamImpl_read_string(_ob_in, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }

                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r;
}

void
operator<<=(CORBA::Any& any, StereoVision_ptr* v)
{
    CORBA_Object cobj = CORBA_OBJECT_NIL;
    if (!CORBA::is_nil(*v))
    {
        cobj = (*v)->_OB_impl_nodup();
    }
    any.replace(_tc_StereoVision, &cobj, true, (CORBA::Object_ptr)*v, &CORBA::Any::sm_any_content_destroyer_object);
}

void
operator<<=(CORBA::Any& any, StereoVision_ptr v)
{
    StereoVision_ptr val = StereoVision::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, StereoVision_ptr& v)
{
    if (any.check_type(_tc_StereoVision))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.cpp_value();
        if (!CORBA::is_nil(val))
            v = dynamic_cast<StereoVision_ptr>(val);
        else
        {
            CORBA_Object cobj = *(CORBA_Object*)any.value();
            if (cobj != CORBA_OBJECT_NIL)
            {
                StereoVision* obj = new StereoVision;
                obj->_OB_setup(cobj);
                v = obj;
                ((CORBA::Any&)any).cpp_value((CORBA::Object_ptr)obj, &CORBA::Any::sm_any_content_destroyer_object);
            }
            else
                v = StereoVision::_nil();
        }

        return true;
    }
    else
        return false;
}

//
// IDL:StereoVision/rbt2scmCalibStart:1.0
//
CORBA::Boolean
StereoVision::rbt2scmCalibStart(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA::Boolean _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    _ob_r = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_op_rbt2scmCalibStart(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r;
}

//
// IDL:StereoVision/rbt2scmCalibEnd:1.0
//
CORBA::Boolean
StereoVision::rbt2scmCalibEnd(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA::Boolean _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    _ob_r = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_op_rbt2scmCalibEnd(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r;
}

//
// IDL:StereoVision/detectCrossMark:1.0
//
CORBA::Boolean
StereoVision::detectCrossMark(
    const ::TransformQuaternion& robotHeadPos,
    const ::TransformQuaternion& robotHandPos
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA::Boolean _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    _ob_r = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_op_detectCrossMark(_ob_stub_impl, robotHeadPos, robotHandPos, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r;
}

//
// IDL:StereoVision/getObjectPosition:1.0
//
CORBA::Boolean
StereoVision::getObjectPosition(
    const char* name,
    const ::TransformQuaternion& robotHeadPos,
    ::TransformQuaternion_out ObjectPosition
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA::Boolean _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    _ob_r = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_op_getObjectPosition(_ob_stub_impl, name, robotHeadPos, ObjectPosition, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r;
}

//
// IDL:StereoVision/StartProcess:1.0
//
CORBA::Boolean
StereoVision::StartProcess(
    const char* ProcessName
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA::Boolean _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    _ob_r = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_op_StartProcess(_ob_stub_impl, ProcessName, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r;
}

//
// IDL:StereoVision/StopProcess:1.0
//
CORBA::Boolean
StereoVision::StopProcess(
    const char* ProcessName
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA::Boolean _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    _ob_r = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_op_StopProcess(_ob_stub_impl, ProcessName, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r;
}

//
// IDL:StereoVision/getImage:1.0
//
CORBA::Long
StereoVision::getImage(
    CORBA::Long CameraID,
    ::ImageData_out anImage,
    char*& Format
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA::Long _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    _ob_r = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_op_getImage(_ob_stub_impl, CameraID, anImage, Format, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r;
}

//
// IDL:StereoVision/getRangeMap:1.0
//
CORBA::Long
StereoVision::getRangeMap(
    ::RangeMap_out aRangeMap,
    char*& Format
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA::Long _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    _ob_r = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_op_getRangeMap(_ob_stub_impl, aRangeMap, Format, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r;
}
