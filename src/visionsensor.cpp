// **********************************************************************
//
// Generated by the Orbix/E IDL-to-C++ Translator
//
// Copyright (c) 2003
// IONA Technologies, Inc.
// Waltham, MA, USA
//
// All Rights Reserved
//
// **********************************************************************

// Version: 2.2.0

#include <OBE/CORBAClient.h>
#include <visionsensor.h>

#ifndef OBEC_INTEGER_VERSION
#   error No Orbix/E version defined! Is <OBE/CORBA.h> included?
#endif

#ifndef OBEC_NO_VERSION_CHECK
#   if (OBEC_INTEGER_VERSION != 2020000L)
#       error Orbix/E version mismatch!
#   endif
#endif

extern "C"
{

typedef CORBA_Object _OBE_C_Camera;

typedef CORBA_Object _OBE_C_VisionSensor;

typedef CORBA_Object _OBE_C_VisionSensorFactory;

#ifndef __OBE_C_CORBA_sequence_float_defined
#define __OBE_C_CORBA_sequence_float_defined
typedef struct
{
    CORBA_unsigned_long _maximum;
    CORBA_unsigned_long _length;
    CORBA_float* _buffer;
    CORBA_boolean _release;
} _OBE_C_CORBA_sequence_float;
#endif

typedef _OBE_C_CORBA_sequence_float _OBE_C_FloatBuffer;

#ifndef __OBE_C_CORBA_sequence_long_defined
#define __OBE_C_CORBA_sequence_long_defined
typedef struct
{
    CORBA_unsigned_long _maximum;
    CORBA_unsigned_long _length;
    CORBA_long* _buffer;
    CORBA_boolean _release;
} _OBE_C_CORBA_sequence_long;
#endif

typedef _OBE_C_CORBA_sequence_long _OBE_C_IntBuffer;

typedef _OBE_C_FloatBuffer _OBE_C_DepthBuffer;

typedef _OBE_C_IntBuffer _OBE_C_ColorBuffer;

typedef _OBE_C_FloatBuffer _OBE_C_LinkAngles;

typedef CORBA_unsigned_long _OBE_C_Camera_CameraType;

#define _OBE_C_Camera_NONE 0
#define _OBE_C_Camera_COLOR 1
#define _OBE_C_Camera_MONO 2
#define _OBE_C_Camera_DEPTH 3
#define _OBE_C_Camera_COLOR_DEPTH 4
#define _OBE_C_Camera_MONO_DEPTH 5

typedef struct _OBE_C_Camera_CameraParameter _OBE_C_Camera_CameraParameter;

struct _OBE_C_Camera_CameraParameter
{
    _OBE_C_Camera_CameraType type;
    CORBA_float frontClipDistance;
    CORBA_float backClipDistance;
    CORBA_float fieldOfView;
    CORBA_long sensorId;
    CORBA_char* sensorName;
    CORBA_char* defName;
    CORBA_long width;
    CORBA_long height;
};

#ifndef __OBE_C_CORBA_sequence__OBE_C_Camera_defined
#define __OBE_C_CORBA_sequence__OBE_C_Camera_defined
typedef struct
{
    CORBA_unsigned_long _maximum;
    CORBA_unsigned_long _length;
    _OBE_C_Camera* _buffer;
    CORBA_boolean _release;
} _OBE_C_CORBA_sequence__OBE_C_Camera;
#endif

typedef _OBE_C_CORBA_sequence__OBE_C_Camera _OBE_C_CameraSeq;

typedef struct _OBE_C_VisionSensor_VisionSensorException _OBE_C_VisionSensor_VisionSensorException;

struct _OBE_C_VisionSensor_VisionSensorException
{
    CORBA_char* description;
};
}

//
// IDL:FloatBuffer:1.0
//

static _CORBA_TypeCode _OB_TC_0__OBE_C_FloatBuffer =
{
    CORBA_tk_float,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC_1__OBE_C_FloatBuffer =
{
    CORBA_tk_sequence,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_0__OBE_C_FloatBuffer,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC__OBE_C_FloatBuffer =
{
    CORBA_tk_alias,
    (char*)"IDL:FloatBuffer:1.0",
    (char*)"FloatBuffer",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_1__OBE_C_FloatBuffer,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_FloatBuffer(&_OB_TC__OBE_C_FloatBuffer);

//
// IDL:IntBuffer:1.0
//

static _CORBA_TypeCode _OB_TC_0__OBE_C_IntBuffer =
{
    CORBA_tk_long,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC_1__OBE_C_IntBuffer =
{
    CORBA_tk_sequence,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_0__OBE_C_IntBuffer,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC__OBE_C_IntBuffer =
{
    CORBA_tk_alias,
    (char*)"IDL:IntBuffer:1.0",
    (char*)"IntBuffer",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_1__OBE_C_IntBuffer,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_IntBuffer(&_OB_TC__OBE_C_IntBuffer);

//
// IDL:DepthBuffer:1.0
//

static _CORBA_TypeCode _OB_TC__OBE_C_DepthBuffer =
{
    CORBA_tk_alias,
    (char*)"IDL:DepthBuffer:1.0",
    (char*)"DepthBuffer",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC__OBE_C_FloatBuffer,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_DepthBuffer(&_OB_TC__OBE_C_DepthBuffer);

//
// IDL:ColorBuffer:1.0
//

static _CORBA_TypeCode _OB_TC__OBE_C_ColorBuffer =
{
    CORBA_tk_alias,
    (char*)"IDL:ColorBuffer:1.0",
    (char*)"ColorBuffer",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC__OBE_C_IntBuffer,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_ColorBuffer(&_OB_TC__OBE_C_ColorBuffer);

//
// IDL:LinkAngles:1.0
//

static _CORBA_TypeCode _OB_TC__OBE_C_LinkAngles =
{
    CORBA_tk_alias,
    (char*)"IDL:LinkAngles:1.0",
    (char*)"LinkAngles",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC__OBE_C_FloatBuffer,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_LinkAngles(&_OB_TC__OBE_C_LinkAngles);

//
// IDL:Camera:1.0
//
static _CORBA_TypeCode _OB_TC__OBE_C_Camera =
{
    CORBA_tk_objref,
    (char*)"IDL:Camera:1.0",
    (char*)"Camera",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_Camera(&_OB_TC__OBE_C_Camera);

//
// IDL:Camera/CameraType:1.0
//

static char* _OB_TC__OBE_C_Camera_CameraType__OB_tc_member_names[] =
{
    (char*)"NONE",
    (char*)"COLOR",
    (char*)"MONO",
    (char*)"DEPTH",
    (char*)"COLOR_DEPTH",
    (char*)"MONO_DEPTH"
};

static _CORBA_TypeCode _OB_TC__OBE_C_Camera_CameraType =
{
    CORBA_tk_enum,
    (char*)"IDL:Camera/CameraType:1.0",
    (char*)"CameraType",
    6,
    _OB_TC__OBE_C_Camera_CameraType__OB_tc_member_names,
    NULL,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_Camera_CameraType(&_OB_TC__OBE_C_Camera_CameraType);

//
// IDL:Camera/CameraParameter:1.0
//

extern _CORBA_TypeCode _OB_TC__OBE_C_Camera_CameraParameter;

static _CORBA_TypeCode _OB_TC_0__OBE_C_Camera_CameraParameter =
{
    CORBA_tk_string,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static _CORBA_TypeCode* _OB_TC__OBE_C_Camera_CameraParameter__OB_tc_member_types[] =
{
    &_OB_TC__OBE_C_Camera_CameraType,
    &_OB_TC_0__OBE_C_FloatBuffer,
    &_OB_TC_0__OBE_C_FloatBuffer,
    &_OB_TC_0__OBE_C_FloatBuffer,
    &_OB_TC_0__OBE_C_IntBuffer,
    &_OB_TC_0__OBE_C_Camera_CameraParameter,
    &_OB_TC_0__OBE_C_Camera_CameraParameter,
    &_OB_TC_0__OBE_C_IntBuffer,
    &_OB_TC_0__OBE_C_IntBuffer
};

static char* _OB_TC__OBE_C_Camera_CameraParameter__OB_tc_member_names[] =
{
    (char*)"type",
    (char*)"frontClipDistance",
    (char*)"backClipDistance",
    (char*)"fieldOfView",
    (char*)"sensorId",
    (char*)"sensorName",
    (char*)"defName",
    (char*)"width",
    (char*)"height"
};

_CORBA_TypeCode _OB_TC__OBE_C_Camera_CameraParameter =
{
    CORBA_tk_struct,
    (char*)"IDL:Camera/CameraParameter:1.0",
    (char*)"CameraParameter",
    9,
    _OB_TC__OBE_C_Camera_CameraParameter__OB_tc_member_names,
    _OB_TC__OBE_C_Camera_CameraParameter__OB_tc_member_types,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_Camera_CameraParameter(&_OB_TC__OBE_C_Camera_CameraParameter);

//
// IDL:CameraSeq:1.0
//

static _CORBA_TypeCode _OB_TC_0__OBE_C_CameraSeq =
{
    CORBA_tk_sequence,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC__OBE_C_Camera,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC__OBE_C_CameraSeq =
{
    CORBA_tk_alias,
    (char*)"IDL:CameraSeq:1.0",
    (char*)"CameraSeq",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_0__OBE_C_CameraSeq,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_CameraSeq(&_OB_TC__OBE_C_CameraSeq);

//
// IDL:VisionSensor:1.0
//
static _CORBA_TypeCode _OB_TC__OBE_C_VisionSensor =
{
    CORBA_tk_objref,
    (char*)"IDL:VisionSensor:1.0",
    (char*)"VisionSensor",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_VisionSensor(&_OB_TC__OBE_C_VisionSensor);

//
// IDL:VisionSensor/VisionSensorException:1.0
//

extern _CORBA_TypeCode _OB_TC__OBE_C_VisionSensor_VisionSensorException;

static _CORBA_TypeCode* _OB_TC__OBE_C_VisionSensor_VisionSensorException__OB_tc_member_types[] =
{
    &_OB_TC_0__OBE_C_Camera_CameraParameter
};

static char* _OB_TC__OBE_C_VisionSensor_VisionSensorException__OB_tc_member_names[] =
{
    (char*)"description"
};

_CORBA_TypeCode _OB_TC__OBE_C_VisionSensor_VisionSensorException =
{
    CORBA_tk_except,
    (char*)"IDL:VisionSensor/VisionSensorException:1.0",
    (char*)"VisionSensorException",
    1,
    _OB_TC__OBE_C_VisionSensor_VisionSensorException__OB_tc_member_names,
    _OB_TC__OBE_C_VisionSensor_VisionSensorException__OB_tc_member_types,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_VisionSensor_VisionSensorException(&_OB_TC__OBE_C_VisionSensor_VisionSensorException);

//
// IDL:VisionSensorFactory:1.0
//
static _CORBA_TypeCode _OB_TC__OBE_C_VisionSensorFactory =
{
    CORBA_tk_objref,
    (char*)"IDL:VisionSensorFactory:1.0",
    (char*)"VisionSensorFactory",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_VisionSensorFactory(&_OB_TC__OBE_C_VisionSensorFactory);

CORBA::TypeCode_ptr _tc_FloatBuffer = &_OBE_TC_FloatBuffer;

CORBA::TypeCode_ptr _tc_IntBuffer = &_OBE_TC_IntBuffer;

CORBA::TypeCode_ptr _tc_DepthBuffer = &_OBE_TC_DepthBuffer;

CORBA::TypeCode_ptr _tc_ColorBuffer = &_OBE_TC_ColorBuffer;

CORBA::TypeCode_ptr _tc_LinkAngles = &_OBE_TC_LinkAngles;

CORBA::TypeCode_ptr _tc_Camera = &_OBE_TC_Camera;

CORBA::TypeCode_ptr Camera::_tc_CameraType = &_OBE_TC_Camera_CameraType;

CORBA::TypeCode_ptr Camera::_tc_CameraParameter = &_OBE_TC_Camera_CameraParameter;

CORBA::TypeCode_ptr _tc_CameraSeq = &_OBE_TC_CameraSeq;

CORBA::TypeCode_ptr _tc_VisionSensor = &_OBE_TC_VisionSensor;

CORBA::TypeCode_ptr VisionSensor::_tc_VisionSensorException = &_OBE_TC_VisionSensor_VisionSensorException;

CORBA::TypeCode_ptr _tc_VisionSensorFactory = &_OBE_TC_VisionSensorFactory;

//
// IDL:FloatBuffer:1.0
//
static CORBA::AnyContentDestroyerDelete<FloatBuffer> OBAnyContentDestroyerInstance_FloatBuffer;

void
operator<<=(CORBA::Any& any, FloatBuffer* v)
{
    _OBE_C_CORBA_sequence_float* p = (_OBE_C_CORBA_sequence_float*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_FloatBuffer->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence_float));
    (*p)._length = (*v).length();
    (*p)._maximum = (*v).length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (CORBA_float*)OBEC_allocate_buffer(NULL, sizeof(CORBA_float) * (*p)._length, (*p)._length, OBEC_FALSE);

    memcpy((*p)._buffer, (*v).get_buffer(), sizeof(CORBA_float) * (*p)._length);
    any.replace(_tc_FloatBuffer, p, false, v, &OBAnyContentDestroyerInstance_FloatBuffer);
}

void
operator<<=(CORBA::Any& any, const FloatBuffer& v)
{
    _OBE_C_CORBA_sequence_float* p = (_OBE_C_CORBA_sequence_float*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_FloatBuffer->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence_float));
    (*p)._length = v.length();
    (*p)._maximum = v.length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (CORBA_float*)OBEC_allocate_buffer(NULL, sizeof(CORBA_float) * (*p)._length, (*p)._length, OBEC_FALSE);

    memcpy((*p)._buffer, v.get_buffer(), sizeof(CORBA_float) * (*p)._length);
    any.replace(_tc_FloatBuffer, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const FloatBuffer*& v)
{
    if (!any.check_type(_tc_FloatBuffer))
        return false;

    v = (const FloatBuffer*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_CORBA_sequence_float* p = (_OBE_C_CORBA_sequence_float*)any.value();
        assert(p != NULL);
        FloatBuffer* val = new FloatBuffer;
        (*val).length((*p)._length);

        memcpy((*val).get_buffer(), (*p)._buffer, sizeof(CORBA_float) * (*p)._length);
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_FloatBuffer);
        v = val;
    }

    return true;
}

//
// IDL:IntBuffer:1.0
//
static CORBA::AnyContentDestroyerDelete<IntBuffer> OBAnyContentDestroyerInstance_IntBuffer;

void
operator<<=(CORBA::Any& any, IntBuffer* v)
{
    _OBE_C_CORBA_sequence_long* p = (_OBE_C_CORBA_sequence_long*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_IntBuffer->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence_long));
    (*p)._length = (*v).length();
    (*p)._maximum = (*v).length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (CORBA_long*)OBEC_allocate_buffer(NULL, sizeof(CORBA_long) * (*p)._length, (*p)._length, OBEC_FALSE);

    memcpy((*p)._buffer, (*v).get_buffer(), sizeof(CORBA_long) * (*p)._length);
    any.replace(_tc_IntBuffer, p, false, v, &OBAnyContentDestroyerInstance_IntBuffer);
}

void
operator<<=(CORBA::Any& any, const IntBuffer& v)
{
    _OBE_C_CORBA_sequence_long* p = (_OBE_C_CORBA_sequence_long*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_IntBuffer->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence_long));
    (*p)._length = v.length();
    (*p)._maximum = v.length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (CORBA_long*)OBEC_allocate_buffer(NULL, sizeof(CORBA_long) * (*p)._length, (*p)._length, OBEC_FALSE);

    memcpy((*p)._buffer, v.get_buffer(), sizeof(CORBA_long) * (*p)._length);
    any.replace(_tc_IntBuffer, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const IntBuffer*& v)
{
    if (!any.check_type(_tc_IntBuffer))
        return false;

    v = (const IntBuffer*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_CORBA_sequence_long* p = (_OBE_C_CORBA_sequence_long*)any.value();
        assert(p != NULL);
        IntBuffer* val = new IntBuffer;
        (*val).length((*p)._length);

        memcpy((*val).get_buffer(), (*p)._buffer, sizeof(CORBA_long) * (*p)._length);
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_IntBuffer);
        v = val;
    }

    return true;
}

//
// IDL:Camera:1.0
//
const char* Camera::ids_[] =
{
    "IDL:Camera:1.0",
    0
};

void
OBDuplicate(Camera_ptr p)
{
    if(p)
        p -> _OB_incRef();
}

void
OBRelease(Camera_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

Camera_ptr
Camera::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        Camera_ptr v = dynamic_cast<Camera_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            ::Camera* val = new ::Camera;
            val -> _OB_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

const char**
Camera::_OB_staticIds()
{
    return ids_;
}

const char**
Camera::_OB_ids() const
{
    return ::Camera::ids_;
}

void
OBMarshal(
    Camera_ptr _ob_v,
    OBEC_OutputStreamImpl* _ob_out,
    CORBA_Environment* _ob_cev
)
{
    CORBA_Object _ob_cobj = NULL;
    if (_ob_v)
    {
        _ob_cobj = _ob_v->_OB_impl_nodup();
        assert(_ob_cobj != NULL);
    }
    OBEC_OutputStreamImpl_write_Object(_ob_out, _ob_cobj, _ob_cev);
}

void
OBUnmarshal(
    Camera_ptr& _ob_v,
    OBEC_InputStreamImpl* _ob_in,
    CORBA_Environment* _ob_cev
)
{
    Camera_var old = _ob_v;
    CORBA_Object _ob_cobj = OBEC_InputStreamImpl_read_Object(_ob_in, _ob_cev);

    if (_ob_cobj != NULL && _ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_v = new Camera;
        _ob_v->_OB_setup(_ob_cobj);
        CORBA_Object_release(_ob_cobj);
    }
    else
        _ob_v = Camera::_nil();
}

//
// IDL:Camera/destroy:1.0
//
void
Camera::_OB_op_destroy(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile, _ob_stub_impl->m_policies, "destroy", 7, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);



            if (OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }
            else
            {
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);
}

//
// IDL:Camera/getCameraParameter:1.0
//
::Camera::CameraParameter*
Camera::_OB_op_getCameraParameter(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::Camera::CameraParameter_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile, _ob_stub_impl->m_policies, "getCameraParameter", 18, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }
            else
            {
                _ob_r = new ::Camera::CameraParameter;
                ::Camera::CameraParameter::_OB_unmarshal(_ob_r.inout(), _ob_in, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }

                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

//
// IDL:Camera/getColorBuffer:1.0
//
::ColorBuffer*
Camera::_OB_op_getColorBuffer(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::ColorBuffer_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile, _ob_stub_impl->m_policies, "getColorBuffer", 14, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }
            else
            {
                _ob_r = new ::ColorBuffer;
                CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
                _ob_r -> length(_ob_len0);
                OBEC_InputStreamImpl_read_long_array(_ob_in, _ob_r -> get_buffer(), _ob_len0, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }

                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

//
// IDL:Camera/getDepthBuffer:1.0
//
::DepthBuffer*
Camera::_OB_op_getDepthBuffer(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::DepthBuffer_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile, _ob_stub_impl->m_policies, "getDepthBuffer", 14, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }
            else
            {
                _ob_r = new ::DepthBuffer;
                CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
                _ob_r -> length(_ob_len0);
                OBEC_InputStreamImpl_read_float_array(_ob_in, _ob_r -> get_buffer(), _ob_len0, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }

                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

//
// IDL:Camera/getImageData:1.0
//
::ImageData*
Camera::_OB_op_getImageData(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::ImageData_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile, _ob_stub_impl->m_policies, "getImageData", 12, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }
            else
            {
                _ob_r = new ::ImageData;
                ::ImageData::_OB_unmarshal(_ob_r.inout(), _ob_in, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }

                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

void
operator<<=(CORBA::Any& any, Camera_ptr* v)
{
    CORBA_Object cobj = CORBA_OBJECT_NIL;
    if (!CORBA::is_nil(*v))
    {
        cobj = (*v)->_OB_impl_nodup();
    }
    any.replace(_tc_Camera, &cobj, true, (CORBA::Object_ptr)*v, &CORBA::Any::sm_any_content_destroyer_object);
}

void
operator<<=(CORBA::Any& any, Camera_ptr v)
{
    Camera_ptr val = Camera::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, Camera_ptr& v)
{
    if (any.check_type(_tc_Camera))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.cpp_value();
        if (!CORBA::is_nil(val))
            v = dynamic_cast<Camera_ptr>(val);
        else
        {
            CORBA_Object cobj = *(CORBA_Object*)any.value();
            if (cobj != CORBA_OBJECT_NIL)
            {
                Camera* obj = new Camera;
                obj->_OB_setup(cobj);
                v = obj;
                ((CORBA::Any&)any).cpp_value((CORBA::Object_ptr)obj, &CORBA::Any::sm_any_content_destroyer_object);
            }
            else
                v = Camera::_nil();
        }

        return true;
    }
    else
        return false;
}

//
// IDL:Camera/CameraType:1.0
//
void
operator<<=(CORBA::Any& any, Camera::CameraType v)
{
    CORBA_unsigned_long* p = (CORBA_unsigned_long*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, Camera::_tc_CameraType->_OB_impl_nodup(), sizeof(CORBA_unsigned_long)); 
    *p = (CORBA_unsigned_long)v;
    any.replace(Camera::_tc_CameraType, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, Camera::CameraType& v)
{
    if (!any.check_type(Camera::_tc_CameraType))
        return false;

    v = (Camera::CameraType)(*(CORBA_unsigned_long*)any.value());

    return true;
}

//
// IDL:Camera/CameraParameter:1.0
//
#ifdef OB_PURIFY_CLEAN
Camera::CameraParameter::CameraParameter()
{
    memset(&type, 0, sizeof(type));
    memset(&frontClipDistance, 0, sizeof(frontClipDistance));
    memset(&backClipDistance, 0, sizeof(backClipDistance));
    memset(&fieldOfView, 0, sizeof(fieldOfView));
    memset(&sensorId, 0, sizeof(sensorId));
    memset(&width, 0, sizeof(width));
    memset(&height, 0, sizeof(height));
}
#endif

Camera::CameraParameter::CameraParameter(const CameraParameter& _ob_a)
    : type(_ob_a.type),
      frontClipDistance(_ob_a.frontClipDistance),
      backClipDistance(_ob_a.backClipDistance),
      fieldOfView(_ob_a.fieldOfView),
      sensorId(_ob_a.sensorId),
      sensorName(_ob_a.sensorName),
      defName(_ob_a.defName),
      width(_ob_a.width),
      height(_ob_a.height)
{
}

Camera::CameraParameter&
Camera::CameraParameter::operator=(const CameraParameter& _ob_a)
{
    if(this != &_ob_a)
    {
        type = _ob_a.type;
        frontClipDistance = _ob_a.frontClipDistance;
        backClipDistance = _ob_a.backClipDistance;
        fieldOfView = _ob_a.fieldOfView;
        sensorId = _ob_a.sensorId;
        sensorName = _ob_a.sensorName;
        defName = _ob_a.defName;
        width = _ob_a.width;
        height = _ob_a.height;
    }
    return *this;
}

void
Camera::CameraParameter::_OB_marshal(
    OBEC_OutputStreamImpl* _ob_out,
    CORBA_Environment* _ob_cev
) const
{
    OBEC_OutputStreamImpl_write_ulong(_ob_out, (CORBA::ULong)type, _ob_cev);
    OBEC_OutputStreamImpl_write_float(_ob_out, frontClipDistance, _ob_cev);
    OBEC_OutputStreamImpl_write_float(_ob_out, backClipDistance, _ob_cev);
    OBEC_OutputStreamImpl_write_float(_ob_out, fieldOfView, _ob_cev);
    OBEC_OutputStreamImpl_write_long(_ob_out, sensorId, _ob_cev);
    OBEC_OutputStreamImpl_write_string(_ob_out, sensorName, _ob_cev);
    OBEC_OutputStreamImpl_write_string(_ob_out, defName, _ob_cev);
    OBEC_OutputStreamImpl_write_long(_ob_out, width, _ob_cev);
    OBEC_OutputStreamImpl_write_long(_ob_out, height, _ob_cev);
}

void
Camera::CameraParameter::_OB_unmarshal(
    CameraParameter& _ob_v,
    OBEC_InputStreamImpl* _ob_in,
    CORBA_Environment* _ob_cev
)
{
    _ob_v.type = (CameraType)OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.frontClipDistance = OBEC_InputStreamImpl_read_float(_ob_in, _ob_cev);
    _ob_v.backClipDistance = OBEC_InputStreamImpl_read_float(_ob_in, _ob_cev);
    _ob_v.fieldOfView = OBEC_InputStreamImpl_read_float(_ob_in, _ob_cev);
    _ob_v.sensorId = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    _ob_v.sensorName = OBEC_InputStreamImpl_read_string(_ob_in, _ob_cev);
    _ob_v.defName = OBEC_InputStreamImpl_read_string(_ob_in, _ob_cev);
    _ob_v.width = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    _ob_v.height = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
}

void
Camera::CameraParameter::_OB_convert_to(
    void* _ob_data
) const
{
    _OBE_C_Camera_CameraParameter* _ob_p = (_OBE_C_Camera_CameraParameter*)_ob_data;
    _ob_p->type = (CORBA_unsigned_long)type;
    _ob_p->frontClipDistance = frontClipDistance;
    _ob_p->backClipDistance = backClipDistance;
    _ob_p->fieldOfView = fieldOfView;
    _ob_p->sensorId = sensorId;
    _ob_p->sensorName = CORBA_string_dup(sensorName);
    _ob_p->defName = CORBA_string_dup(defName);
    _ob_p->width = width;
    _ob_p->height = height;
}

void
Camera::CameraParameter::_OB_convert_from(
    CameraParameter& _ob_v,
    void* _ob_data
)
{
    _OBE_C_Camera_CameraParameter* _ob_p = (_OBE_C_Camera_CameraParameter*)_ob_data;
    _ob_v.type = (Camera::CameraType)_ob_p->type;
    _ob_v.frontClipDistance = _ob_p->frontClipDistance;
    _ob_v.backClipDistance = _ob_p->backClipDistance;
    _ob_v.fieldOfView = _ob_p->fieldOfView;
    _ob_v.sensorId = _ob_p->sensorId;
    _ob_v.sensorName = CORBA::string_dup(_ob_p->sensorName);
    _ob_v.defName = CORBA::string_dup(_ob_p->defName);
    _ob_v.width = _ob_p->width;
    _ob_v.height = _ob_p->height;
}

static CORBA::AnyContentDestroyerDelete<Camera::CameraParameter> OBAnyContentDestroyerInstance_Camera_CameraParameter;

void
operator<<=(CORBA::Any& any, Camera::CameraParameter* v)
{
    _OBE_C_Camera_CameraParameter* p = (_OBE_C_Camera_CameraParameter*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, Camera::_tc_CameraParameter->_OB_impl_nodup(), sizeof(_OBE_C_Camera_CameraParameter));
    (*v)._OB_convert_to(&(*p));
    any.replace(Camera::_tc_CameraParameter, p, false, v, &OBAnyContentDestroyerInstance_Camera_CameraParameter);
}

void
operator<<=(CORBA::Any& any, const Camera::CameraParameter& v)
{
    _OBE_C_Camera_CameraParameter* p = (_OBE_C_Camera_CameraParameter*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, Camera::_tc_CameraParameter->_OB_impl_nodup(), sizeof(_OBE_C_Camera_CameraParameter));
    v._OB_convert_to(&(*p));
    any.replace(Camera::_tc_CameraParameter, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const Camera::CameraParameter*& v)
{
    if (!any.check_type(Camera::_tc_CameraParameter))
        return 0;

    v = (const Camera::CameraParameter*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_Camera_CameraParameter* p = (_OBE_C_Camera_CameraParameter*)any.value();
        assert(p != NULL);
        Camera::CameraParameter* val = new Camera::CameraParameter;
        Camera::CameraParameter::_OB_convert_from((*val), &(*p));
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_Camera_CameraParameter);
        v = val;
    }

    return 1;
}

//
// IDL:Camera/destroy:1.0
//
void
Camera::destroy(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _OB_op_destroy(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();
}

//
// IDL:Camera/getCameraParameter:1.0
//
::Camera::CameraParameter*
Camera::getCameraParameter(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::Camera::CameraParameter_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_op_getCameraParameter(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:Camera/getColorBuffer:1.0
//
::ColorBuffer*
Camera::getColorBuffer(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::ColorBuffer_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_op_getColorBuffer(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:Camera/getDepthBuffer:1.0
//
::DepthBuffer*
Camera::getDepthBuffer(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::DepthBuffer_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_op_getDepthBuffer(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:Camera/getImageData:1.0
//
::ImageData*
Camera::getImageData(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::ImageData_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_op_getImageData(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:CameraSeq:1.0
//
static CORBA::AnyContentDestroyerDelete<CameraSeq> OBAnyContentDestroyerInstance_CameraSeq;

void
operator<<=(CORBA::Any& any, CameraSeq* v)
{
    _OBE_C_CORBA_sequence__OBE_C_Camera* p = (_OBE_C_CORBA_sequence__OBE_C_Camera*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_CameraSeq->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence__OBE_C_Camera));
    (*p)._length = (*v).length();
    (*p)._maximum = (*v).length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (_OBE_C_Camera*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_Camera) * (*p)._length, (*p)._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
    {
        if (CORBA::is_nil((*v)[_ob_i0]))
            (*p)._buffer[_ob_i0] = CORBA_OBJECT_NIL;
        else
            (*p)._buffer[_ob_i0] = CORBA_Object_duplicate((*v)[_ob_i0]->_OB_impl_nodup());
    }
    any.replace(_tc_CameraSeq, p, false, v, &OBAnyContentDestroyerInstance_CameraSeq);
}

void
operator<<=(CORBA::Any& any, const CameraSeq& v)
{
    _OBE_C_CORBA_sequence__OBE_C_Camera* p = (_OBE_C_CORBA_sequence__OBE_C_Camera*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_CameraSeq->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence__OBE_C_Camera));
    (*p)._length = v.length();
    (*p)._maximum = v.length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (_OBE_C_Camera*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_Camera) * (*p)._length, (*p)._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
    {
        if (CORBA::is_nil(v[_ob_i0]))
            (*p)._buffer[_ob_i0] = CORBA_OBJECT_NIL;
        else
            (*p)._buffer[_ob_i0] = CORBA_Object_duplicate(v[_ob_i0]->_OB_impl_nodup());
    }
    any.replace(_tc_CameraSeq, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CameraSeq*& v)
{
    if (!any.check_type(_tc_CameraSeq))
        return false;

    v = (const CameraSeq*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_CORBA_sequence__OBE_C_Camera* p = (_OBE_C_CORBA_sequence__OBE_C_Camera*)any.value();
        assert(p != NULL);
        CameraSeq* val = new CameraSeq;
        (*val).length((*p)._length);

        for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
        {
            if ((*p)._buffer[_ob_i0] == CORBA_OBJECT_NIL)
                (*val)[_ob_i0] = Camera::_nil();
            else
            {
                (*val)[_ob_i0] = new Camera;
                (*val)[_ob_i0]->_OB_setup((*p)._buffer[_ob_i0]);
            }
        }
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_CameraSeq);
        v = val;
    }

    return true;
}

//
// IDL:VisionSensor:1.0
//
const char* VisionSensor::ids_[] =
{
    "IDL:VisionSensor:1.0",
    0
};

void
OBDuplicate(VisionSensor_ptr p)
{
    if(p)
        p -> _OB_incRef();
}

void
OBRelease(VisionSensor_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

VisionSensor_ptr
VisionSensor::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        VisionSensor_ptr v = dynamic_cast<VisionSensor_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            ::VisionSensor* val = new ::VisionSensor;
            val -> _OB_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

const char**
VisionSensor::_OB_staticIds()
{
    return ids_;
}

const char**
VisionSensor::_OB_ids() const
{
    return ::VisionSensor::ids_;
}

void
OBMarshal(
    VisionSensor_ptr _ob_v,
    OBEC_OutputStreamImpl* _ob_out,
    CORBA_Environment* _ob_cev
)
{
    CORBA_Object _ob_cobj = NULL;
    if (_ob_v)
    {
        _ob_cobj = _ob_v->_OB_impl_nodup();
        assert(_ob_cobj != NULL);
    }
    OBEC_OutputStreamImpl_write_Object(_ob_out, _ob_cobj, _ob_cev);
}

void
OBUnmarshal(
    VisionSensor_ptr& _ob_v,
    OBEC_InputStreamImpl* _ob_in,
    CORBA_Environment* _ob_cev
)
{
    VisionSensor_var old = _ob_v;
    CORBA_Object _ob_cobj = OBEC_InputStreamImpl_read_Object(_ob_in, _ob_cev);

    if (_ob_cobj != NULL && _ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_v = new VisionSensor;
        _ob_v->_OB_setup(_ob_cobj);
        CORBA_Object_release(_ob_cobj);
    }
    else
        _ob_v = VisionSensor::_nil();
}

//
// IDL:VisionSensor/destroy:1.0
//
void
VisionSensor::_OB_op_destroy(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile, _ob_stub_impl->m_policies, "destroy", 7, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);



            if (OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }
            else
            {
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);
}

//
// IDL:VisionSensor/loadObject:1.0
//
void
VisionSensor::_OB_op_loadObject(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    const char* src,
    const char* objectName,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_OutputStreamImpl* _ob_out;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile, _ob_stub_impl->m_policies, "loadObject", 10, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            _ob_out = OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            OBEC_OutputStreamImpl_write_string(_ob_out, src, _ob_cev);
            OBEC_OutputStreamImpl_write_string(_ob_out, objectName, _ob_cev);
            if (_ob_cev->_major == CORBA_SYSTEM_EXCEPTION)
            {
                OBEC_DowncallImpl_marshalEx(&_ob_down, _ob_cev);
                break;
            }

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                CORBA::Boolean _ob_ex_set = (_ob_cev->_major == CORBA_USER_EXCEPTION);
                CORBA_char* _ob_id;

                if (_ob_ex_set)
                {
                    _ob_id = CORBA_exception_id(_ob_cev);
                }
                else
                {
                    _ob_id = OBEC_DowncallImpl_unmarshalExceptionId(&_ob_down, _ob_cev);
                    if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                    {
                        OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                        break;
                    }
                    OBEC_CREATE_DESTRUCTOR(CORBA_free, _ob_id, OBEC_TRUE, _ob_cev);
                }

                if (strcmp(_ob_id, "IDL:VisionSensor/VisionSensorException:1.0") == 0)
                {
                    if (!_ob_ex_set)
                    {
                        VisionSensor::VisionSensorException* _ob_except = new VisionSensor::VisionSensorException;
                        VisionSensor::VisionSensorException::_OB_unmarshal(*_ob_except, _ob_in, _ob_cev);
                        if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                        {
                            OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                            delete _ob_except;
                            break;
                        }
                        OB::ExceptionHolder* _ob_holder = OB::ExceptionHolder__alloc();
                        _ob_holder->value = _ob_except;
                        CORBA_exception_set(
                            _ob_cev,
                            CORBA_USER_EXCEPTION, 
                            "IDL:VisionSensor/VisionSensorException:1.0",
                            _ob_holder
                        );
                    }
                    OBEC_DowncallImpl_setUserException2(&_ob_down, _ob_cev);
                }
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }
            else
            {
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);
}

//
// IDL:VisionSensor/showObject:1.0
//
void
VisionSensor::_OB_op_showObject(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    const char* objectName,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_OutputStreamImpl* _ob_out;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile, _ob_stub_impl->m_policies, "showObject", 10, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            _ob_out = OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            OBEC_OutputStreamImpl_write_string(_ob_out, objectName, _ob_cev);
            if (_ob_cev->_major == CORBA_SYSTEM_EXCEPTION)
            {
                OBEC_DowncallImpl_marshalEx(&_ob_down, _ob_cev);
                break;
            }

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                CORBA::Boolean _ob_ex_set = (_ob_cev->_major == CORBA_USER_EXCEPTION);
                CORBA_char* _ob_id;

                if (_ob_ex_set)
                {
                    _ob_id = CORBA_exception_id(_ob_cev);
                }
                else
                {
                    _ob_id = OBEC_DowncallImpl_unmarshalExceptionId(&_ob_down, _ob_cev);
                    if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                    {
                        OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                        break;
                    }
                    OBEC_CREATE_DESTRUCTOR(CORBA_free, _ob_id, OBEC_TRUE, _ob_cev);
                }

                if (strcmp(_ob_id, "IDL:VisionSensor/VisionSensorException:1.0") == 0)
                {
                    if (!_ob_ex_set)
                    {
                        VisionSensor::VisionSensorException* _ob_except = new VisionSensor::VisionSensorException;
                        VisionSensor::VisionSensorException::_OB_unmarshal(*_ob_except, _ob_in, _ob_cev);
                        if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                        {
                            OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                            delete _ob_except;
                            break;
                        }
                        OB::ExceptionHolder* _ob_holder = OB::ExceptionHolder__alloc();
                        _ob_holder->value = _ob_except;
                        CORBA_exception_set(
                            _ob_cev,
                            CORBA_USER_EXCEPTION, 
                            "IDL:VisionSensor/VisionSensorException:1.0",
                            _ob_holder
                        );
                    }
                    OBEC_DowncallImpl_setUserException2(&_ob_down, _ob_cev);
                }
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }
            else
            {
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);
}

//
// IDL:VisionSensor/getCameraSeq:1.0
//
CORBA::Long
VisionSensor::_OB_op_getCameraSeq(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    ::CameraSeq_out cameras,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    CORBA::Long _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    _ob_r = 0;
    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile, _ob_stub_impl->m_policies, "getCameraSeq", 12, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }
            else
            {
                _ob_r = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
                cameras = new ::CameraSeq;
                CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
                cameras -> length(_ob_len0);
                ::Camera_ptr * _ob_buf0 = cameras -> get_buffer();
                for(CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
                {
                    OBUnmarshal(_ob_buf0[_ob_i0], _ob_in, _ob_cev);
                }
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }

                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r;
}

//
// IDL:VisionSensor/getCameraSeqOf:1.0
//
CORBA::Long
VisionSensor::_OB_op_getCameraSeqOf(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    const char* objectName,
    ::CameraSeq_out cameras,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    CORBA::Long _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    _ob_r = 0;
    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_OutputStreamImpl* _ob_out;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile, _ob_stub_impl->m_policies, "getCameraSeqOf", 14, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            _ob_out = OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            OBEC_OutputStreamImpl_write_string(_ob_out, objectName, _ob_cev);
            if (_ob_cev->_major == CORBA_SYSTEM_EXCEPTION)
            {
                OBEC_DowncallImpl_marshalEx(&_ob_down, _ob_cev);
                break;
            }

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }
            else
            {
                _ob_r = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
                cameras = new ::CameraSeq;
                CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
                cameras -> length(_ob_len0);
                ::Camera_ptr * _ob_buf0 = cameras -> get_buffer();
                for(CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
                {
                    OBUnmarshal(_ob_buf0[_ob_i0], _ob_in, _ob_cev);
                }
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }

                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r;
}

//
// IDL:VisionSensor/addCamera:1.0
//
::Camera_ptr
VisionSensor::_OB_op_addCamera(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    const char* objectName,
    const char* jointName,
    const ::Transform& transformation,
    const ::Camera::CameraParameter& cameraParam,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::Camera_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_OutputStreamImpl* _ob_out;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile, _ob_stub_impl->m_policies, "addCamera", 9, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            _ob_out = OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            OBEC_OutputStreamImpl_write_string(_ob_out, objectName, _ob_cev);
            OBEC_OutputStreamImpl_write_string(_ob_out, jointName, _ob_cev);
            transformation._OB_marshal(_ob_out, _ob_cev);
            cameraParam._OB_marshal(_ob_out, _ob_cev);
            if (_ob_cev->_major == CORBA_SYSTEM_EXCEPTION)
            {
                OBEC_DowncallImpl_marshalEx(&_ob_down, _ob_cev);
                break;
            }

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                CORBA::Boolean _ob_ex_set = (_ob_cev->_major == CORBA_USER_EXCEPTION);
                CORBA_char* _ob_id;

                if (_ob_ex_set)
                {
                    _ob_id = CORBA_exception_id(_ob_cev);
                }
                else
                {
                    _ob_id = OBEC_DowncallImpl_unmarshalExceptionId(&_ob_down, _ob_cev);
                    if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                    {
                        OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                        break;
                    }
                    OBEC_CREATE_DESTRUCTOR(CORBA_free, _ob_id, OBEC_TRUE, _ob_cev);
                }

                if (strcmp(_ob_id, "IDL:VisionSensor/VisionSensorException:1.0") == 0)
                {
                    if (!_ob_ex_set)
                    {
                        VisionSensor::VisionSensorException* _ob_except = new VisionSensor::VisionSensorException;
                        VisionSensor::VisionSensorException::_OB_unmarshal(*_ob_except, _ob_in, _ob_cev);
                        if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                        {
                            OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                            delete _ob_except;
                            break;
                        }
                        OB::ExceptionHolder* _ob_holder = OB::ExceptionHolder__alloc();
                        _ob_holder->value = _ob_except;
                        CORBA_exception_set(
                            _ob_cev,
                            CORBA_USER_EXCEPTION, 
                            "IDL:VisionSensor/VisionSensorException:1.0",
                            _ob_holder
                        );
                    }
                    OBEC_DowncallImpl_setUserException2(&_ob_down, _ob_cev);
                }
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }
            else
            {
                OBUnmarshal(_ob_r.inout(), _ob_in, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }

                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

//
// IDL:VisionSensor/updateScene:1.0
//
void
VisionSensor::_OB_op_updateScene(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    const ::WorldState& state,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_OutputStreamImpl* _ob_out;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile, _ob_stub_impl->m_policies, "updateScene", 11, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            _ob_out = OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            state._OB_marshal(_ob_out, _ob_cev);
            if (_ob_cev->_major == CORBA_SYSTEM_EXCEPTION)
            {
                OBEC_DowncallImpl_marshalEx(&_ob_down, _ob_cev);
                break;
            }

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);



            if (OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }
            else
            {
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);
}

void
operator<<=(CORBA::Any& any, VisionSensor_ptr* v)
{
    CORBA_Object cobj = CORBA_OBJECT_NIL;
    if (!CORBA::is_nil(*v))
    {
        cobj = (*v)->_OB_impl_nodup();
    }
    any.replace(_tc_VisionSensor, &cobj, true, (CORBA::Object_ptr)*v, &CORBA::Any::sm_any_content_destroyer_object);
}

void
operator<<=(CORBA::Any& any, VisionSensor_ptr v)
{
    VisionSensor_ptr val = VisionSensor::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, VisionSensor_ptr& v)
{
    if (any.check_type(_tc_VisionSensor))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.cpp_value();
        if (!CORBA::is_nil(val))
            v = dynamic_cast<VisionSensor_ptr>(val);
        else
        {
            CORBA_Object cobj = *(CORBA_Object*)any.value();
            if (cobj != CORBA_OBJECT_NIL)
            {
                VisionSensor* obj = new VisionSensor;
                obj->_OB_setup(cobj);
                v = obj;
                ((CORBA::Any&)any).cpp_value((CORBA::Object_ptr)obj, &CORBA::Any::sm_any_content_destroyer_object);
            }
            else
                v = VisionSensor::_nil();
        }

        return true;
    }
    else
        return false;
}

//
// IDL:VisionSensor/VisionSensorException:1.0
//
VisionSensor::VisionSensorException::VisionSensorException(const VisionSensorException& _ob_a)
    : CORBA::UserException(_ob_a),
      description(_ob_a.description)
{
}

VisionSensor::VisionSensorException::VisionSensorException(const char* _ob_a0)
    : description(_ob_a0)
{
}

VisionSensor::VisionSensorException&
VisionSensor::VisionSensorException::operator=(const VisionSensorException& _ob_a)
{
    if(this != &_ob_a)
    {
        description = _ob_a.description;
    }
    return *this;
}

const char*
VisionSensor::VisionSensorException::_rep_id() const
{
    return "IDL:VisionSensor/VisionSensorException:1.0";
}

CORBA::Exception*
VisionSensor::VisionSensorException::_OB_clone() const
{
    return new VisionSensorException(*this);
}

void
VisionSensor::VisionSensorException::_OB_marshal(
    OBEC_OutputStreamImpl* _ob_out,
    CORBA_Environment* _ob_cev
) const
{
#ifdef HAVE_VCPLUSPLUS_BUGS
    UserException::_OB_marshal(_ob_out, _ob_cev);
#else
    CORBA::UserException::_OB_marshal(_ob_out, _ob_cev);
#endif
    OBEC_OutputStreamImpl_write_string(_ob_out, description, _ob_cev);
}

void
VisionSensor::VisionSensorException::_OB_unmarshal(
    VisionSensorException& _ob_v,
    OBEC_InputStreamImpl* _ob_in,
    CORBA_Environment* _ob_cev
)
{
    CORBA::String_var id = OBEC_InputStreamImpl_read_string(_ob_in, _ob_cev);
    assert(strcmp(id, "IDL:VisionSensor/VisionSensorException:1.0") == 0);
    _ob_v.description = OBEC_InputStreamImpl_read_string(_ob_in, _ob_cev);
}

void
VisionSensor::VisionSensorException::_OB_convert_to(
    void* _ob_data
) const
{
    _OBE_C_VisionSensor_VisionSensorException* _ob_p = (_OBE_C_VisionSensor_VisionSensorException*)_ob_data;
    _ob_p->description = CORBA_string_dup(description);
}

void
VisionSensor::VisionSensorException::_OB_convert_from(
    VisionSensorException& _ob_v,
    void* _ob_data
)
{
    _OBE_C_VisionSensor_VisionSensorException* _ob_p = (_OBE_C_VisionSensor_VisionSensorException*)_ob_data;
    _ob_v.description = CORBA::string_dup(_ob_p->description);
}

static CORBA::AnyContentDestroyerDelete<VisionSensor::VisionSensorException> OBAnyContentDestroyerInstance_VisionSensor_VisionSensorException;

void
operator<<=(CORBA::Any& any, VisionSensor::VisionSensorException* v)
{
    _OBE_C_VisionSensor_VisionSensorException* p = (_OBE_C_VisionSensor_VisionSensorException*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, VisionSensor::_tc_VisionSensorException->_OB_impl_nodup(), sizeof(_OBE_C_VisionSensor_VisionSensorException));
    (*v)._OB_convert_to(&(*p));
    any.replace(VisionSensor::_tc_VisionSensorException, p, false, v, &OBAnyContentDestroyerInstance_VisionSensor_VisionSensorException);
}

void
operator<<=(CORBA::Any& any, const VisionSensor::VisionSensorException& v)
{
    _OBE_C_VisionSensor_VisionSensorException* p = (_OBE_C_VisionSensor_VisionSensorException*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, VisionSensor::_tc_VisionSensorException->_OB_impl_nodup(), sizeof(_OBE_C_VisionSensor_VisionSensorException));
    v._OB_convert_to(&(*p));
    any.replace(VisionSensor::_tc_VisionSensorException, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const VisionSensor::VisionSensorException*& v)
{
    if (!any.check_type(VisionSensor::_tc_VisionSensorException))
        return 0;

    v = (const VisionSensor::VisionSensorException*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_VisionSensor_VisionSensorException* p = (_OBE_C_VisionSensor_VisionSensorException*)any.value();
        assert(p != NULL);
        VisionSensor::VisionSensorException* val = new VisionSensor::VisionSensorException;
        VisionSensor::VisionSensorException::_OB_convert_from((*val), &(*p));
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_VisionSensor_VisionSensorException);
        v = val;
    }

    return 1;
}

//
// IDL:VisionSensor/destroy:1.0
//
void
VisionSensor::destroy(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _OB_op_destroy(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();
}

//
// IDL:VisionSensor/loadObject:1.0
//
void
VisionSensor::loadObject(
    const char* src,
    const char* objectName
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _OB_op_loadObject(_ob_stub_impl, src, objectName, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();
}

//
// IDL:VisionSensor/showObject:1.0
//
void
VisionSensor::showObject(
    const char* objectName
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _OB_op_showObject(_ob_stub_impl, objectName, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();
}

//
// IDL:VisionSensor/getCameraSeq:1.0
//
CORBA::Long
VisionSensor::getCameraSeq(
    ::CameraSeq_out cameras
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA::Long _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    _ob_r = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_op_getCameraSeq(_ob_stub_impl, cameras, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r;
}

//
// IDL:VisionSensor/getCameraSeqOf:1.0
//
CORBA::Long
VisionSensor::getCameraSeqOf(
    const char* objectName,
    ::CameraSeq_out cameras
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA::Long _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    _ob_r = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_op_getCameraSeqOf(_ob_stub_impl, objectName, cameras, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r;
}

//
// IDL:VisionSensor/addCamera:1.0
//
::Camera_ptr
VisionSensor::addCamera(
    const char* objectName,
    const char* jointName,
    const ::Transform& transformation,
    const ::Camera::CameraParameter& cameraParam
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::Camera_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_op_addCamera(_ob_stub_impl, objectName, jointName, transformation, cameraParam, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:VisionSensor/updateScene:1.0
//
void
VisionSensor::updateScene(
    const ::WorldState& state
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _OB_op_updateScene(_ob_stub_impl, state, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();
}

//
// IDL:VisionSensorFactory:1.0
//
const char* VisionSensorFactory::ids_[] =
{
    "IDL:VisionSensorFactory:1.0",
    "IDL:OpenHRPObject:1.0",
    0
};

void
OBDuplicate(VisionSensorFactory_ptr p)
{
    if(p)
        p -> _OB_incRef();
}

void
OBRelease(VisionSensorFactory_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

VisionSensorFactory_ptr
VisionSensorFactory::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        VisionSensorFactory_ptr v = dynamic_cast<VisionSensorFactory_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            ::VisionSensorFactory* val = new ::VisionSensorFactory;
            val -> _OB_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

const char**
VisionSensorFactory::_OB_staticIds()
{
    return ids_;
}

const char**
VisionSensorFactory::_OB_ids() const
{
    return ::VisionSensorFactory::ids_;
}

void
OBMarshal(
    VisionSensorFactory_ptr _ob_v,
    OBEC_OutputStreamImpl* _ob_out,
    CORBA_Environment* _ob_cev
)
{
    CORBA_Object _ob_cobj = NULL;
    if (_ob_v)
    {
        _ob_cobj = _ob_v->_OB_impl_nodup();
        assert(_ob_cobj != NULL);
    }
    OBEC_OutputStreamImpl_write_Object(_ob_out, _ob_cobj, _ob_cev);
}

void
OBUnmarshal(
    VisionSensorFactory_ptr& _ob_v,
    OBEC_InputStreamImpl* _ob_in,
    CORBA_Environment* _ob_cev
)
{
    VisionSensorFactory_var old = _ob_v;
    CORBA_Object _ob_cobj = OBEC_InputStreamImpl_read_Object(_ob_in, _ob_cev);

    if (_ob_cobj != NULL && _ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_v = new VisionSensorFactory;
        _ob_v->_OB_setup(_ob_cobj);
        CORBA_Object_release(_ob_cobj);
    }
    else
        _ob_v = VisionSensorFactory::_nil();
}

//
// IDL:VisionSensorFactory/createVisionSensor:1.0
//
::VisionSensor_ptr
VisionSensorFactory::_OB_op_createVisionSensor(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::VisionSensor_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile, _ob_stub_impl->m_policies, "createVisionSensor", 18, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }
            else
            {
                OBUnmarshal(_ob_r.inout(), _ob_in, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }

                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

void
operator<<=(CORBA::Any& any, VisionSensorFactory_ptr* v)
{
    CORBA_Object cobj = CORBA_OBJECT_NIL;
    if (!CORBA::is_nil(*v))
    {
        cobj = (*v)->_OB_impl_nodup();
    }
    any.replace(_tc_VisionSensorFactory, &cobj, true, (CORBA::Object_ptr)*v, &CORBA::Any::sm_any_content_destroyer_object);
}

void
operator<<=(CORBA::Any& any, VisionSensorFactory_ptr v)
{
    VisionSensorFactory_ptr val = VisionSensorFactory::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, VisionSensorFactory_ptr& v)
{
    if (any.check_type(_tc_VisionSensorFactory))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.cpp_value();
        if (!CORBA::is_nil(val))
            v = dynamic_cast<VisionSensorFactory_ptr>(val);
        else
        {
            CORBA_Object cobj = *(CORBA_Object*)any.value();
            if (cobj != CORBA_OBJECT_NIL)
            {
                VisionSensorFactory* obj = new VisionSensorFactory;
                obj->_OB_setup(cobj);
                v = obj;
                ((CORBA::Any&)any).cpp_value((CORBA::Object_ptr)obj, &CORBA::Any::sm_any_content_destroyer_object);
            }
            else
                v = VisionSensorFactory::_nil();
        }

        return true;
    }
    else
        return false;
}

//
// IDL:VisionSensorFactory/createVisionSensor:1.0
//
::VisionSensor_ptr
VisionSensorFactory::createVisionSensor(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::VisionSensor_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_op_createVisionSensor(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}
