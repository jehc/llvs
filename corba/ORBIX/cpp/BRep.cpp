// **********************************************************************
//
// Generated by the Orbix/E IDL-to-C++ Translator
//
// Copyright (c) 2003
// IONA Technologies, Inc.
// Waltham, MA, USA
//
// All Rights Reserved
//
// **********************************************************************

// Version: 2.2.0

#include <OBE/CORBAClient.h>
#include <BRep.h>

#ifndef OBEC_INTEGER_VERSION
#   error No Orbix/E version defined! Is <OBE/CORBA.h> included?
#endif

#ifndef OBEC_NO_VERSION_CHECK
#   if (OBEC_INTEGER_VERSION != 2020000L)
#       error Orbix/E version mismatch!
#   endif
#endif

extern "C"
{

typedef struct _OBE_C_CBREP_Point _OBE_C_CBREP_Point;

struct _OBE_C_CBREP_Point
{
    CORBA_long label;
    CORBA_long n;
    CORBA_long row;
    CORBA_long col;
    CORBA_float rowd;
    CORBA_float cold;
    CORBA_float Xr;
    CORBA_float Yr;
    CORBA_float x;
    CORBA_float y;
    CORBA_float z;
    CORBA_float normals;
    CORBA_float Normal[3];
    CORBA_float Tangent[3];
    CORBA_float curvature;
    CORBA_float error;
    CORBA_octet red;
    CORBA_octet green;
    CORBA_octet blue;
};

#ifndef __OBE_C_CORBA_sequence__OBE_C_CBREP_Point_defined
#define __OBE_C_CORBA_sequence__OBE_C_CBREP_Point_defined
typedef struct
{
    CORBA_unsigned_long _maximum;
    CORBA_unsigned_long _length;
    _OBE_C_CBREP_Point* _buffer;
    CORBA_boolean _release;
} _OBE_C_CORBA_sequence__OBE_C_CBREP_Point;
#endif

typedef _OBE_C_CORBA_sequence__OBE_C_CBREP_Point _OBE_C_CBREP_PointSeq;

typedef struct _OBE_C_CBREP_Segment _OBE_C_CBREP_Segment;

struct _OBE_C_CBREP_Segment
{
    CORBA_long label;
    CORBA_long n;
    CORBA_long npoint;
    CORBA_float curvature;
    CORBA_float error;
    CORBA_float intensity_sigma;
    _OBE_C_CBREP_PointSeq point;
    CORBA_octet red;
    CORBA_octet green;
    CORBA_octet blue;
};

#ifndef __OBE_C_CORBA_sequence__OBE_C_CBREP_Segment_defined
#define __OBE_C_CORBA_sequence__OBE_C_CBREP_Segment_defined
typedef struct
{
    CORBA_unsigned_long _maximum;
    CORBA_unsigned_long _length;
    _OBE_C_CBREP_Segment* _buffer;
    CORBA_boolean _release;
} _OBE_C_CORBA_sequence__OBE_C_CBREP_Segment;
#endif

typedef _OBE_C_CORBA_sequence__OBE_C_CBREP_Segment _OBE_C_CBREP_SegmentSeq;

typedef struct _OBE_C_CBREP_Bound _OBE_C_CBREP_Bound;

struct _OBE_C_CBREP_Bound
{
    CORBA_long label;
    CORBA_long n;
    CORBA_long nsegment;
    CORBA_long npoint;
    _OBE_C_CBREP_SegmentSeq segment;
    _OBE_C_CBREP_PointSeq point;
};

#ifndef __OBE_C_CORBA_sequence__OBE_C_CBREP_Bound_defined
#define __OBE_C_CORBA_sequence__OBE_C_CBREP_Bound_defined
typedef struct
{
    CORBA_unsigned_long _maximum;
    CORBA_unsigned_long _length;
    _OBE_C_CBREP_Bound* _buffer;
    CORBA_boolean _release;
} _OBE_C_CORBA_sequence__OBE_C_CBREP_Bound;
#endif

typedef _OBE_C_CORBA_sequence__OBE_C_CBREP_Bound _OBE_C_CBREP_BoundSeq;

typedef struct _OBE_C_CBREP_Cnet _OBE_C_CBREP_Cnet;

struct _OBE_C_CBREP_Cnet
{
    CORBA_long label;
    CORBA_long n;
    CORBA_long mapcol;
    CORBA_long maprow;
    CORBA_float Position[3];
    CORBA_float Normal[3];
    CORBA_octet red;
    CORBA_octet green;
    CORBA_octet blue;
};

#ifndef __OBE_C_CORBA_sequence__OBE_C_CBREP_Cnet_defined
#define __OBE_C_CORBA_sequence__OBE_C_CBREP_Cnet_defined
typedef struct
{
    CORBA_unsigned_long _maximum;
    CORBA_unsigned_long _length;
    _OBE_C_CBREP_Cnet* _buffer;
    CORBA_boolean _release;
} _OBE_C_CORBA_sequence__OBE_C_CBREP_Cnet;
#endif

typedef _OBE_C_CORBA_sequence__OBE_C_CBREP_Cnet _OBE_C_CBREP_CnetSeq;

typedef struct _OBE_C_CBREP_Region _OBE_C_CBREP_Region;

struct _OBE_C_CBREP_Region
{
    CORBA_long label;
    CORBA_long n;
    CORBA_long nbound;
    CORBA_long nsegment;
    CORBA_long npoint;
    CORBA_long ncnet;
    CORBA_long area;
    CORBA_long width;
    CORBA_long type;
    CORBA_float intensity;
    CORBA_float std_deviation;
    _OBE_C_CBREP_BoundSeq bound;
    _OBE_C_CBREP_SegmentSeq segment;
    _OBE_C_CBREP_PointSeq point;
    _OBE_C_CBREP_CnetSeq cnet;
};

#ifndef __OBE_C_CORBA_sequence__OBE_C_CBREP_Region_defined
#define __OBE_C_CORBA_sequence__OBE_C_CBREP_Region_defined
typedef struct
{
    CORBA_unsigned_long _maximum;
    CORBA_unsigned_long _length;
    _OBE_C_CBREP_Region* _buffer;
    CORBA_boolean _release;
} _OBE_C_CORBA_sequence__OBE_C_CBREP_Region;
#endif

typedef _OBE_C_CORBA_sequence__OBE_C_CBREP_Region _OBE_C_CBREP_RegionSeq;

typedef struct _OBE_C_CBREP _OBE_C_CBREP;

struct _OBE_C_CBREP
{
    CORBA_long label;
    CORBA_long n;
    CORBA_long nregion;
    CORBA_long nbound;
    CORBA_long nsegment;
    CORBA_long npoint;
    CORBA_long ncnet;
    CORBA_long colstart;
    CORBA_long rowstart;
    CORBA_long ncol;
    CORBA_long nrow;
    _OBE_C_CBREP_RegionSeq region;
    _OBE_C_CBREP_BoundSeq bound;
    _OBE_C_CBREP_SegmentSeq segment;
    _OBE_C_CBREP_PointSeq point;
    _OBE_C_CBREP_CnetSeq cnet;
    CORBA_long CameraID;
};

#ifndef __OBE_C_CORBA_sequence__OBE_C_CBREP_defined
#define __OBE_C_CORBA_sequence__OBE_C_CBREP_defined
typedef struct
{
    CORBA_unsigned_long _maximum;
    CORBA_unsigned_long _length;
    _OBE_C_CBREP* _buffer;
    CORBA_boolean _release;
} _OBE_C_CORBA_sequence__OBE_C_CBREP;
#endif

typedef _OBE_C_CORBA_sequence__OBE_C_CBREP _OBE_C_CBREPSeq;
}

//
// IDL:CBREP_Point:1.0
//

extern _CORBA_TypeCode _OB_TC__OBE_C_CBREP_Point;

static _CORBA_TypeCode _OB_TC_0__OBE_C_CBREP_Point =
{
    CORBA_tk_long,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC_1__OBE_C_CBREP_Point =
{
    CORBA_tk_float,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC_2__OBE_C_CBREP_Point =
{
    CORBA_tk_array,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    3,
    &_OB_TC_1__OBE_C_CBREP_Point,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC_3__OBE_C_CBREP_Point =
{
    CORBA_tk_array,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    3,
    &_OB_TC_1__OBE_C_CBREP_Point,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC_4__OBE_C_CBREP_Point =
{
    CORBA_tk_octet,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static _CORBA_TypeCode* _OB_TC__OBE_C_CBREP_Point__OB_tc_member_types[] =
{
    &_OB_TC_0__OBE_C_CBREP_Point,
    &_OB_TC_0__OBE_C_CBREP_Point,
    &_OB_TC_0__OBE_C_CBREP_Point,
    &_OB_TC_0__OBE_C_CBREP_Point,
    &_OB_TC_1__OBE_C_CBREP_Point,
    &_OB_TC_1__OBE_C_CBREP_Point,
    &_OB_TC_1__OBE_C_CBREP_Point,
    &_OB_TC_1__OBE_C_CBREP_Point,
    &_OB_TC_1__OBE_C_CBREP_Point,
    &_OB_TC_1__OBE_C_CBREP_Point,
    &_OB_TC_1__OBE_C_CBREP_Point,
    &_OB_TC_1__OBE_C_CBREP_Point,
    &_OB_TC_2__OBE_C_CBREP_Point,
    &_OB_TC_3__OBE_C_CBREP_Point,
    &_OB_TC_1__OBE_C_CBREP_Point,
    &_OB_TC_1__OBE_C_CBREP_Point,
    &_OB_TC_4__OBE_C_CBREP_Point,
    &_OB_TC_4__OBE_C_CBREP_Point,
    &_OB_TC_4__OBE_C_CBREP_Point
};

static char* _OB_TC__OBE_C_CBREP_Point__OB_tc_member_names[] =
{
    (char*)"label",
    (char*)"n",
    (char*)"row",
    (char*)"col",
    (char*)"rowd",
    (char*)"cold",
    (char*)"Xr",
    (char*)"Yr",
    (char*)"x",
    (char*)"y",
    (char*)"z",
    (char*)"normals",
    (char*)"Normal",
    (char*)"Tangent",
    (char*)"curvature",
    (char*)"error",
    (char*)"red",
    (char*)"green",
    (char*)"blue"
};

_CORBA_TypeCode _OB_TC__OBE_C_CBREP_Point =
{
    CORBA_tk_struct,
    (char*)"IDL:CBREP_Point:1.0",
    (char*)"CBREP_Point",
    19,
    _OB_TC__OBE_C_CBREP_Point__OB_tc_member_names,
    _OB_TC__OBE_C_CBREP_Point__OB_tc_member_types,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_CBREP_Point(&_OB_TC__OBE_C_CBREP_Point);

//
// IDL:CBREP_PointSeq:1.0
//

static _CORBA_TypeCode _OB_TC_0__OBE_C_CBREP_PointSeq =
{
    CORBA_tk_sequence,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC__OBE_C_CBREP_Point,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC__OBE_C_CBREP_PointSeq =
{
    CORBA_tk_alias,
    (char*)"IDL:CBREP_PointSeq:1.0",
    (char*)"CBREP_PointSeq",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_0__OBE_C_CBREP_PointSeq,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_CBREP_PointSeq(&_OB_TC__OBE_C_CBREP_PointSeq);

//
// IDL:CBREP_Segment:1.0
//

extern _CORBA_TypeCode _OB_TC__OBE_C_CBREP_Segment;

static _CORBA_TypeCode* _OB_TC__OBE_C_CBREP_Segment__OB_tc_member_types[] =
{
    &_OB_TC_0__OBE_C_CBREP_Point,
    &_OB_TC_0__OBE_C_CBREP_Point,
    &_OB_TC_0__OBE_C_CBREP_Point,
    &_OB_TC_1__OBE_C_CBREP_Point,
    &_OB_TC_1__OBE_C_CBREP_Point,
    &_OB_TC_1__OBE_C_CBREP_Point,
    &_OB_TC__OBE_C_CBREP_PointSeq,
    &_OB_TC_4__OBE_C_CBREP_Point,
    &_OB_TC_4__OBE_C_CBREP_Point,
    &_OB_TC_4__OBE_C_CBREP_Point
};

static char* _OB_TC__OBE_C_CBREP_Segment__OB_tc_member_names[] =
{
    (char*)"label",
    (char*)"n",
    (char*)"npoint",
    (char*)"curvature",
    (char*)"error",
    (char*)"intensity_sigma",
    (char*)"point",
    (char*)"red",
    (char*)"green",
    (char*)"blue"
};

_CORBA_TypeCode _OB_TC__OBE_C_CBREP_Segment =
{
    CORBA_tk_struct,
    (char*)"IDL:CBREP_Segment:1.0",
    (char*)"CBREP_Segment",
    10,
    _OB_TC__OBE_C_CBREP_Segment__OB_tc_member_names,
    _OB_TC__OBE_C_CBREP_Segment__OB_tc_member_types,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_CBREP_Segment(&_OB_TC__OBE_C_CBREP_Segment);

//
// IDL:CBREP_SegmentSeq:1.0
//

static _CORBA_TypeCode _OB_TC_0__OBE_C_CBREP_SegmentSeq =
{
    CORBA_tk_sequence,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC__OBE_C_CBREP_Segment,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC__OBE_C_CBREP_SegmentSeq =
{
    CORBA_tk_alias,
    (char*)"IDL:CBREP_SegmentSeq:1.0",
    (char*)"CBREP_SegmentSeq",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_0__OBE_C_CBREP_SegmentSeq,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_CBREP_SegmentSeq(&_OB_TC__OBE_C_CBREP_SegmentSeq);

//
// IDL:CBREP_Bound:1.0
//

extern _CORBA_TypeCode _OB_TC__OBE_C_CBREP_Bound;

static _CORBA_TypeCode* _OB_TC__OBE_C_CBREP_Bound__OB_tc_member_types[] =
{
    &_OB_TC_0__OBE_C_CBREP_Point,
    &_OB_TC_0__OBE_C_CBREP_Point,
    &_OB_TC_0__OBE_C_CBREP_Point,
    &_OB_TC_0__OBE_C_CBREP_Point,
    &_OB_TC__OBE_C_CBREP_SegmentSeq,
    &_OB_TC__OBE_C_CBREP_PointSeq
};

static char* _OB_TC__OBE_C_CBREP_Bound__OB_tc_member_names[] =
{
    (char*)"label",
    (char*)"n",
    (char*)"nsegment",
    (char*)"npoint",
    (char*)"segment",
    (char*)"point"
};

_CORBA_TypeCode _OB_TC__OBE_C_CBREP_Bound =
{
    CORBA_tk_struct,
    (char*)"IDL:CBREP_Bound:1.0",
    (char*)"CBREP_Bound",
    6,
    _OB_TC__OBE_C_CBREP_Bound__OB_tc_member_names,
    _OB_TC__OBE_C_CBREP_Bound__OB_tc_member_types,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_CBREP_Bound(&_OB_TC__OBE_C_CBREP_Bound);

//
// IDL:CBREP_BoundSeq:1.0
//

static _CORBA_TypeCode _OB_TC_0__OBE_C_CBREP_BoundSeq =
{
    CORBA_tk_sequence,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC__OBE_C_CBREP_Bound,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC__OBE_C_CBREP_BoundSeq =
{
    CORBA_tk_alias,
    (char*)"IDL:CBREP_BoundSeq:1.0",
    (char*)"CBREP_BoundSeq",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_0__OBE_C_CBREP_BoundSeq,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_CBREP_BoundSeq(&_OB_TC__OBE_C_CBREP_BoundSeq);

//
// IDL:CBREP_Cnet:1.0
//

extern _CORBA_TypeCode _OB_TC__OBE_C_CBREP_Cnet;

static _CORBA_TypeCode _OB_TC_0__OBE_C_CBREP_Cnet =
{
    CORBA_tk_array,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    3,
    &_OB_TC_1__OBE_C_CBREP_Point,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC_1__OBE_C_CBREP_Cnet =
{
    CORBA_tk_array,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    3,
    &_OB_TC_1__OBE_C_CBREP_Point,
    OBEC_TRUE
};

static _CORBA_TypeCode* _OB_TC__OBE_C_CBREP_Cnet__OB_tc_member_types[] =
{
    &_OB_TC_0__OBE_C_CBREP_Point,
    &_OB_TC_0__OBE_C_CBREP_Point,
    &_OB_TC_0__OBE_C_CBREP_Point,
    &_OB_TC_0__OBE_C_CBREP_Point,
    &_OB_TC_0__OBE_C_CBREP_Cnet,
    &_OB_TC_1__OBE_C_CBREP_Cnet,
    &_OB_TC_4__OBE_C_CBREP_Point,
    &_OB_TC_4__OBE_C_CBREP_Point,
    &_OB_TC_4__OBE_C_CBREP_Point
};

static char* _OB_TC__OBE_C_CBREP_Cnet__OB_tc_member_names[] =
{
    (char*)"label",
    (char*)"n",
    (char*)"mapcol",
    (char*)"maprow",
    (char*)"Position",
    (char*)"Normal",
    (char*)"red",
    (char*)"green",
    (char*)"blue"
};

_CORBA_TypeCode _OB_TC__OBE_C_CBREP_Cnet =
{
    CORBA_tk_struct,
    (char*)"IDL:CBREP_Cnet:1.0",
    (char*)"CBREP_Cnet",
    9,
    _OB_TC__OBE_C_CBREP_Cnet__OB_tc_member_names,
    _OB_TC__OBE_C_CBREP_Cnet__OB_tc_member_types,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_CBREP_Cnet(&_OB_TC__OBE_C_CBREP_Cnet);

//
// IDL:CBREP_CnetSeq:1.0
//

static _CORBA_TypeCode _OB_TC_0__OBE_C_CBREP_CnetSeq =
{
    CORBA_tk_sequence,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC__OBE_C_CBREP_Cnet,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC__OBE_C_CBREP_CnetSeq =
{
    CORBA_tk_alias,
    (char*)"IDL:CBREP_CnetSeq:1.0",
    (char*)"CBREP_CnetSeq",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_0__OBE_C_CBREP_CnetSeq,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_CBREP_CnetSeq(&_OB_TC__OBE_C_CBREP_CnetSeq);

//
// IDL:CBREP_Region:1.0
//

extern _CORBA_TypeCode _OB_TC__OBE_C_CBREP_Region;

static _CORBA_TypeCode* _OB_TC__OBE_C_CBREP_Region__OB_tc_member_types[] =
{
    &_OB_TC_0__OBE_C_CBREP_Point,
    &_OB_TC_0__OBE_C_CBREP_Point,
    &_OB_TC_0__OBE_C_CBREP_Point,
    &_OB_TC_0__OBE_C_CBREP_Point,
    &_OB_TC_0__OBE_C_CBREP_Point,
    &_OB_TC_0__OBE_C_CBREP_Point,
    &_OB_TC_0__OBE_C_CBREP_Point,
    &_OB_TC_0__OBE_C_CBREP_Point,
    &_OB_TC_0__OBE_C_CBREP_Point,
    &_OB_TC_1__OBE_C_CBREP_Point,
    &_OB_TC_1__OBE_C_CBREP_Point,
    &_OB_TC__OBE_C_CBREP_BoundSeq,
    &_OB_TC__OBE_C_CBREP_SegmentSeq,
    &_OB_TC__OBE_C_CBREP_PointSeq,
    &_OB_TC__OBE_C_CBREP_CnetSeq
};

static char* _OB_TC__OBE_C_CBREP_Region__OB_tc_member_names[] =
{
    (char*)"label",
    (char*)"n",
    (char*)"nbound",
    (char*)"nsegment",
    (char*)"npoint",
    (char*)"ncnet",
    (char*)"area",
    (char*)"width",
    (char*)"type",
    (char*)"intensity",
    (char*)"std_deviation",
    (char*)"bound",
    (char*)"segment",
    (char*)"point",
    (char*)"cnet"
};

_CORBA_TypeCode _OB_TC__OBE_C_CBREP_Region =
{
    CORBA_tk_struct,
    (char*)"IDL:CBREP_Region:1.0",
    (char*)"CBREP_Region",
    15,
    _OB_TC__OBE_C_CBREP_Region__OB_tc_member_names,
    _OB_TC__OBE_C_CBREP_Region__OB_tc_member_types,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_CBREP_Region(&_OB_TC__OBE_C_CBREP_Region);

//
// IDL:CBREP_RegionSeq:1.0
//

static _CORBA_TypeCode _OB_TC_0__OBE_C_CBREP_RegionSeq =
{
    CORBA_tk_sequence,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC__OBE_C_CBREP_Region,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC__OBE_C_CBREP_RegionSeq =
{
    CORBA_tk_alias,
    (char*)"IDL:CBREP_RegionSeq:1.0",
    (char*)"CBREP_RegionSeq",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_0__OBE_C_CBREP_RegionSeq,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_CBREP_RegionSeq(&_OB_TC__OBE_C_CBREP_RegionSeq);

//
// IDL:CBREP:1.0
//

extern _CORBA_TypeCode _OB_TC__OBE_C_CBREP;

static _CORBA_TypeCode* _OB_TC__OBE_C_CBREP__OB_tc_member_types[] =
{
    &_OB_TC_0__OBE_C_CBREP_Point,
    &_OB_TC_0__OBE_C_CBREP_Point,
    &_OB_TC_0__OBE_C_CBREP_Point,
    &_OB_TC_0__OBE_C_CBREP_Point,
    &_OB_TC_0__OBE_C_CBREP_Point,
    &_OB_TC_0__OBE_C_CBREP_Point,
    &_OB_TC_0__OBE_C_CBREP_Point,
    &_OB_TC_0__OBE_C_CBREP_Point,
    &_OB_TC_0__OBE_C_CBREP_Point,
    &_OB_TC_0__OBE_C_CBREP_Point,
    &_OB_TC_0__OBE_C_CBREP_Point,
    &_OB_TC__OBE_C_CBREP_RegionSeq,
    &_OB_TC__OBE_C_CBREP_BoundSeq,
    &_OB_TC__OBE_C_CBREP_SegmentSeq,
    &_OB_TC__OBE_C_CBREP_PointSeq,
    &_OB_TC__OBE_C_CBREP_CnetSeq,
    &_OB_TC_0__OBE_C_CBREP_Point
};

static char* _OB_TC__OBE_C_CBREP__OB_tc_member_names[] =
{
    (char*)"label",
    (char*)"n",
    (char*)"nregion",
    (char*)"nbound",
    (char*)"nsegment",
    (char*)"npoint",
    (char*)"ncnet",
    (char*)"colstart",
    (char*)"rowstart",
    (char*)"ncol",
    (char*)"nrow",
    (char*)"region",
    (char*)"bound",
    (char*)"segment",
    (char*)"point",
    (char*)"cnet",
    (char*)"CameraID"
};

_CORBA_TypeCode _OB_TC__OBE_C_CBREP =
{
    CORBA_tk_struct,
    (char*)"IDL:CBREP:1.0",
    (char*)"CBREP",
    17,
    _OB_TC__OBE_C_CBREP__OB_tc_member_names,
    _OB_TC__OBE_C_CBREP__OB_tc_member_types,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_CBREP(&_OB_TC__OBE_C_CBREP);

//
// IDL:CBREPSeq:1.0
//

static _CORBA_TypeCode _OB_TC_0__OBE_C_CBREPSeq =
{
    CORBA_tk_sequence,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC__OBE_C_CBREP,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC__OBE_C_CBREPSeq =
{
    CORBA_tk_alias,
    (char*)"IDL:CBREPSeq:1.0",
    (char*)"CBREPSeq",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_0__OBE_C_CBREPSeq,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_CBREPSeq(&_OB_TC__OBE_C_CBREPSeq);

CORBA::TypeCode_ptr _tc_CBREP_Point = &_OBE_TC_CBREP_Point;

CORBA::TypeCode_ptr _tc_CBREP_PointSeq = &_OBE_TC_CBREP_PointSeq;

CORBA::TypeCode_ptr _tc_CBREP_Segment = &_OBE_TC_CBREP_Segment;

CORBA::TypeCode_ptr _tc_CBREP_SegmentSeq = &_OBE_TC_CBREP_SegmentSeq;

CORBA::TypeCode_ptr _tc_CBREP_Bound = &_OBE_TC_CBREP_Bound;

CORBA::TypeCode_ptr _tc_CBREP_BoundSeq = &_OBE_TC_CBREP_BoundSeq;

CORBA::TypeCode_ptr _tc_CBREP_Cnet = &_OBE_TC_CBREP_Cnet;

CORBA::TypeCode_ptr _tc_CBREP_CnetSeq = &_OBE_TC_CBREP_CnetSeq;

CORBA::TypeCode_ptr _tc_CBREP_Region = &_OBE_TC_CBREP_Region;

CORBA::TypeCode_ptr _tc_CBREP_RegionSeq = &_OBE_TC_CBREP_RegionSeq;

CORBA::TypeCode_ptr _tc_CBREP = &_OBE_TC_CBREP;

CORBA::TypeCode_ptr _tc_CBREPSeq = &_OBE_TC_CBREPSeq;

//
// IDL:CBREP_Point:1.0
//
void
CBREP_Point::_OB_marshal(
    OBEC_OutputStreamImpl* _ob_out,
    CORBA_Environment* _ob_cev
) const
{
    OBEC_OutputStreamImpl_write_long(_ob_out, label, _ob_cev);
    OBEC_OutputStreamImpl_write_long(_ob_out, n, _ob_cev);
    OBEC_OutputStreamImpl_write_long(_ob_out, row, _ob_cev);
    OBEC_OutputStreamImpl_write_long(_ob_out, col, _ob_cev);
    OBEC_OutputStreamImpl_write_float(_ob_out, rowd, _ob_cev);
    OBEC_OutputStreamImpl_write_float(_ob_out, cold, _ob_cev);
    OBEC_OutputStreamImpl_write_float(_ob_out, Xr, _ob_cev);
    OBEC_OutputStreamImpl_write_float(_ob_out, Yr, _ob_cev);
    OBEC_OutputStreamImpl_write_float(_ob_out, x, _ob_cev);
    OBEC_OutputStreamImpl_write_float(_ob_out, y, _ob_cev);
    OBEC_OutputStreamImpl_write_float(_ob_out, z, _ob_cev);
    OBEC_OutputStreamImpl_write_float(_ob_out, normals, _ob_cev);
    OBEC_OutputStreamImpl_write_float_array(_ob_out, (const CORBA::Float*)Normal, 3, _ob_cev);
    OBEC_OutputStreamImpl_write_float_array(_ob_out, (const CORBA::Float*)Tangent, 3, _ob_cev);
    OBEC_OutputStreamImpl_write_float(_ob_out, curvature, _ob_cev);
    OBEC_OutputStreamImpl_write_float(_ob_out, error, _ob_cev);
    OBEC_OutputStreamImpl_write_octet(_ob_out, red, _ob_cev);
    OBEC_OutputStreamImpl_write_octet(_ob_out, green, _ob_cev);
    OBEC_OutputStreamImpl_write_octet(_ob_out, blue, _ob_cev);
}

void
CBREP_Point::_OB_unmarshal(
    CBREP_Point& _ob_v,
    OBEC_InputStreamImpl* _ob_in,
    CORBA_Environment* _ob_cev
)
{
    _ob_v.label = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    _ob_v.n = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    _ob_v.row = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    _ob_v.col = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    _ob_v.rowd = OBEC_InputStreamImpl_read_float(_ob_in, _ob_cev);
    _ob_v.cold = OBEC_InputStreamImpl_read_float(_ob_in, _ob_cev);
    _ob_v.Xr = OBEC_InputStreamImpl_read_float(_ob_in, _ob_cev);
    _ob_v.Yr = OBEC_InputStreamImpl_read_float(_ob_in, _ob_cev);
    _ob_v.x = OBEC_InputStreamImpl_read_float(_ob_in, _ob_cev);
    _ob_v.y = OBEC_InputStreamImpl_read_float(_ob_in, _ob_cev);
    _ob_v.z = OBEC_InputStreamImpl_read_float(_ob_in, _ob_cev);
    _ob_v.normals = OBEC_InputStreamImpl_read_float(_ob_in, _ob_cev);
    OBEC_InputStreamImpl_read_float_array(_ob_in, (CORBA::Float*)_ob_v.Normal, 3, _ob_cev);
    OBEC_InputStreamImpl_read_float_array(_ob_in, (CORBA::Float*)_ob_v.Tangent, 3, _ob_cev);
    _ob_v.curvature = OBEC_InputStreamImpl_read_float(_ob_in, _ob_cev);
    _ob_v.error = OBEC_InputStreamImpl_read_float(_ob_in, _ob_cev);
    _ob_v.red = OBEC_InputStreamImpl_read_octet(_ob_in, _ob_cev);
    _ob_v.green = OBEC_InputStreamImpl_read_octet(_ob_in, _ob_cev);
    _ob_v.blue = OBEC_InputStreamImpl_read_octet(_ob_in, _ob_cev);
}

void
CBREP_Point::_OB_convert_to(
    void* _ob_data
) const
{
    _OBE_C_CBREP_Point* _ob_p = (_OBE_C_CBREP_Point*)_ob_data;
    _ob_p->label = label;
    _ob_p->n = n;
    _ob_p->row = row;
    _ob_p->col = col;
    _ob_p->rowd = rowd;
    _ob_p->cold = cold;
    _ob_p->Xr = Xr;
    _ob_p->Yr = Yr;
    _ob_p->x = x;
    _ob_p->y = y;
    _ob_p->z = z;
    _ob_p->normals = normals;
    memcpy(_ob_p->Normal, Normal, sizeof(CORBA_float) * 3);
    memcpy(_ob_p->Tangent, Tangent, sizeof(CORBA_float) * 3);
    _ob_p->curvature = curvature;
    _ob_p->error = error;
    _ob_p->red = red;
    _ob_p->green = green;
    _ob_p->blue = blue;
}

void
CBREP_Point::_OB_convert_from(
    CBREP_Point& _ob_v,
    void* _ob_data
)
{
    _OBE_C_CBREP_Point* _ob_p = (_OBE_C_CBREP_Point*)_ob_data;
    _ob_v.label = _ob_p->label;
    _ob_v.n = _ob_p->n;
    _ob_v.row = _ob_p->row;
    _ob_v.col = _ob_p->col;
    _ob_v.rowd = _ob_p->rowd;
    _ob_v.cold = _ob_p->cold;
    _ob_v.Xr = _ob_p->Xr;
    _ob_v.Yr = _ob_p->Yr;
    _ob_v.x = _ob_p->x;
    _ob_v.y = _ob_p->y;
    _ob_v.z = _ob_p->z;
    _ob_v.normals = _ob_p->normals;
    memcpy(_ob_v.Normal, _ob_p->Normal, sizeof(CORBA_float) * 3);
    memcpy(_ob_v.Tangent, _ob_p->Tangent, sizeof(CORBA_float) * 3);
    _ob_v.curvature = _ob_p->curvature;
    _ob_v.error = _ob_p->error;
    _ob_v.red = _ob_p->red;
    _ob_v.green = _ob_p->green;
    _ob_v.blue = _ob_p->blue;
}

static CORBA::AnyContentDestroyerDelete<CBREP_Point> OBAnyContentDestroyerInstance_CBREP_Point;

void
operator<<=(CORBA::Any& any, CBREP_Point* v)
{
    _OBE_C_CBREP_Point* p = (_OBE_C_CBREP_Point*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_CBREP_Point->_OB_impl_nodup(), sizeof(_OBE_C_CBREP_Point));
    (*v)._OB_convert_to(&(*p));
    any.replace(_tc_CBREP_Point, p, false, v, &OBAnyContentDestroyerInstance_CBREP_Point);
}

void
operator<<=(CORBA::Any& any, const CBREP_Point& v)
{
    _OBE_C_CBREP_Point* p = (_OBE_C_CBREP_Point*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_CBREP_Point->_OB_impl_nodup(), sizeof(_OBE_C_CBREP_Point));
    v._OB_convert_to(&(*p));
    any.replace(_tc_CBREP_Point, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CBREP_Point*& v)
{
    if (!any.check_type(_tc_CBREP_Point))
        return 0;

    v = (const CBREP_Point*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_CBREP_Point* p = (_OBE_C_CBREP_Point*)any.value();
        assert(p != NULL);
        CBREP_Point* val = new CBREP_Point;
        CBREP_Point::_OB_convert_from((*val), &(*p));
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_CBREP_Point);
        v = val;
    }

    return 1;
}

//
// IDL:CBREP_PointSeq:1.0
//
static CORBA::AnyContentDestroyerDelete<CBREP_PointSeq> OBAnyContentDestroyerInstance_CBREP_PointSeq;

void
operator<<=(CORBA::Any& any, CBREP_PointSeq* v)
{
    _OBE_C_CORBA_sequence__OBE_C_CBREP_Point* p = (_OBE_C_CORBA_sequence__OBE_C_CBREP_Point*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_CBREP_PointSeq->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence__OBE_C_CBREP_Point));
    (*p)._length = (*v).length();
    (*p)._maximum = (*v).length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (_OBE_C_CBREP_Point*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_CBREP_Point) * (*p)._length, (*p)._length, OBEC_FALSE);

    memcpy((*p)._buffer, (*v).get_buffer(), sizeof(_OBE_C_CBREP_Point) * (*p)._length);
    any.replace(_tc_CBREP_PointSeq, p, false, v, &OBAnyContentDestroyerInstance_CBREP_PointSeq);
}

void
operator<<=(CORBA::Any& any, const CBREP_PointSeq& v)
{
    _OBE_C_CORBA_sequence__OBE_C_CBREP_Point* p = (_OBE_C_CORBA_sequence__OBE_C_CBREP_Point*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_CBREP_PointSeq->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence__OBE_C_CBREP_Point));
    (*p)._length = v.length();
    (*p)._maximum = v.length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (_OBE_C_CBREP_Point*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_CBREP_Point) * (*p)._length, (*p)._length, OBEC_FALSE);

    memcpy((*p)._buffer, v.get_buffer(), sizeof(_OBE_C_CBREP_Point) * (*p)._length);
    any.replace(_tc_CBREP_PointSeq, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CBREP_PointSeq*& v)
{
    if (!any.check_type(_tc_CBREP_PointSeq))
        return false;

    v = (const CBREP_PointSeq*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_CORBA_sequence__OBE_C_CBREP_Point* p = (_OBE_C_CORBA_sequence__OBE_C_CBREP_Point*)any.value();
        assert(p != NULL);
        CBREP_PointSeq* val = new CBREP_PointSeq;
        (*val).length((*p)._length);

        memcpy((*val).get_buffer(), (*p)._buffer, sizeof(_OBE_C_CBREP_Point) * (*p)._length);
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_CBREP_PointSeq);
        v = val;
    }

    return true;
}

//
// IDL:CBREP_Segment:1.0
//
#ifdef OB_PURIFY_CLEAN
CBREP_Segment::CBREP_Segment()
{
    memset(&label, 0, sizeof(label));
    memset(&n, 0, sizeof(n));
    memset(&npoint, 0, sizeof(npoint));
    memset(&curvature, 0, sizeof(curvature));
    memset(&error, 0, sizeof(error));
    memset(&intensity_sigma, 0, sizeof(intensity_sigma));
    memset(&red, 0, sizeof(red));
    memset(&green, 0, sizeof(green));
    memset(&blue, 0, sizeof(blue));
}
#endif

CBREP_Segment::CBREP_Segment(const CBREP_Segment& _ob_a)
    : label(_ob_a.label),
      n(_ob_a.n),
      npoint(_ob_a.npoint),
      curvature(_ob_a.curvature),
      error(_ob_a.error),
      intensity_sigma(_ob_a.intensity_sigma),
      point(_ob_a.point),
      red(_ob_a.red),
      green(_ob_a.green),
      blue(_ob_a.blue)
{
}

CBREP_Segment&
CBREP_Segment::operator=(const CBREP_Segment& _ob_a)
{
    if(this != &_ob_a)
    {
        label = _ob_a.label;
        n = _ob_a.n;
        npoint = _ob_a.npoint;
        curvature = _ob_a.curvature;
        error = _ob_a.error;
        intensity_sigma = _ob_a.intensity_sigma;
        point = _ob_a.point;
        red = _ob_a.red;
        green = _ob_a.green;
        blue = _ob_a.blue;
    }
    return *this;
}

void
CBREP_Segment::_OB_marshal(
    OBEC_OutputStreamImpl* _ob_out,
    CORBA_Environment* _ob_cev
) const
{
    OBEC_OutputStreamImpl_write_long(_ob_out, label, _ob_cev);
    OBEC_OutputStreamImpl_write_long(_ob_out, n, _ob_cev);
    OBEC_OutputStreamImpl_write_long(_ob_out, npoint, _ob_cev);
    OBEC_OutputStreamImpl_write_float(_ob_out, curvature, _ob_cev);
    OBEC_OutputStreamImpl_write_float(_ob_out, error, _ob_cev);
    OBEC_OutputStreamImpl_write_float(_ob_out, intensity_sigma, _ob_cev);
    CORBA::ULong _ob_len0 = point.length();
    OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len0, _ob_cev);
    ::CBREP_Point const * _ob_buf0 = point.get_buffer();
    for(CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
    {
        _ob_buf0[_ob_i0]._OB_marshal(_ob_out, _ob_cev);
    }
    OBEC_OutputStreamImpl_write_octet(_ob_out, red, _ob_cev);
    OBEC_OutputStreamImpl_write_octet(_ob_out, green, _ob_cev);
    OBEC_OutputStreamImpl_write_octet(_ob_out, blue, _ob_cev);
}

void
CBREP_Segment::_OB_unmarshal(
    CBREP_Segment& _ob_v,
    OBEC_InputStreamImpl* _ob_in,
    CORBA_Environment* _ob_cev
)
{
    _ob_v.label = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    _ob_v.n = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    _ob_v.npoint = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    _ob_v.curvature = OBEC_InputStreamImpl_read_float(_ob_in, _ob_cev);
    _ob_v.error = OBEC_InputStreamImpl_read_float(_ob_in, _ob_cev);
    _ob_v.intensity_sigma = OBEC_InputStreamImpl_read_float(_ob_in, _ob_cev);
    CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.point.length(_ob_len0);
    ::CBREP_Point * _ob_buf0 = _ob_v.point.get_buffer();
    for(CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
    {
        ::CBREP_Point::_OB_unmarshal(_ob_buf0[_ob_i0], _ob_in, _ob_cev);
    }
    _ob_v.red = OBEC_InputStreamImpl_read_octet(_ob_in, _ob_cev);
    _ob_v.green = OBEC_InputStreamImpl_read_octet(_ob_in, _ob_cev);
    _ob_v.blue = OBEC_InputStreamImpl_read_octet(_ob_in, _ob_cev);
}

void
CBREP_Segment::_OB_convert_to(
    void* _ob_data
) const
{
    _OBE_C_CBREP_Segment* _ob_p = (_OBE_C_CBREP_Segment*)_ob_data;
    _ob_p->label = label;
    _ob_p->n = n;
    _ob_p->npoint = npoint;
    _ob_p->curvature = curvature;
    _ob_p->error = error;
    _ob_p->intensity_sigma = intensity_sigma;
    _ob_p->point._length = point.length();
    _ob_p->point._maximum = point.length();
    _ob_p->point._release = OBEC_TRUE;
    _ob_p->point._buffer = (_OBE_C_CBREP_Point*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_CBREP_Point) * _ob_p->point._length, _ob_p->point._length, OBEC_FALSE);

    memcpy(_ob_p->point._buffer, point.get_buffer(), sizeof(_OBE_C_CBREP_Point) * _ob_p->point._length);
    _ob_p->red = red;
    _ob_p->green = green;
    _ob_p->blue = blue;
}

void
CBREP_Segment::_OB_convert_from(
    CBREP_Segment& _ob_v,
    void* _ob_data
)
{
    _OBE_C_CBREP_Segment* _ob_p = (_OBE_C_CBREP_Segment*)_ob_data;
    _ob_v.label = _ob_p->label;
    _ob_v.n = _ob_p->n;
    _ob_v.npoint = _ob_p->npoint;
    _ob_v.curvature = _ob_p->curvature;
    _ob_v.error = _ob_p->error;
    _ob_v.intensity_sigma = _ob_p->intensity_sigma;
    _ob_v.point.length(_ob_p->point._length);

    memcpy(_ob_v.point.get_buffer(), _ob_p->point._buffer, sizeof(_OBE_C_CBREP_Point) * _ob_p->point._length);
    _ob_v.red = _ob_p->red;
    _ob_v.green = _ob_p->green;
    _ob_v.blue = _ob_p->blue;
}

static CORBA::AnyContentDestroyerDelete<CBREP_Segment> OBAnyContentDestroyerInstance_CBREP_Segment;

void
operator<<=(CORBA::Any& any, CBREP_Segment* v)
{
    _OBE_C_CBREP_Segment* p = (_OBE_C_CBREP_Segment*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_CBREP_Segment->_OB_impl_nodup(), sizeof(_OBE_C_CBREP_Segment));
    (*v)._OB_convert_to(&(*p));
    any.replace(_tc_CBREP_Segment, p, false, v, &OBAnyContentDestroyerInstance_CBREP_Segment);
}

void
operator<<=(CORBA::Any& any, const CBREP_Segment& v)
{
    _OBE_C_CBREP_Segment* p = (_OBE_C_CBREP_Segment*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_CBREP_Segment->_OB_impl_nodup(), sizeof(_OBE_C_CBREP_Segment));
    v._OB_convert_to(&(*p));
    any.replace(_tc_CBREP_Segment, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CBREP_Segment*& v)
{
    if (!any.check_type(_tc_CBREP_Segment))
        return 0;

    v = (const CBREP_Segment*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_CBREP_Segment* p = (_OBE_C_CBREP_Segment*)any.value();
        assert(p != NULL);
        CBREP_Segment* val = new CBREP_Segment;
        CBREP_Segment::_OB_convert_from((*val), &(*p));
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_CBREP_Segment);
        v = val;
    }

    return 1;
}

//
// IDL:CBREP_SegmentSeq:1.0
//
static CORBA::AnyContentDestroyerDelete<CBREP_SegmentSeq> OBAnyContentDestroyerInstance_CBREP_SegmentSeq;

void
operator<<=(CORBA::Any& any, CBREP_SegmentSeq* v)
{
    _OBE_C_CORBA_sequence__OBE_C_CBREP_Segment* p = (_OBE_C_CORBA_sequence__OBE_C_CBREP_Segment*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_CBREP_SegmentSeq->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence__OBE_C_CBREP_Segment));
    (*p)._length = (*v).length();
    (*p)._maximum = (*v).length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (_OBE_C_CBREP_Segment*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_CBREP_Segment) * (*p)._length, (*p)._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
    {
        (*v)[_ob_i0]._OB_convert_to(&(*p)._buffer[_ob_i0]);
    }
    any.replace(_tc_CBREP_SegmentSeq, p, false, v, &OBAnyContentDestroyerInstance_CBREP_SegmentSeq);
}

void
operator<<=(CORBA::Any& any, const CBREP_SegmentSeq& v)
{
    _OBE_C_CORBA_sequence__OBE_C_CBREP_Segment* p = (_OBE_C_CORBA_sequence__OBE_C_CBREP_Segment*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_CBREP_SegmentSeq->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence__OBE_C_CBREP_Segment));
    (*p)._length = v.length();
    (*p)._maximum = v.length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (_OBE_C_CBREP_Segment*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_CBREP_Segment) * (*p)._length, (*p)._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
    {
        v[_ob_i0]._OB_convert_to(&(*p)._buffer[_ob_i0]);
    }
    any.replace(_tc_CBREP_SegmentSeq, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CBREP_SegmentSeq*& v)
{
    if (!any.check_type(_tc_CBREP_SegmentSeq))
        return false;

    v = (const CBREP_SegmentSeq*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_CORBA_sequence__OBE_C_CBREP_Segment* p = (_OBE_C_CORBA_sequence__OBE_C_CBREP_Segment*)any.value();
        assert(p != NULL);
        CBREP_SegmentSeq* val = new CBREP_SegmentSeq;
        (*val).length((*p)._length);

        for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
        {
            CBREP_Segment::_OB_convert_from((*val)[_ob_i0], &(*p)._buffer[_ob_i0]);
        }
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_CBREP_SegmentSeq);
        v = val;
    }

    return true;
}

//
// IDL:CBREP_Bound:1.0
//
#ifdef OB_PURIFY_CLEAN
CBREP_Bound::CBREP_Bound()
{
    memset(&label, 0, sizeof(label));
    memset(&n, 0, sizeof(n));
    memset(&nsegment, 0, sizeof(nsegment));
    memset(&npoint, 0, sizeof(npoint));
}
#endif

CBREP_Bound::CBREP_Bound(const CBREP_Bound& _ob_a)
    : label(_ob_a.label),
      n(_ob_a.n),
      nsegment(_ob_a.nsegment),
      npoint(_ob_a.npoint),
      segment(_ob_a.segment),
      point(_ob_a.point)
{
}

CBREP_Bound&
CBREP_Bound::operator=(const CBREP_Bound& _ob_a)
{
    if(this != &_ob_a)
    {
        label = _ob_a.label;
        n = _ob_a.n;
        nsegment = _ob_a.nsegment;
        npoint = _ob_a.npoint;
        segment = _ob_a.segment;
        point = _ob_a.point;
    }
    return *this;
}

void
CBREP_Bound::_OB_marshal(
    OBEC_OutputStreamImpl* _ob_out,
    CORBA_Environment* _ob_cev
) const
{
    OBEC_OutputStreamImpl_write_long(_ob_out, label, _ob_cev);
    OBEC_OutputStreamImpl_write_long(_ob_out, n, _ob_cev);
    OBEC_OutputStreamImpl_write_long(_ob_out, nsegment, _ob_cev);
    OBEC_OutputStreamImpl_write_long(_ob_out, npoint, _ob_cev);
    CORBA::ULong _ob_len0 = segment.length();
    OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len0, _ob_cev);
    ::CBREP_Segment const * _ob_buf0 = segment.get_buffer();
    for(CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
    {
        _ob_buf0[_ob_i0]._OB_marshal(_ob_out, _ob_cev);
    }
    CORBA::ULong _ob_len1 = point.length();
    OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len1, _ob_cev);
    ::CBREP_Point const * _ob_buf1 = point.get_buffer();
    for(CORBA::ULong _ob_i1 = 0 ; _ob_i1 < _ob_len1 ; _ob_i1++)
    {
        _ob_buf1[_ob_i1]._OB_marshal(_ob_out, _ob_cev);
    }
}

void
CBREP_Bound::_OB_unmarshal(
    CBREP_Bound& _ob_v,
    OBEC_InputStreamImpl* _ob_in,
    CORBA_Environment* _ob_cev
)
{
    _ob_v.label = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    _ob_v.n = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    _ob_v.nsegment = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    _ob_v.npoint = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.segment.length(_ob_len0);
    ::CBREP_Segment * _ob_buf0 = _ob_v.segment.get_buffer();
    for(CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
    {
        ::CBREP_Segment::_OB_unmarshal(_ob_buf0[_ob_i0], _ob_in, _ob_cev);
    }
    CORBA::ULong _ob_len1 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.point.length(_ob_len1);
    ::CBREP_Point * _ob_buf1 = _ob_v.point.get_buffer();
    for(CORBA::ULong _ob_i1 = 0 ; _ob_i1 < _ob_len1 ; _ob_i1++)
    {
        ::CBREP_Point::_OB_unmarshal(_ob_buf1[_ob_i1], _ob_in, _ob_cev);
    }
}

void
CBREP_Bound::_OB_convert_to(
    void* _ob_data
) const
{
    _OBE_C_CBREP_Bound* _ob_p = (_OBE_C_CBREP_Bound*)_ob_data;
    _ob_p->label = label;
    _ob_p->n = n;
    _ob_p->nsegment = nsegment;
    _ob_p->npoint = npoint;
    _ob_p->segment._length = segment.length();
    _ob_p->segment._maximum = segment.length();
    _ob_p->segment._release = OBEC_TRUE;
    _ob_p->segment._buffer = (_OBE_C_CBREP_Segment*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_CBREP_Segment) * _ob_p->segment._length, _ob_p->segment._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i4 = 0; _ob_i4 < _ob_p->segment._length; _ob_i4++)
    {
        segment[_ob_i4]._OB_convert_to(&_ob_p->segment._buffer[_ob_i4]);
    }
    _ob_p->point._length = point.length();
    _ob_p->point._maximum = point.length();
    _ob_p->point._release = OBEC_TRUE;
    _ob_p->point._buffer = (_OBE_C_CBREP_Point*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_CBREP_Point) * _ob_p->point._length, _ob_p->point._length, OBEC_FALSE);

    memcpy(_ob_p->point._buffer, point.get_buffer(), sizeof(_OBE_C_CBREP_Point) * _ob_p->point._length);
}

void
CBREP_Bound::_OB_convert_from(
    CBREP_Bound& _ob_v,
    void* _ob_data
)
{
    _OBE_C_CBREP_Bound* _ob_p = (_OBE_C_CBREP_Bound*)_ob_data;
    _ob_v.label = _ob_p->label;
    _ob_v.n = _ob_p->n;
    _ob_v.nsegment = _ob_p->nsegment;
    _ob_v.npoint = _ob_p->npoint;
    _ob_v.segment.length(_ob_p->segment._length);

    for (CORBA::ULong _ob_i4 = 0; _ob_i4 < _ob_p->segment._length; _ob_i4++)
    {
        CBREP_Segment::_OB_convert_from(_ob_v.segment[_ob_i4], &_ob_p->segment._buffer[_ob_i4]);
    }
    _ob_v.point.length(_ob_p->point._length);

    memcpy(_ob_v.point.get_buffer(), _ob_p->point._buffer, sizeof(_OBE_C_CBREP_Point) * _ob_p->point._length);
}

static CORBA::AnyContentDestroyerDelete<CBREP_Bound> OBAnyContentDestroyerInstance_CBREP_Bound;

void
operator<<=(CORBA::Any& any, CBREP_Bound* v)
{
    _OBE_C_CBREP_Bound* p = (_OBE_C_CBREP_Bound*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_CBREP_Bound->_OB_impl_nodup(), sizeof(_OBE_C_CBREP_Bound));
    (*v)._OB_convert_to(&(*p));
    any.replace(_tc_CBREP_Bound, p, false, v, &OBAnyContentDestroyerInstance_CBREP_Bound);
}

void
operator<<=(CORBA::Any& any, const CBREP_Bound& v)
{
    _OBE_C_CBREP_Bound* p = (_OBE_C_CBREP_Bound*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_CBREP_Bound->_OB_impl_nodup(), sizeof(_OBE_C_CBREP_Bound));
    v._OB_convert_to(&(*p));
    any.replace(_tc_CBREP_Bound, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CBREP_Bound*& v)
{
    if (!any.check_type(_tc_CBREP_Bound))
        return 0;

    v = (const CBREP_Bound*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_CBREP_Bound* p = (_OBE_C_CBREP_Bound*)any.value();
        assert(p != NULL);
        CBREP_Bound* val = new CBREP_Bound;
        CBREP_Bound::_OB_convert_from((*val), &(*p));
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_CBREP_Bound);
        v = val;
    }

    return 1;
}

//
// IDL:CBREP_BoundSeq:1.0
//
static CORBA::AnyContentDestroyerDelete<CBREP_BoundSeq> OBAnyContentDestroyerInstance_CBREP_BoundSeq;

void
operator<<=(CORBA::Any& any, CBREP_BoundSeq* v)
{
    _OBE_C_CORBA_sequence__OBE_C_CBREP_Bound* p = (_OBE_C_CORBA_sequence__OBE_C_CBREP_Bound*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_CBREP_BoundSeq->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence__OBE_C_CBREP_Bound));
    (*p)._length = (*v).length();
    (*p)._maximum = (*v).length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (_OBE_C_CBREP_Bound*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_CBREP_Bound) * (*p)._length, (*p)._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
    {
        (*v)[_ob_i0]._OB_convert_to(&(*p)._buffer[_ob_i0]);
    }
    any.replace(_tc_CBREP_BoundSeq, p, false, v, &OBAnyContentDestroyerInstance_CBREP_BoundSeq);
}

void
operator<<=(CORBA::Any& any, const CBREP_BoundSeq& v)
{
    _OBE_C_CORBA_sequence__OBE_C_CBREP_Bound* p = (_OBE_C_CORBA_sequence__OBE_C_CBREP_Bound*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_CBREP_BoundSeq->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence__OBE_C_CBREP_Bound));
    (*p)._length = v.length();
    (*p)._maximum = v.length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (_OBE_C_CBREP_Bound*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_CBREP_Bound) * (*p)._length, (*p)._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
    {
        v[_ob_i0]._OB_convert_to(&(*p)._buffer[_ob_i0]);
    }
    any.replace(_tc_CBREP_BoundSeq, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CBREP_BoundSeq*& v)
{
    if (!any.check_type(_tc_CBREP_BoundSeq))
        return false;

    v = (const CBREP_BoundSeq*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_CORBA_sequence__OBE_C_CBREP_Bound* p = (_OBE_C_CORBA_sequence__OBE_C_CBREP_Bound*)any.value();
        assert(p != NULL);
        CBREP_BoundSeq* val = new CBREP_BoundSeq;
        (*val).length((*p)._length);

        for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
        {
            CBREP_Bound::_OB_convert_from((*val)[_ob_i0], &(*p)._buffer[_ob_i0]);
        }
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_CBREP_BoundSeq);
        v = val;
    }

    return true;
}

//
// IDL:CBREP_Cnet:1.0
//
void
CBREP_Cnet::_OB_marshal(
    OBEC_OutputStreamImpl* _ob_out,
    CORBA_Environment* _ob_cev
) const
{
    OBEC_OutputStreamImpl_write_long(_ob_out, label, _ob_cev);
    OBEC_OutputStreamImpl_write_long(_ob_out, n, _ob_cev);
    OBEC_OutputStreamImpl_write_long(_ob_out, mapcol, _ob_cev);
    OBEC_OutputStreamImpl_write_long(_ob_out, maprow, _ob_cev);
    OBEC_OutputStreamImpl_write_float_array(_ob_out, (const CORBA::Float*)Position, 3, _ob_cev);
    OBEC_OutputStreamImpl_write_float_array(_ob_out, (const CORBA::Float*)Normal, 3, _ob_cev);
    OBEC_OutputStreamImpl_write_octet(_ob_out, red, _ob_cev);
    OBEC_OutputStreamImpl_write_octet(_ob_out, green, _ob_cev);
    OBEC_OutputStreamImpl_write_octet(_ob_out, blue, _ob_cev);
}

void
CBREP_Cnet::_OB_unmarshal(
    CBREP_Cnet& _ob_v,
    OBEC_InputStreamImpl* _ob_in,
    CORBA_Environment* _ob_cev
)
{
    _ob_v.label = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    _ob_v.n = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    _ob_v.mapcol = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    _ob_v.maprow = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    OBEC_InputStreamImpl_read_float_array(_ob_in, (CORBA::Float*)_ob_v.Position, 3, _ob_cev);
    OBEC_InputStreamImpl_read_float_array(_ob_in, (CORBA::Float*)_ob_v.Normal, 3, _ob_cev);
    _ob_v.red = OBEC_InputStreamImpl_read_octet(_ob_in, _ob_cev);
    _ob_v.green = OBEC_InputStreamImpl_read_octet(_ob_in, _ob_cev);
    _ob_v.blue = OBEC_InputStreamImpl_read_octet(_ob_in, _ob_cev);
}

void
CBREP_Cnet::_OB_convert_to(
    void* _ob_data
) const
{
    _OBE_C_CBREP_Cnet* _ob_p = (_OBE_C_CBREP_Cnet*)_ob_data;
    _ob_p->label = label;
    _ob_p->n = n;
    _ob_p->mapcol = mapcol;
    _ob_p->maprow = maprow;
    memcpy(_ob_p->Position, Position, sizeof(CORBA_float) * 3);
    memcpy(_ob_p->Normal, Normal, sizeof(CORBA_float) * 3);
    _ob_p->red = red;
    _ob_p->green = green;
    _ob_p->blue = blue;
}

void
CBREP_Cnet::_OB_convert_from(
    CBREP_Cnet& _ob_v,
    void* _ob_data
)
{
    _OBE_C_CBREP_Cnet* _ob_p = (_OBE_C_CBREP_Cnet*)_ob_data;
    _ob_v.label = _ob_p->label;
    _ob_v.n = _ob_p->n;
    _ob_v.mapcol = _ob_p->mapcol;
    _ob_v.maprow = _ob_p->maprow;
    memcpy(_ob_v.Position, _ob_p->Position, sizeof(CORBA_float) * 3);
    memcpy(_ob_v.Normal, _ob_p->Normal, sizeof(CORBA_float) * 3);
    _ob_v.red = _ob_p->red;
    _ob_v.green = _ob_p->green;
    _ob_v.blue = _ob_p->blue;
}

static CORBA::AnyContentDestroyerDelete<CBREP_Cnet> OBAnyContentDestroyerInstance_CBREP_Cnet;

void
operator<<=(CORBA::Any& any, CBREP_Cnet* v)
{
    _OBE_C_CBREP_Cnet* p = (_OBE_C_CBREP_Cnet*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_CBREP_Cnet->_OB_impl_nodup(), sizeof(_OBE_C_CBREP_Cnet));
    (*v)._OB_convert_to(&(*p));
    any.replace(_tc_CBREP_Cnet, p, false, v, &OBAnyContentDestroyerInstance_CBREP_Cnet);
}

void
operator<<=(CORBA::Any& any, const CBREP_Cnet& v)
{
    _OBE_C_CBREP_Cnet* p = (_OBE_C_CBREP_Cnet*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_CBREP_Cnet->_OB_impl_nodup(), sizeof(_OBE_C_CBREP_Cnet));
    v._OB_convert_to(&(*p));
    any.replace(_tc_CBREP_Cnet, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CBREP_Cnet*& v)
{
    if (!any.check_type(_tc_CBREP_Cnet))
        return 0;

    v = (const CBREP_Cnet*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_CBREP_Cnet* p = (_OBE_C_CBREP_Cnet*)any.value();
        assert(p != NULL);
        CBREP_Cnet* val = new CBREP_Cnet;
        CBREP_Cnet::_OB_convert_from((*val), &(*p));
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_CBREP_Cnet);
        v = val;
    }

    return 1;
}

//
// IDL:CBREP_CnetSeq:1.0
//
static CORBA::AnyContentDestroyerDelete<CBREP_CnetSeq> OBAnyContentDestroyerInstance_CBREP_CnetSeq;

void
operator<<=(CORBA::Any& any, CBREP_CnetSeq* v)
{
    _OBE_C_CORBA_sequence__OBE_C_CBREP_Cnet* p = (_OBE_C_CORBA_sequence__OBE_C_CBREP_Cnet*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_CBREP_CnetSeq->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence__OBE_C_CBREP_Cnet));
    (*p)._length = (*v).length();
    (*p)._maximum = (*v).length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (_OBE_C_CBREP_Cnet*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_CBREP_Cnet) * (*p)._length, (*p)._length, OBEC_FALSE);

    memcpy((*p)._buffer, (*v).get_buffer(), sizeof(_OBE_C_CBREP_Cnet) * (*p)._length);
    any.replace(_tc_CBREP_CnetSeq, p, false, v, &OBAnyContentDestroyerInstance_CBREP_CnetSeq);
}

void
operator<<=(CORBA::Any& any, const CBREP_CnetSeq& v)
{
    _OBE_C_CORBA_sequence__OBE_C_CBREP_Cnet* p = (_OBE_C_CORBA_sequence__OBE_C_CBREP_Cnet*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_CBREP_CnetSeq->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence__OBE_C_CBREP_Cnet));
    (*p)._length = v.length();
    (*p)._maximum = v.length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (_OBE_C_CBREP_Cnet*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_CBREP_Cnet) * (*p)._length, (*p)._length, OBEC_FALSE);

    memcpy((*p)._buffer, v.get_buffer(), sizeof(_OBE_C_CBREP_Cnet) * (*p)._length);
    any.replace(_tc_CBREP_CnetSeq, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CBREP_CnetSeq*& v)
{
    if (!any.check_type(_tc_CBREP_CnetSeq))
        return false;

    v = (const CBREP_CnetSeq*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_CORBA_sequence__OBE_C_CBREP_Cnet* p = (_OBE_C_CORBA_sequence__OBE_C_CBREP_Cnet*)any.value();
        assert(p != NULL);
        CBREP_CnetSeq* val = new CBREP_CnetSeq;
        (*val).length((*p)._length);

        memcpy((*val).get_buffer(), (*p)._buffer, sizeof(_OBE_C_CBREP_Cnet) * (*p)._length);
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_CBREP_CnetSeq);
        v = val;
    }

    return true;
}

//
// IDL:CBREP_Region:1.0
//
#ifdef OB_PURIFY_CLEAN
CBREP_Region::CBREP_Region()
{
    memset(&label, 0, sizeof(label));
    memset(&n, 0, sizeof(n));
    memset(&nbound, 0, sizeof(nbound));
    memset(&nsegment, 0, sizeof(nsegment));
    memset(&npoint, 0, sizeof(npoint));
    memset(&ncnet, 0, sizeof(ncnet));
    memset(&area, 0, sizeof(area));
    memset(&width, 0, sizeof(width));
    memset(&type, 0, sizeof(type));
    memset(&intensity, 0, sizeof(intensity));
    memset(&std_deviation, 0, sizeof(std_deviation));
}
#endif

CBREP_Region::CBREP_Region(const CBREP_Region& _ob_a)
    : label(_ob_a.label),
      n(_ob_a.n),
      nbound(_ob_a.nbound),
      nsegment(_ob_a.nsegment),
      npoint(_ob_a.npoint),
      ncnet(_ob_a.ncnet),
      area(_ob_a.area),
      width(_ob_a.width),
      type(_ob_a.type),
      intensity(_ob_a.intensity),
      std_deviation(_ob_a.std_deviation),
      bound(_ob_a.bound),
      segment(_ob_a.segment),
      point(_ob_a.point),
      cnet(_ob_a.cnet)
{
}

CBREP_Region&
CBREP_Region::operator=(const CBREP_Region& _ob_a)
{
    if(this != &_ob_a)
    {
        label = _ob_a.label;
        n = _ob_a.n;
        nbound = _ob_a.nbound;
        nsegment = _ob_a.nsegment;
        npoint = _ob_a.npoint;
        ncnet = _ob_a.ncnet;
        area = _ob_a.area;
        width = _ob_a.width;
        type = _ob_a.type;
        intensity = _ob_a.intensity;
        std_deviation = _ob_a.std_deviation;
        bound = _ob_a.bound;
        segment = _ob_a.segment;
        point = _ob_a.point;
        cnet = _ob_a.cnet;
    }
    return *this;
}

void
CBREP_Region::_OB_marshal(
    OBEC_OutputStreamImpl* _ob_out,
    CORBA_Environment* _ob_cev
) const
{
    OBEC_OutputStreamImpl_write_long(_ob_out, label, _ob_cev);
    OBEC_OutputStreamImpl_write_long(_ob_out, n, _ob_cev);
    OBEC_OutputStreamImpl_write_long(_ob_out, nbound, _ob_cev);
    OBEC_OutputStreamImpl_write_long(_ob_out, nsegment, _ob_cev);
    OBEC_OutputStreamImpl_write_long(_ob_out, npoint, _ob_cev);
    OBEC_OutputStreamImpl_write_long(_ob_out, ncnet, _ob_cev);
    OBEC_OutputStreamImpl_write_long(_ob_out, area, _ob_cev);
    OBEC_OutputStreamImpl_write_long(_ob_out, width, _ob_cev);
    OBEC_OutputStreamImpl_write_long(_ob_out, type, _ob_cev);
    OBEC_OutputStreamImpl_write_float(_ob_out, intensity, _ob_cev);
    OBEC_OutputStreamImpl_write_float(_ob_out, std_deviation, _ob_cev);
    CORBA::ULong _ob_len0 = bound.length();
    OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len0, _ob_cev);
    ::CBREP_Bound const * _ob_buf0 = bound.get_buffer();
    for(CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
    {
        _ob_buf0[_ob_i0]._OB_marshal(_ob_out, _ob_cev);
    }
    CORBA::ULong _ob_len1 = segment.length();
    OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len1, _ob_cev);
    ::CBREP_Segment const * _ob_buf1 = segment.get_buffer();
    for(CORBA::ULong _ob_i1 = 0 ; _ob_i1 < _ob_len1 ; _ob_i1++)
    {
        _ob_buf1[_ob_i1]._OB_marshal(_ob_out, _ob_cev);
    }
    CORBA::ULong _ob_len2 = point.length();
    OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len2, _ob_cev);
    ::CBREP_Point const * _ob_buf2 = point.get_buffer();
    for(CORBA::ULong _ob_i2 = 0 ; _ob_i2 < _ob_len2 ; _ob_i2++)
    {
        _ob_buf2[_ob_i2]._OB_marshal(_ob_out, _ob_cev);
    }
    CORBA::ULong _ob_len3 = cnet.length();
    OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len3, _ob_cev);
    ::CBREP_Cnet const * _ob_buf3 = cnet.get_buffer();
    for(CORBA::ULong _ob_i3 = 0 ; _ob_i3 < _ob_len3 ; _ob_i3++)
    {
        _ob_buf3[_ob_i3]._OB_marshal(_ob_out, _ob_cev);
    }
}

void
CBREP_Region::_OB_unmarshal(
    CBREP_Region& _ob_v,
    OBEC_InputStreamImpl* _ob_in,
    CORBA_Environment* _ob_cev
)
{
    _ob_v.label = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    _ob_v.n = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    _ob_v.nbound = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    _ob_v.nsegment = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    _ob_v.npoint = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    _ob_v.ncnet = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    _ob_v.area = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    _ob_v.width = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    _ob_v.type = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    _ob_v.intensity = OBEC_InputStreamImpl_read_float(_ob_in, _ob_cev);
    _ob_v.std_deviation = OBEC_InputStreamImpl_read_float(_ob_in, _ob_cev);
    CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.bound.length(_ob_len0);
    ::CBREP_Bound * _ob_buf0 = _ob_v.bound.get_buffer();
    for(CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
    {
        ::CBREP_Bound::_OB_unmarshal(_ob_buf0[_ob_i0], _ob_in, _ob_cev);
    }
    CORBA::ULong _ob_len1 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.segment.length(_ob_len1);
    ::CBREP_Segment * _ob_buf1 = _ob_v.segment.get_buffer();
    for(CORBA::ULong _ob_i1 = 0 ; _ob_i1 < _ob_len1 ; _ob_i1++)
    {
        ::CBREP_Segment::_OB_unmarshal(_ob_buf1[_ob_i1], _ob_in, _ob_cev);
    }
    CORBA::ULong _ob_len2 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.point.length(_ob_len2);
    ::CBREP_Point * _ob_buf2 = _ob_v.point.get_buffer();
    for(CORBA::ULong _ob_i2 = 0 ; _ob_i2 < _ob_len2 ; _ob_i2++)
    {
        ::CBREP_Point::_OB_unmarshal(_ob_buf2[_ob_i2], _ob_in, _ob_cev);
    }
    CORBA::ULong _ob_len3 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.cnet.length(_ob_len3);
    ::CBREP_Cnet * _ob_buf3 = _ob_v.cnet.get_buffer();
    for(CORBA::ULong _ob_i3 = 0 ; _ob_i3 < _ob_len3 ; _ob_i3++)
    {
        ::CBREP_Cnet::_OB_unmarshal(_ob_buf3[_ob_i3], _ob_in, _ob_cev);
    }
}

void
CBREP_Region::_OB_convert_to(
    void* _ob_data
) const
{
    _OBE_C_CBREP_Region* _ob_p = (_OBE_C_CBREP_Region*)_ob_data;
    _ob_p->label = label;
    _ob_p->n = n;
    _ob_p->nbound = nbound;
    _ob_p->nsegment = nsegment;
    _ob_p->npoint = npoint;
    _ob_p->ncnet = ncnet;
    _ob_p->area = area;
    _ob_p->width = width;
    _ob_p->type = type;
    _ob_p->intensity = intensity;
    _ob_p->std_deviation = std_deviation;
    _ob_p->bound._length = bound.length();
    _ob_p->bound._maximum = bound.length();
    _ob_p->bound._release = OBEC_TRUE;
    _ob_p->bound._buffer = (_OBE_C_CBREP_Bound*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_CBREP_Bound) * _ob_p->bound._length, _ob_p->bound._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i11 = 0; _ob_i11 < _ob_p->bound._length; _ob_i11++)
    {
        bound[_ob_i11]._OB_convert_to(&_ob_p->bound._buffer[_ob_i11]);
    }
    _ob_p->segment._length = segment.length();
    _ob_p->segment._maximum = segment.length();
    _ob_p->segment._release = OBEC_TRUE;
    _ob_p->segment._buffer = (_OBE_C_CBREP_Segment*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_CBREP_Segment) * _ob_p->segment._length, _ob_p->segment._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i13 = 0; _ob_i13 < _ob_p->segment._length; _ob_i13++)
    {
        segment[_ob_i13]._OB_convert_to(&_ob_p->segment._buffer[_ob_i13]);
    }
    _ob_p->point._length = point.length();
    _ob_p->point._maximum = point.length();
    _ob_p->point._release = OBEC_TRUE;
    _ob_p->point._buffer = (_OBE_C_CBREP_Point*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_CBREP_Point) * _ob_p->point._length, _ob_p->point._length, OBEC_FALSE);

    memcpy(_ob_p->point._buffer, point.get_buffer(), sizeof(_OBE_C_CBREP_Point) * _ob_p->point._length);
    _ob_p->cnet._length = cnet.length();
    _ob_p->cnet._maximum = cnet.length();
    _ob_p->cnet._release = OBEC_TRUE;
    _ob_p->cnet._buffer = (_OBE_C_CBREP_Cnet*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_CBREP_Cnet) * _ob_p->cnet._length, _ob_p->cnet._length, OBEC_FALSE);

    memcpy(_ob_p->cnet._buffer, cnet.get_buffer(), sizeof(_OBE_C_CBREP_Cnet) * _ob_p->cnet._length);
}

void
CBREP_Region::_OB_convert_from(
    CBREP_Region& _ob_v,
    void* _ob_data
)
{
    _OBE_C_CBREP_Region* _ob_p = (_OBE_C_CBREP_Region*)_ob_data;
    _ob_v.label = _ob_p->label;
    _ob_v.n = _ob_p->n;
    _ob_v.nbound = _ob_p->nbound;
    _ob_v.nsegment = _ob_p->nsegment;
    _ob_v.npoint = _ob_p->npoint;
    _ob_v.ncnet = _ob_p->ncnet;
    _ob_v.area = _ob_p->area;
    _ob_v.width = _ob_p->width;
    _ob_v.type = _ob_p->type;
    _ob_v.intensity = _ob_p->intensity;
    _ob_v.std_deviation = _ob_p->std_deviation;
    _ob_v.bound.length(_ob_p->bound._length);

    for (CORBA::ULong _ob_i11 = 0; _ob_i11 < _ob_p->bound._length; _ob_i11++)
    {
        CBREP_Bound::_OB_convert_from(_ob_v.bound[_ob_i11], &_ob_p->bound._buffer[_ob_i11]);
    }
    _ob_v.segment.length(_ob_p->segment._length);

    for (CORBA::ULong _ob_i13 = 0; _ob_i13 < _ob_p->segment._length; _ob_i13++)
    {
        CBREP_Segment::_OB_convert_from(_ob_v.segment[_ob_i13], &_ob_p->segment._buffer[_ob_i13]);
    }
    _ob_v.point.length(_ob_p->point._length);

    memcpy(_ob_v.point.get_buffer(), _ob_p->point._buffer, sizeof(_OBE_C_CBREP_Point) * _ob_p->point._length);
    _ob_v.cnet.length(_ob_p->cnet._length);

    memcpy(_ob_v.cnet.get_buffer(), _ob_p->cnet._buffer, sizeof(_OBE_C_CBREP_Cnet) * _ob_p->cnet._length);
}

static CORBA::AnyContentDestroyerDelete<CBREP_Region> OBAnyContentDestroyerInstance_CBREP_Region;

void
operator<<=(CORBA::Any& any, CBREP_Region* v)
{
    _OBE_C_CBREP_Region* p = (_OBE_C_CBREP_Region*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_CBREP_Region->_OB_impl_nodup(), sizeof(_OBE_C_CBREP_Region));
    (*v)._OB_convert_to(&(*p));
    any.replace(_tc_CBREP_Region, p, false, v, &OBAnyContentDestroyerInstance_CBREP_Region);
}

void
operator<<=(CORBA::Any& any, const CBREP_Region& v)
{
    _OBE_C_CBREP_Region* p = (_OBE_C_CBREP_Region*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_CBREP_Region->_OB_impl_nodup(), sizeof(_OBE_C_CBREP_Region));
    v._OB_convert_to(&(*p));
    any.replace(_tc_CBREP_Region, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CBREP_Region*& v)
{
    if (!any.check_type(_tc_CBREP_Region))
        return 0;

    v = (const CBREP_Region*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_CBREP_Region* p = (_OBE_C_CBREP_Region*)any.value();
        assert(p != NULL);
        CBREP_Region* val = new CBREP_Region;
        CBREP_Region::_OB_convert_from((*val), &(*p));
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_CBREP_Region);
        v = val;
    }

    return 1;
}

//
// IDL:CBREP_RegionSeq:1.0
//
static CORBA::AnyContentDestroyerDelete<CBREP_RegionSeq> OBAnyContentDestroyerInstance_CBREP_RegionSeq;

void
operator<<=(CORBA::Any& any, CBREP_RegionSeq* v)
{
    _OBE_C_CORBA_sequence__OBE_C_CBREP_Region* p = (_OBE_C_CORBA_sequence__OBE_C_CBREP_Region*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_CBREP_RegionSeq->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence__OBE_C_CBREP_Region));
    (*p)._length = (*v).length();
    (*p)._maximum = (*v).length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (_OBE_C_CBREP_Region*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_CBREP_Region) * (*p)._length, (*p)._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
    {
        (*v)[_ob_i0]._OB_convert_to(&(*p)._buffer[_ob_i0]);
    }
    any.replace(_tc_CBREP_RegionSeq, p, false, v, &OBAnyContentDestroyerInstance_CBREP_RegionSeq);
}

void
operator<<=(CORBA::Any& any, const CBREP_RegionSeq& v)
{
    _OBE_C_CORBA_sequence__OBE_C_CBREP_Region* p = (_OBE_C_CORBA_sequence__OBE_C_CBREP_Region*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_CBREP_RegionSeq->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence__OBE_C_CBREP_Region));
    (*p)._length = v.length();
    (*p)._maximum = v.length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (_OBE_C_CBREP_Region*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_CBREP_Region) * (*p)._length, (*p)._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
    {
        v[_ob_i0]._OB_convert_to(&(*p)._buffer[_ob_i0]);
    }
    any.replace(_tc_CBREP_RegionSeq, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CBREP_RegionSeq*& v)
{
    if (!any.check_type(_tc_CBREP_RegionSeq))
        return false;

    v = (const CBREP_RegionSeq*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_CORBA_sequence__OBE_C_CBREP_Region* p = (_OBE_C_CORBA_sequence__OBE_C_CBREP_Region*)any.value();
        assert(p != NULL);
        CBREP_RegionSeq* val = new CBREP_RegionSeq;
        (*val).length((*p)._length);

        for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
        {
            CBREP_Region::_OB_convert_from((*val)[_ob_i0], &(*p)._buffer[_ob_i0]);
        }
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_CBREP_RegionSeq);
        v = val;
    }

    return true;
}

//
// IDL:CBREP:1.0
//
#ifdef OB_PURIFY_CLEAN
CBREP::CBREP()
{
    memset(&label, 0, sizeof(label));
    memset(&n, 0, sizeof(n));
    memset(&nregion, 0, sizeof(nregion));
    memset(&nbound, 0, sizeof(nbound));
    memset(&nsegment, 0, sizeof(nsegment));
    memset(&npoint, 0, sizeof(npoint));
    memset(&ncnet, 0, sizeof(ncnet));
    memset(&colstart, 0, sizeof(colstart));
    memset(&rowstart, 0, sizeof(rowstart));
    memset(&ncol, 0, sizeof(ncol));
    memset(&nrow, 0, sizeof(nrow));
    memset(&CameraID, 0, sizeof(CameraID));
}
#endif

CBREP::CBREP(const CBREP& _ob_a)
    : label(_ob_a.label),
      n(_ob_a.n),
      nregion(_ob_a.nregion),
      nbound(_ob_a.nbound),
      nsegment(_ob_a.nsegment),
      npoint(_ob_a.npoint),
      ncnet(_ob_a.ncnet),
      colstart(_ob_a.colstart),
      rowstart(_ob_a.rowstart),
      ncol(_ob_a.ncol),
      nrow(_ob_a.nrow),
      region(_ob_a.region),
      bound(_ob_a.bound),
      segment(_ob_a.segment),
      point(_ob_a.point),
      cnet(_ob_a.cnet),
      CameraID(_ob_a.CameraID)
{
}

CBREP&
CBREP::operator=(const CBREP& _ob_a)
{
    if(this != &_ob_a)
    {
        label = _ob_a.label;
        n = _ob_a.n;
        nregion = _ob_a.nregion;
        nbound = _ob_a.nbound;
        nsegment = _ob_a.nsegment;
        npoint = _ob_a.npoint;
        ncnet = _ob_a.ncnet;
        colstart = _ob_a.colstart;
        rowstart = _ob_a.rowstart;
        ncol = _ob_a.ncol;
        nrow = _ob_a.nrow;
        region = _ob_a.region;
        bound = _ob_a.bound;
        segment = _ob_a.segment;
        point = _ob_a.point;
        cnet = _ob_a.cnet;
        CameraID = _ob_a.CameraID;
    }
    return *this;
}

void
CBREP::_OB_marshal(
    OBEC_OutputStreamImpl* _ob_out,
    CORBA_Environment* _ob_cev
) const
{
    OBEC_OutputStreamImpl_write_long(_ob_out, label, _ob_cev);
    OBEC_OutputStreamImpl_write_long(_ob_out, n, _ob_cev);
    OBEC_OutputStreamImpl_write_long(_ob_out, nregion, _ob_cev);
    OBEC_OutputStreamImpl_write_long(_ob_out, nbound, _ob_cev);
    OBEC_OutputStreamImpl_write_long(_ob_out, nsegment, _ob_cev);
    OBEC_OutputStreamImpl_write_long(_ob_out, npoint, _ob_cev);
    OBEC_OutputStreamImpl_write_long(_ob_out, ncnet, _ob_cev);
    OBEC_OutputStreamImpl_write_long(_ob_out, colstart, _ob_cev);
    OBEC_OutputStreamImpl_write_long(_ob_out, rowstart, _ob_cev);
    OBEC_OutputStreamImpl_write_long(_ob_out, ncol, _ob_cev);
    OBEC_OutputStreamImpl_write_long(_ob_out, nrow, _ob_cev);
    CORBA::ULong _ob_len0 = region.length();
    OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len0, _ob_cev);
    ::CBREP_Region const * _ob_buf0 = region.get_buffer();
    for(CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
    {
        _ob_buf0[_ob_i0]._OB_marshal(_ob_out, _ob_cev);
    }
    CORBA::ULong _ob_len1 = bound.length();
    OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len1, _ob_cev);
    ::CBREP_Bound const * _ob_buf1 = bound.get_buffer();
    for(CORBA::ULong _ob_i1 = 0 ; _ob_i1 < _ob_len1 ; _ob_i1++)
    {
        _ob_buf1[_ob_i1]._OB_marshal(_ob_out, _ob_cev);
    }
    CORBA::ULong _ob_len2 = segment.length();
    OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len2, _ob_cev);
    ::CBREP_Segment const * _ob_buf2 = segment.get_buffer();
    for(CORBA::ULong _ob_i2 = 0 ; _ob_i2 < _ob_len2 ; _ob_i2++)
    {
        _ob_buf2[_ob_i2]._OB_marshal(_ob_out, _ob_cev);
    }
    CORBA::ULong _ob_len3 = point.length();
    OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len3, _ob_cev);
    ::CBREP_Point const * _ob_buf3 = point.get_buffer();
    for(CORBA::ULong _ob_i3 = 0 ; _ob_i3 < _ob_len3 ; _ob_i3++)
    {
        _ob_buf3[_ob_i3]._OB_marshal(_ob_out, _ob_cev);
    }
    CORBA::ULong _ob_len4 = cnet.length();
    OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len4, _ob_cev);
    ::CBREP_Cnet const * _ob_buf4 = cnet.get_buffer();
    for(CORBA::ULong _ob_i4 = 0 ; _ob_i4 < _ob_len4 ; _ob_i4++)
    {
        _ob_buf4[_ob_i4]._OB_marshal(_ob_out, _ob_cev);
    }
    OBEC_OutputStreamImpl_write_long(_ob_out, CameraID, _ob_cev);
}

void
CBREP::_OB_unmarshal(
    CBREP& _ob_v,
    OBEC_InputStreamImpl* _ob_in,
    CORBA_Environment* _ob_cev
)
{
    _ob_v.label = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    _ob_v.n = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    _ob_v.nregion = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    _ob_v.nbound = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    _ob_v.nsegment = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    _ob_v.npoint = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    _ob_v.ncnet = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    _ob_v.colstart = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    _ob_v.rowstart = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    _ob_v.ncol = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    _ob_v.nrow = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.region.length(_ob_len0);
    ::CBREP_Region * _ob_buf0 = _ob_v.region.get_buffer();
    for(CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
    {
        ::CBREP_Region::_OB_unmarshal(_ob_buf0[_ob_i0], _ob_in, _ob_cev);
    }
    CORBA::ULong _ob_len1 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.bound.length(_ob_len1);
    ::CBREP_Bound * _ob_buf1 = _ob_v.bound.get_buffer();
    for(CORBA::ULong _ob_i1 = 0 ; _ob_i1 < _ob_len1 ; _ob_i1++)
    {
        ::CBREP_Bound::_OB_unmarshal(_ob_buf1[_ob_i1], _ob_in, _ob_cev);
    }
    CORBA::ULong _ob_len2 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.segment.length(_ob_len2);
    ::CBREP_Segment * _ob_buf2 = _ob_v.segment.get_buffer();
    for(CORBA::ULong _ob_i2 = 0 ; _ob_i2 < _ob_len2 ; _ob_i2++)
    {
        ::CBREP_Segment::_OB_unmarshal(_ob_buf2[_ob_i2], _ob_in, _ob_cev);
    }
    CORBA::ULong _ob_len3 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.point.length(_ob_len3);
    ::CBREP_Point * _ob_buf3 = _ob_v.point.get_buffer();
    for(CORBA::ULong _ob_i3 = 0 ; _ob_i3 < _ob_len3 ; _ob_i3++)
    {
        ::CBREP_Point::_OB_unmarshal(_ob_buf3[_ob_i3], _ob_in, _ob_cev);
    }
    CORBA::ULong _ob_len4 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.cnet.length(_ob_len4);
    ::CBREP_Cnet * _ob_buf4 = _ob_v.cnet.get_buffer();
    for(CORBA::ULong _ob_i4 = 0 ; _ob_i4 < _ob_len4 ; _ob_i4++)
    {
        ::CBREP_Cnet::_OB_unmarshal(_ob_buf4[_ob_i4], _ob_in, _ob_cev);
    }
    _ob_v.CameraID = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
}

void
CBREP::_OB_convert_to(
    void* _ob_data
) const
{
    _OBE_C_CBREP* _ob_p = (_OBE_C_CBREP*)_ob_data;
    _ob_p->label = label;
    _ob_p->n = n;
    _ob_p->nregion = nregion;
    _ob_p->nbound = nbound;
    _ob_p->nsegment = nsegment;
    _ob_p->npoint = npoint;
    _ob_p->ncnet = ncnet;
    _ob_p->colstart = colstart;
    _ob_p->rowstart = rowstart;
    _ob_p->ncol = ncol;
    _ob_p->nrow = nrow;
    _ob_p->region._length = region.length();
    _ob_p->region._maximum = region.length();
    _ob_p->region._release = OBEC_TRUE;
    _ob_p->region._buffer = (_OBE_C_CBREP_Region*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_CBREP_Region) * _ob_p->region._length, _ob_p->region._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i11 = 0; _ob_i11 < _ob_p->region._length; _ob_i11++)
    {
        region[_ob_i11]._OB_convert_to(&_ob_p->region._buffer[_ob_i11]);
    }
    _ob_p->bound._length = bound.length();
    _ob_p->bound._maximum = bound.length();
    _ob_p->bound._release = OBEC_TRUE;
    _ob_p->bound._buffer = (_OBE_C_CBREP_Bound*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_CBREP_Bound) * _ob_p->bound._length, _ob_p->bound._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i13 = 0; _ob_i13 < _ob_p->bound._length; _ob_i13++)
    {
        bound[_ob_i13]._OB_convert_to(&_ob_p->bound._buffer[_ob_i13]);
    }
    _ob_p->segment._length = segment.length();
    _ob_p->segment._maximum = segment.length();
    _ob_p->segment._release = OBEC_TRUE;
    _ob_p->segment._buffer = (_OBE_C_CBREP_Segment*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_CBREP_Segment) * _ob_p->segment._length, _ob_p->segment._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i15 = 0; _ob_i15 < _ob_p->segment._length; _ob_i15++)
    {
        segment[_ob_i15]._OB_convert_to(&_ob_p->segment._buffer[_ob_i15]);
    }
    _ob_p->point._length = point.length();
    _ob_p->point._maximum = point.length();
    _ob_p->point._release = OBEC_TRUE;
    _ob_p->point._buffer = (_OBE_C_CBREP_Point*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_CBREP_Point) * _ob_p->point._length, _ob_p->point._length, OBEC_FALSE);

    memcpy(_ob_p->point._buffer, point.get_buffer(), sizeof(_OBE_C_CBREP_Point) * _ob_p->point._length);
    _ob_p->cnet._length = cnet.length();
    _ob_p->cnet._maximum = cnet.length();
    _ob_p->cnet._release = OBEC_TRUE;
    _ob_p->cnet._buffer = (_OBE_C_CBREP_Cnet*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_CBREP_Cnet) * _ob_p->cnet._length, _ob_p->cnet._length, OBEC_FALSE);

    memcpy(_ob_p->cnet._buffer, cnet.get_buffer(), sizeof(_OBE_C_CBREP_Cnet) * _ob_p->cnet._length);
    _ob_p->CameraID = CameraID;
}

void
CBREP::_OB_convert_from(
    CBREP& _ob_v,
    void* _ob_data
)
{
    _OBE_C_CBREP* _ob_p = (_OBE_C_CBREP*)_ob_data;
    _ob_v.label = _ob_p->label;
    _ob_v.n = _ob_p->n;
    _ob_v.nregion = _ob_p->nregion;
    _ob_v.nbound = _ob_p->nbound;
    _ob_v.nsegment = _ob_p->nsegment;
    _ob_v.npoint = _ob_p->npoint;
    _ob_v.ncnet = _ob_p->ncnet;
    _ob_v.colstart = _ob_p->colstart;
    _ob_v.rowstart = _ob_p->rowstart;
    _ob_v.ncol = _ob_p->ncol;
    _ob_v.nrow = _ob_p->nrow;
    _ob_v.region.length(_ob_p->region._length);

    for (CORBA::ULong _ob_i11 = 0; _ob_i11 < _ob_p->region._length; _ob_i11++)
    {
        CBREP_Region::_OB_convert_from(_ob_v.region[_ob_i11], &_ob_p->region._buffer[_ob_i11]);
    }
    _ob_v.bound.length(_ob_p->bound._length);

    for (CORBA::ULong _ob_i13 = 0; _ob_i13 < _ob_p->bound._length; _ob_i13++)
    {
        CBREP_Bound::_OB_convert_from(_ob_v.bound[_ob_i13], &_ob_p->bound._buffer[_ob_i13]);
    }
    _ob_v.segment.length(_ob_p->segment._length);

    for (CORBA::ULong _ob_i15 = 0; _ob_i15 < _ob_p->segment._length; _ob_i15++)
    {
        CBREP_Segment::_OB_convert_from(_ob_v.segment[_ob_i15], &_ob_p->segment._buffer[_ob_i15]);
    }
    _ob_v.point.length(_ob_p->point._length);

    memcpy(_ob_v.point.get_buffer(), _ob_p->point._buffer, sizeof(_OBE_C_CBREP_Point) * _ob_p->point._length);
    _ob_v.cnet.length(_ob_p->cnet._length);

    memcpy(_ob_v.cnet.get_buffer(), _ob_p->cnet._buffer, sizeof(_OBE_C_CBREP_Cnet) * _ob_p->cnet._length);
    _ob_v.CameraID = _ob_p->CameraID;
}

static CORBA::AnyContentDestroyerDelete<CBREP> OBAnyContentDestroyerInstance_CBREP;

void
operator<<=(CORBA::Any& any, CBREP* v)
{
    _OBE_C_CBREP* p = (_OBE_C_CBREP*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_CBREP->_OB_impl_nodup(), sizeof(_OBE_C_CBREP));
    (*v)._OB_convert_to(&(*p));
    any.replace(_tc_CBREP, p, false, v, &OBAnyContentDestroyerInstance_CBREP);
}

void
operator<<=(CORBA::Any& any, const CBREP& v)
{
    _OBE_C_CBREP* p = (_OBE_C_CBREP*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_CBREP->_OB_impl_nodup(), sizeof(_OBE_C_CBREP));
    v._OB_convert_to(&(*p));
    any.replace(_tc_CBREP, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CBREP*& v)
{
    if (!any.check_type(_tc_CBREP))
        return 0;

    v = (const CBREP*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_CBREP* p = (_OBE_C_CBREP*)any.value();
        assert(p != NULL);
        CBREP* val = new CBREP;
        CBREP::_OB_convert_from((*val), &(*p));
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_CBREP);
        v = val;
    }

    return 1;
}

//
// IDL:CBREPSeq:1.0
//
static CORBA::AnyContentDestroyerDelete<CBREPSeq> OBAnyContentDestroyerInstance_CBREPSeq;

void
operator<<=(CORBA::Any& any, CBREPSeq* v)
{
    _OBE_C_CORBA_sequence__OBE_C_CBREP* p = (_OBE_C_CORBA_sequence__OBE_C_CBREP*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_CBREPSeq->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence__OBE_C_CBREP));
    (*p)._length = (*v).length();
    (*p)._maximum = (*v).length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (_OBE_C_CBREP*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_CBREP) * (*p)._length, (*p)._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
    {
        (*v)[_ob_i0]._OB_convert_to(&(*p)._buffer[_ob_i0]);
    }
    any.replace(_tc_CBREPSeq, p, false, v, &OBAnyContentDestroyerInstance_CBREPSeq);
}

void
operator<<=(CORBA::Any& any, const CBREPSeq& v)
{
    _OBE_C_CORBA_sequence__OBE_C_CBREP* p = (_OBE_C_CORBA_sequence__OBE_C_CBREP*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_CBREPSeq->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence__OBE_C_CBREP));
    (*p)._length = v.length();
    (*p)._maximum = v.length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (_OBE_C_CBREP*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_CBREP) * (*p)._length, (*p)._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
    {
        v[_ob_i0]._OB_convert_to(&(*p)._buffer[_ob_i0]);
    }
    any.replace(_tc_CBREPSeq, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CBREPSeq*& v)
{
    if (!any.check_type(_tc_CBREPSeq))
        return false;

    v = (const CBREPSeq*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_CORBA_sequence__OBE_C_CBREP* p = (_OBE_C_CORBA_sequence__OBE_C_CBREP*)any.value();
        assert(p != NULL);
        CBREPSeq* val = new CBREPSeq;
        (*val).length((*p)._length);

        for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
        {
            CBREP::_OB_convert_from((*val)[_ob_i0], &(*p)._buffer[_ob_i0]);
        }
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_CBREPSeq);
        v = val;
    }

    return true;
}
