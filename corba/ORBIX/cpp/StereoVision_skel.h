// **********************************************************************
//
// Generated by the Orbix/E IDL-to-C++ Translator
//
// Copyright (c) 2003
// IONA Technologies, Inc.
// Waltham, MA, USA
//
// All Rights Reserved
//
// **********************************************************************

// Version: 2.2.0

#ifndef ___StereoVision_skel_h__
#define ___StereoVision_skel_h__

#include <StereoVision.h>

#include <common_skel.h>
#include <visionsensor_skel.h>

#ifndef OBEC_INTEGER_VERSION
#   error No Orbix/E version defined! Is <OBE/CORBA.h> included?
#endif

#ifndef OBEC_NO_VERSION_CHECK
#   if (OBEC_INTEGER_VERSION != 2020000L)
#       error Orbix/E version mismatch!
#   endif
#endif

//
// IDL:StereoVision:1.0
//
class POA_StereoVision : virtual public PortableServer::ServantBase
{
    POA_StereoVision(const POA_StereoVision&);
    void operator=(const POA_StereoVision&);

protected:

    //
    // IDL:StereoVision/rbt2scmCalibStart:1.0
    //
    void
    _OB_op_rbt2scmCalibStart(
        OBEC_UpcallImpl* _ob_up,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:StereoVision/rbt2scmCalibEnd:1.0
    //
    void
    _OB_op_rbt2scmCalibEnd(
        OBEC_UpcallImpl* _ob_up,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:StereoVision/detectCrossMark:1.0
    //
    void
    _OB_op_detectCrossMark(
        OBEC_UpcallImpl* _ob_up,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:StereoVision/getObjectPosition:1.0
    //
    void
    _OB_op_getObjectPosition(
        OBEC_UpcallImpl* _ob_up,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:StereoVision/StartProcess:1.0
    //
    void
    _OB_op_StartProcess(
        OBEC_UpcallImpl* _ob_up,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:StereoVision/StopProcess:1.0
    //
    void
    _OB_op_StopProcess(
        OBEC_UpcallImpl* _ob_up,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:StereoVision/getImage:1.0
    //
    void
    _OB_op_getImage(
        OBEC_UpcallImpl* _ob_up,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:StereoVision/getRangeMap:1.0
    //
    void
    _OB_op_getRangeMap(
        OBEC_UpcallImpl* _ob_up,
        CORBA_Environment* _ob_cev
    );

public:

    POA_StereoVision() { }

    virtual CORBA::Boolean
    _is_a(
        const char* _ob_repid
    ) throw(CORBA::SystemException);

    virtual CORBA::RepositoryId
    _primary_interface(
        const PortableServer::ObjectId& _ob_oid,
        PortableServer::POA_ptr _ob_poa
    );

    ::StereoVision_ptr
    _this(
    );

    virtual void
    _OB_dispatch(
        OBEC_UpcallImpl* _ob_up,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:StereoVision/rbt2scmCalibStart:1.0
    //
    virtual CORBA::Boolean rbt2scmCalibStart(
    ) throw(CORBA::SystemException) = 0;

    //
    // IDL:StereoVision/rbt2scmCalibEnd:1.0
    //
    virtual CORBA::Boolean rbt2scmCalibEnd(
    ) throw(CORBA::SystemException) = 0;

    //
    // IDL:StereoVision/detectCrossMark:1.0
    //
    virtual CORBA::Boolean detectCrossMark(
        const TransformQuaternion& robotHeadPos,
        const TransformQuaternion& robotHandPos
    ) throw(CORBA::SystemException) = 0;

    //
    // IDL:StereoVision/getObjectPosition:1.0
    //
    virtual CORBA::Boolean getObjectPosition(
        const char* name,
        const TransformQuaternion& robotHeadPos,
        TransformQuaternion_out ObjectPosition
    ) throw(CORBA::SystemException) = 0;

    //
    // IDL:StereoVision/StartProcess:1.0
    //
    virtual CORBA::Boolean StartProcess(
        const char* ProcessName
    ) throw(CORBA::SystemException) = 0;

    //
    // IDL:StereoVision/StopProcess:1.0
    //
    virtual CORBA::Boolean StopProcess(
        const char* ProcessName
    ) throw(CORBA::SystemException) = 0;

    //
    // IDL:StereoVision/getImage:1.0
    //
    virtual CORBA::Long getImage(
        CORBA::Long CameraID,
        ImageData_out anImage,
        char*& Format
    ) throw(CORBA::SystemException) = 0;

    //
    // IDL:StereoVision/getRangeMap:1.0
    //
    virtual CORBA::Long getRangeMap(
        RangeMap_out aRangeMap,
        char*& Format
    ) throw(CORBA::SystemException) = 0;
};

#endif
