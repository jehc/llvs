// **********************************************************************
//
// Generated by the Orbix/E IDL-to-C++ Translator
//
// Copyright (c) 2003
// IONA Technologies, Inc.
// Waltham, MA, USA
//
// All Rights Reserved
//
// **********************************************************************

// Version: 2.2.0

#include <OBE/CORBAClient.h>
#include <common.h>

#ifndef OBEC_INTEGER_VERSION
#   error No Orbix/E version defined! Is <OBE/CORBA.h> included?
#endif

#ifndef OBEC_NO_VERSION_CHECK
#   if (OBEC_INTEGER_VERSION != 2020000L)
#       error Orbix/E version mismatch!
#   endif
#endif

extern "C"
{

typedef CORBA_Object _OBE_C_SensorInfo;

typedef CORBA_Object _OBE_C_ParserModelObject;

typedef CORBA_Object _OBE_C_ParserCharObject;

typedef CORBA_Object _OBE_C_ModelInfo;

typedef CORBA_Object _OBE_C_OpenHRPObject;

typedef CORBA_Object _OBE_C_CommandReceiver;

typedef CORBA_Object _OBE_C_Plugin;

typedef CORBA_Object _OBE_C_PluginManager;

#ifndef __OBE_C_CORBA_sequence_double_defined
#define __OBE_C_CORBA_sequence_double_defined
typedef struct
{
    CORBA_unsigned_long _maximum;
    CORBA_unsigned_long _length;
    CORBA_double* _buffer;
    CORBA_boolean _release;
} _OBE_C_CORBA_sequence_double;
#endif

typedef _OBE_C_CORBA_sequence_double _OBE_C_TorqueSeq;

typedef CORBA_unsigned_long _OBE_C_DataId;

#define _OBE_C_ANGLE 0
#define _OBE_C_VELOCITY 1
#define _OBE_C_ACCELERATION 2

typedef CORBA_double _OBE_C_LinkData[3];
typedef CORBA_double _OBE_C_LinkData_slice;

#ifndef __OBE_C_CORBA_sequence__OBE_C_LinkData_defined
#define __OBE_C_CORBA_sequence__OBE_C_LinkData_defined
typedef struct
{
    CORBA_unsigned_long _maximum;
    CORBA_unsigned_long _length;
    _OBE_C_LinkData* _buffer;
    CORBA_boolean _release;
} _OBE_C_CORBA_sequence__OBE_C_LinkData;
#endif

typedef _OBE_C_CORBA_sequence__OBE_C_LinkData _OBE_C_LinkDataSeq;

typedef _OBE_C_CORBA_sequence_double _OBE_C_Value;

typedef _OBE_C_CORBA_sequence_double _OBE_C_FSValue;

#ifndef __OBE_C_CORBA_sequence_string_defined
#define __OBE_C_CORBA_sequence_string_defined
typedef struct
{
    CORBA_unsigned_long _maximum;
    CORBA_unsigned_long _length;
    CORBA_char** _buffer;
    CORBA_boolean _release;
} _OBE_C_CORBA_sequence_string;
#endif

typedef _OBE_C_CORBA_sequence_string _OBE_C_LinkNameSeq;

typedef struct _OBE_C_Transform _OBE_C_Transform;

struct _OBE_C_Transform
{
    CORBA_float posX;
    CORBA_float posY;
    CORBA_float posZ;
    CORBA_float axisX;
    CORBA_float axisY;
    CORBA_float axisZ;
    CORBA_float angle;
};

typedef struct _OBE_C_TransformQuaternion _OBE_C_TransformQuaternion;

struct _OBE_C_TransformQuaternion
{
    CORBA_float px;
    CORBA_float py;
    CORBA_float pz;
    CORBA_float qx;
    CORBA_float qy;
    CORBA_float qz;
    CORBA_float qw;
};

typedef struct _OBE_C_LinkInfo _OBE_C_LinkInfo;

struct _OBE_C_LinkInfo
{
    CORBA_char* name;
    _OBE_C_Value pos;
    _OBE_C_Value rot;
    CORBA_double JointValue;
    CORBA_double JointVel;
    CORBA_double JointAcc;
    _OBE_C_Value jpos;
    _OBE_C_Value jatt;
    _OBE_C_Value vel;
    _OBE_C_Value acc;
};

typedef struct _OBE_C_LinkValue _OBE_C_LinkValue;

struct _OBE_C_LinkValue
{
    CORBA_char* name;
    CORBA_char* param;
    _OBE_C_Value data;
};

#ifndef __OBE_C_CORBA_sequence__OBE_C_LinkValue_defined
#define __OBE_C_CORBA_sequence__OBE_C_LinkValue_defined
typedef struct
{
    CORBA_unsigned_long _maximum;
    CORBA_unsigned_long _length;
    _OBE_C_LinkValue* _buffer;
    CORBA_boolean _release;
} _OBE_C_CORBA_sequence__OBE_C_LinkValue;
#endif

typedef _OBE_C_CORBA_sequence__OBE_C_LinkValue _OBE_C_LinkValueSeq;

#ifndef __OBE_C_CORBA_sequence__OBE_C_LinkInfo_defined
#define __OBE_C_CORBA_sequence__OBE_C_LinkInfo_defined
typedef struct
{
    CORBA_unsigned_long _maximum;
    CORBA_unsigned_long _length;
    _OBE_C_LinkInfo* _buffer;
    CORBA_boolean _release;
} _OBE_C_CORBA_sequence__OBE_C_LinkInfo;
#endif

typedef _OBE_C_CORBA_sequence__OBE_C_LinkInfo _OBE_C_LinkInfoSeq;

typedef CORBA_float _OBE_C_Vector3[3];
typedef CORBA_float _OBE_C_Vector3_slice;

typedef struct _OBE_C_CollisionData _OBE_C_CollisionData;

struct _OBE_C_CollisionData
{
    _OBE_C_Vector3 coord;
    _OBE_C_Vector3 normal;
    CORBA_double idepth;
};

#ifndef __OBE_C_CORBA_sequence__OBE_C_CollisionData_defined
#define __OBE_C_CORBA_sequence__OBE_C_CollisionData_defined
typedef struct
{
    CORBA_unsigned_long _maximum;
    CORBA_unsigned_long _length;
    _OBE_C_CollisionData* _buffer;
    CORBA_boolean _release;
} _OBE_C_CORBA_sequence__OBE_C_CollisionData;
#endif

typedef _OBE_C_CORBA_sequence__OBE_C_CollisionData _OBE_C_CollisionDataSeq;

typedef struct _OBE_C_WorldState _OBE_C_WorldState;

struct _OBE_C_WorldState
{
    CORBA_double time;
    _OBE_C_LinkInfoSeq linkinfo;
    _OBE_C_CollisionDataSeq collision;
};

typedef _OBE_C_CORBA_sequence_double _OBE_C_dsequence;

typedef CORBA_unsigned_long _OBE_C_PixelFormat;

#define _OBE_C_ARGB 0
#define _OBE_C_GRAY 1
#define _OBE_C_DEPTH 2
#define _OBE_C_RGB 3

typedef struct _OBE_C_ImageData _OBE_C_ImageData;


#ifndef __OBE_C_CORBA_sequence_octet_defined
#define __OBE_C_CORBA_sequence_octet_defined
typedef struct
{
    CORBA_unsigned_long _maximum;
    CORBA_unsigned_long _length;
    CORBA_octet* _buffer;
    CORBA_boolean _release;
} _OBE_C_CORBA_sequence_octet;
#endif


#ifndef __OBE_C_CORBA_sequence_long_defined
#define __OBE_C_CORBA_sequence_long_defined
typedef struct
{
    CORBA_unsigned_long _maximum;
    CORBA_unsigned_long _length;
    CORBA_long* _buffer;
    CORBA_boolean _release;
} _OBE_C_CORBA_sequence_long;
#endif


#ifndef __OBE_C_CORBA_sequence_float_defined
#define __OBE_C_CORBA_sequence_float_defined
typedef struct
{
    CORBA_unsigned_long _maximum;
    CORBA_unsigned_long _length;
    CORBA_float* _buffer;
    CORBA_boolean _release;
} _OBE_C_CORBA_sequence_float;
#endif

struct _OBE_C_ImageData
{
    _OBE_C_PixelFormat format;
    CORBA_long width;
    CORBA_long height;
    _OBE_C_CORBA_sequence_octet octetData;
    _OBE_C_CORBA_sequence_long longData;
    _OBE_C_CORBA_sequence_float floatData;
};

typedef struct _OBE_C_RobotState _OBE_C_RobotState;



#ifndef __OBE_C_CORBA_sequence_sequence_double_defined
#define __OBE_C_CORBA_sequence_sequence_double_defined
typedef struct
{
    CORBA_unsigned_long _maximum;
    CORBA_unsigned_long _length;
    _OBE_C_dsequence* _buffer;
    CORBA_boolean _release;
} _OBE_C_CORBA_sequence_sequence_double;
#endif








#ifndef __OBE_C_CORBA_sequence__OBE_C_ImageData_defined
#define __OBE_C_CORBA_sequence__OBE_C_ImageData_defined
typedef struct
{
    CORBA_unsigned_long _maximum;
    CORBA_unsigned_long _length;
    _OBE_C_ImageData* _buffer;
    CORBA_boolean _release;
} _OBE_C_CORBA_sequence__OBE_C_ImageData;
#endif


struct _OBE_C_RobotState
{
    _OBE_C_dsequence angle;
    _OBE_C_dsequence velocity;
    _OBE_C_dsequence torque;
    _OBE_C_CORBA_sequence_sequence_double force;
    _OBE_C_CORBA_sequence_sequence_double rate;
    _OBE_C_CORBA_sequence_sequence_double accel;
    _OBE_C_CORBA_sequence_sequence_double attitude;
    _OBE_C_dsequence zmp;
    _OBE_C_dsequence waistPos;
    _OBE_C_dsequence waistRpy;
    _OBE_C_CORBA_sequence__OBE_C_ImageData image;
    _OBE_C_CORBA_sequence_long dio;
};

typedef _OBE_C_Value _OBE_C_ValueMatrix;

typedef CORBA_unsigned_long _OBE_C_SensorType;

#define _OBE_C_FORCE_SENSOR 0
#define _OBE_C_GYRO 1
#define _OBE_C_ACCELERATION_SENSOR 2
#define _OBE_C_PRESSURE_SENSOR 3
#define _OBE_C_PHOTO_INTERRUPTER 4
#define _OBE_C_VISION_SENSOR 5
#define _OBE_C_TORQUE_SENSOR 6

#ifndef __OBE_C_CORBA_sequence__OBE_C_SensorInfo_defined
#define __OBE_C_CORBA_sequence__OBE_C_SensorInfo_defined
typedef struct
{
    CORBA_unsigned_long _maximum;
    CORBA_unsigned_long _length;
    _OBE_C_SensorInfo* _buffer;
    CORBA_boolean _release;
} _OBE_C_CORBA_sequence__OBE_C_SensorInfo;
#endif

typedef _OBE_C_CORBA_sequence__OBE_C_SensorInfo _OBE_C_SensorInfoSeq;

typedef _OBE_C_CORBA_sequence_string _OBE_C_stringSeq;

#ifndef __OBE_C_CORBA_sequence__OBE_C_ParserModelObject_defined
#define __OBE_C_CORBA_sequence__OBE_C_ParserModelObject_defined
typedef struct
{
    CORBA_unsigned_long _maximum;
    CORBA_unsigned_long _length;
    _OBE_C_ParserModelObject* _buffer;
    CORBA_boolean _release;
} _OBE_C_CORBA_sequence__OBE_C_ParserModelObject;
#endif

typedef _OBE_C_CORBA_sequence__OBE_C_ParserModelObject _OBE_C_ParserModelObjectSeq;

typedef _OBE_C_CORBA_sequence_float _OBE_C_ModelInfo_floatSeq;

typedef _OBE_C_CORBA_sequence_string _OBE_C_ModelInfo_NameSeq;
}

//
// IDL:TorqueSeq:1.0
//

static _CORBA_TypeCode _OB_TC_0__OBE_C_TorqueSeq =
{
    CORBA_tk_double,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC_1__OBE_C_TorqueSeq =
{
    CORBA_tk_sequence,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_0__OBE_C_TorqueSeq,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC__OBE_C_TorqueSeq =
{
    CORBA_tk_alias,
    (char*)"IDL:TorqueSeq:1.0",
    (char*)"TorqueSeq",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_1__OBE_C_TorqueSeq,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_TorqueSeq(&_OB_TC__OBE_C_TorqueSeq);

//
// IDL:DataId:1.0
//

static char* _OB_TC__OBE_C_DataId__OB_tc_member_names[] =
{
    (char*)"ANGLE",
    (char*)"VELOCITY",
    (char*)"ACCELERATION"
};

static _CORBA_TypeCode _OB_TC__OBE_C_DataId =
{
    CORBA_tk_enum,
    (char*)"IDL:DataId:1.0",
    (char*)"DataId",
    3,
    _OB_TC__OBE_C_DataId__OB_tc_member_names,
    NULL,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_DataId(&_OB_TC__OBE_C_DataId);

//
// IDL:LinkData:1.0
//

static _CORBA_TypeCode _OB_TC_0__OBE_C_LinkData =
{
    CORBA_tk_array,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    3,
    &_OB_TC_0__OBE_C_TorqueSeq,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC__OBE_C_LinkData =
{
    CORBA_tk_alias,
    (char*)"IDL:LinkData:1.0",
    (char*)"LinkData",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_0__OBE_C_LinkData,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_LinkData(&_OB_TC__OBE_C_LinkData);

//
// IDL:LinkDataSeq:1.0
//

static _CORBA_TypeCode _OB_TC_0__OBE_C_LinkDataSeq =
{
    CORBA_tk_sequence,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC__OBE_C_LinkData,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC__OBE_C_LinkDataSeq =
{
    CORBA_tk_alias,
    (char*)"IDL:LinkDataSeq:1.0",
    (char*)"LinkDataSeq",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_0__OBE_C_LinkDataSeq,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_LinkDataSeq(&_OB_TC__OBE_C_LinkDataSeq);

//
// IDL:Value:1.0
//

static _CORBA_TypeCode _OB_TC_0__OBE_C_Value =
{
    CORBA_tk_sequence,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    9,
    &_OB_TC_0__OBE_C_TorqueSeq,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC__OBE_C_Value =
{
    CORBA_tk_alias,
    (char*)"IDL:Value:1.0",
    (char*)"Value",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_0__OBE_C_Value,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_Value(&_OB_TC__OBE_C_Value);

//
// IDL:FSValue:1.0
//

static _CORBA_TypeCode _OB_TC_0__OBE_C_FSValue =
{
    CORBA_tk_sequence,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    6,
    &_OB_TC_0__OBE_C_TorqueSeq,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC__OBE_C_FSValue =
{
    CORBA_tk_alias,
    (char*)"IDL:FSValue:1.0",
    (char*)"FSValue",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_0__OBE_C_FSValue,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_FSValue(&_OB_TC__OBE_C_FSValue);

//
// IDL:LinkNameSeq:1.0
//

static _CORBA_TypeCode _OB_TC_0__OBE_C_LinkNameSeq =
{
    CORBA_tk_string,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC_1__OBE_C_LinkNameSeq =
{
    CORBA_tk_sequence,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_0__OBE_C_LinkNameSeq,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC__OBE_C_LinkNameSeq =
{
    CORBA_tk_alias,
    (char*)"IDL:LinkNameSeq:1.0",
    (char*)"LinkNameSeq",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_1__OBE_C_LinkNameSeq,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_LinkNameSeq(&_OB_TC__OBE_C_LinkNameSeq);

//
// IDL:Transform:1.0
//

extern _CORBA_TypeCode _OB_TC__OBE_C_Transform;

static _CORBA_TypeCode _OB_TC_0__OBE_C_Transform =
{
    CORBA_tk_float,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static _CORBA_TypeCode* _OB_TC__OBE_C_Transform__OB_tc_member_types[] =
{
    &_OB_TC_0__OBE_C_Transform,
    &_OB_TC_0__OBE_C_Transform,
    &_OB_TC_0__OBE_C_Transform,
    &_OB_TC_0__OBE_C_Transform,
    &_OB_TC_0__OBE_C_Transform,
    &_OB_TC_0__OBE_C_Transform,
    &_OB_TC_0__OBE_C_Transform
};

static char* _OB_TC__OBE_C_Transform__OB_tc_member_names[] =
{
    (char*)"posX",
    (char*)"posY",
    (char*)"posZ",
    (char*)"axisX",
    (char*)"axisY",
    (char*)"axisZ",
    (char*)"angle"
};

_CORBA_TypeCode _OB_TC__OBE_C_Transform =
{
    CORBA_tk_struct,
    (char*)"IDL:Transform:1.0",
    (char*)"Transform",
    7,
    _OB_TC__OBE_C_Transform__OB_tc_member_names,
    _OB_TC__OBE_C_Transform__OB_tc_member_types,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_Transform(&_OB_TC__OBE_C_Transform);

//
// IDL:TransformQuaternion:1.0
//

extern _CORBA_TypeCode _OB_TC__OBE_C_TransformQuaternion;

static _CORBA_TypeCode* _OB_TC__OBE_C_TransformQuaternion__OB_tc_member_types[] =
{
    &_OB_TC_0__OBE_C_Transform,
    &_OB_TC_0__OBE_C_Transform,
    &_OB_TC_0__OBE_C_Transform,
    &_OB_TC_0__OBE_C_Transform,
    &_OB_TC_0__OBE_C_Transform,
    &_OB_TC_0__OBE_C_Transform,
    &_OB_TC_0__OBE_C_Transform
};

static char* _OB_TC__OBE_C_TransformQuaternion__OB_tc_member_names[] =
{
    (char*)"px",
    (char*)"py",
    (char*)"pz",
    (char*)"qx",
    (char*)"qy",
    (char*)"qz",
    (char*)"qw"
};

_CORBA_TypeCode _OB_TC__OBE_C_TransformQuaternion =
{
    CORBA_tk_struct,
    (char*)"IDL:TransformQuaternion:1.0",
    (char*)"TransformQuaternion",
    7,
    _OB_TC__OBE_C_TransformQuaternion__OB_tc_member_names,
    _OB_TC__OBE_C_TransformQuaternion__OB_tc_member_types,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_TransformQuaternion(&_OB_TC__OBE_C_TransformQuaternion);

//
// IDL:LinkInfo:1.0
//

extern _CORBA_TypeCode _OB_TC__OBE_C_LinkInfo;

static _CORBA_TypeCode* _OB_TC__OBE_C_LinkInfo__OB_tc_member_types[] =
{
    &_OB_TC_0__OBE_C_LinkNameSeq,
    &_OB_TC__OBE_C_Value,
    &_OB_TC__OBE_C_Value,
    &_OB_TC_0__OBE_C_TorqueSeq,
    &_OB_TC_0__OBE_C_TorqueSeq,
    &_OB_TC_0__OBE_C_TorqueSeq,
    &_OB_TC__OBE_C_Value,
    &_OB_TC__OBE_C_Value,
    &_OB_TC__OBE_C_Value,
    &_OB_TC__OBE_C_Value
};

static char* _OB_TC__OBE_C_LinkInfo__OB_tc_member_names[] =
{
    (char*)"name",
    (char*)"pos",
    (char*)"rot",
    (char*)"JointValue",
    (char*)"JointVel",
    (char*)"JointAcc",
    (char*)"jpos",
    (char*)"jatt",
    (char*)"vel",
    (char*)"acc"
};

_CORBA_TypeCode _OB_TC__OBE_C_LinkInfo =
{
    CORBA_tk_struct,
    (char*)"IDL:LinkInfo:1.0",
    (char*)"LinkInfo",
    10,
    _OB_TC__OBE_C_LinkInfo__OB_tc_member_names,
    _OB_TC__OBE_C_LinkInfo__OB_tc_member_types,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_LinkInfo(&_OB_TC__OBE_C_LinkInfo);

//
// IDL:LinkValue:1.0
//

extern _CORBA_TypeCode _OB_TC__OBE_C_LinkValue;

static _CORBA_TypeCode* _OB_TC__OBE_C_LinkValue__OB_tc_member_types[] =
{
    &_OB_TC_0__OBE_C_LinkNameSeq,
    &_OB_TC_0__OBE_C_LinkNameSeq,
    &_OB_TC__OBE_C_Value
};

static char* _OB_TC__OBE_C_LinkValue__OB_tc_member_names[] =
{
    (char*)"name",
    (char*)"param",
    (char*)"data"
};

_CORBA_TypeCode _OB_TC__OBE_C_LinkValue =
{
    CORBA_tk_struct,
    (char*)"IDL:LinkValue:1.0",
    (char*)"LinkValue",
    3,
    _OB_TC__OBE_C_LinkValue__OB_tc_member_names,
    _OB_TC__OBE_C_LinkValue__OB_tc_member_types,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_LinkValue(&_OB_TC__OBE_C_LinkValue);

//
// IDL:LinkValueSeq:1.0
//

static _CORBA_TypeCode _OB_TC_0__OBE_C_LinkValueSeq =
{
    CORBA_tk_sequence,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC__OBE_C_LinkValue,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC__OBE_C_LinkValueSeq =
{
    CORBA_tk_alias,
    (char*)"IDL:LinkValueSeq:1.0",
    (char*)"LinkValueSeq",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_0__OBE_C_LinkValueSeq,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_LinkValueSeq(&_OB_TC__OBE_C_LinkValueSeq);

//
// IDL:LinkInfoSeq:1.0
//

static _CORBA_TypeCode _OB_TC_0__OBE_C_LinkInfoSeq =
{
    CORBA_tk_sequence,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC__OBE_C_LinkInfo,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC__OBE_C_LinkInfoSeq =
{
    CORBA_tk_alias,
    (char*)"IDL:LinkInfoSeq:1.0",
    (char*)"LinkInfoSeq",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_0__OBE_C_LinkInfoSeq,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_LinkInfoSeq(&_OB_TC__OBE_C_LinkInfoSeq);

//
// IDL:Vector3:1.0
//

static _CORBA_TypeCode _OB_TC_0__OBE_C_Vector3 =
{
    CORBA_tk_array,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    3,
    &_OB_TC_0__OBE_C_Transform,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC__OBE_C_Vector3 =
{
    CORBA_tk_alias,
    (char*)"IDL:Vector3:1.0",
    (char*)"Vector3",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_0__OBE_C_Vector3,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_Vector3(&_OB_TC__OBE_C_Vector3);

//
// IDL:CollisionData:1.0
//

extern _CORBA_TypeCode _OB_TC__OBE_C_CollisionData;

static _CORBA_TypeCode* _OB_TC__OBE_C_CollisionData__OB_tc_member_types[] =
{
    &_OB_TC__OBE_C_Vector3,
    &_OB_TC__OBE_C_Vector3,
    &_OB_TC_0__OBE_C_TorqueSeq
};

static char* _OB_TC__OBE_C_CollisionData__OB_tc_member_names[] =
{
    (char*)"coord",
    (char*)"normal",
    (char*)"idepth"
};

_CORBA_TypeCode _OB_TC__OBE_C_CollisionData =
{
    CORBA_tk_struct,
    (char*)"IDL:CollisionData:1.0",
    (char*)"CollisionData",
    3,
    _OB_TC__OBE_C_CollisionData__OB_tc_member_names,
    _OB_TC__OBE_C_CollisionData__OB_tc_member_types,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_CollisionData(&_OB_TC__OBE_C_CollisionData);

//
// IDL:CollisionDataSeq:1.0
//

static _CORBA_TypeCode _OB_TC_0__OBE_C_CollisionDataSeq =
{
    CORBA_tk_sequence,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC__OBE_C_CollisionData,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC__OBE_C_CollisionDataSeq =
{
    CORBA_tk_alias,
    (char*)"IDL:CollisionDataSeq:1.0",
    (char*)"CollisionDataSeq",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_0__OBE_C_CollisionDataSeq,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_CollisionDataSeq(&_OB_TC__OBE_C_CollisionDataSeq);

//
// IDL:WorldState:1.0
//

extern _CORBA_TypeCode _OB_TC__OBE_C_WorldState;

static _CORBA_TypeCode* _OB_TC__OBE_C_WorldState__OB_tc_member_types[] =
{
    &_OB_TC_0__OBE_C_TorqueSeq,
    &_OB_TC__OBE_C_LinkInfoSeq,
    &_OB_TC__OBE_C_CollisionDataSeq
};

static char* _OB_TC__OBE_C_WorldState__OB_tc_member_names[] =
{
    (char*)"time",
    (char*)"linkinfo",
    (char*)"collision"
};

_CORBA_TypeCode _OB_TC__OBE_C_WorldState =
{
    CORBA_tk_struct,
    (char*)"IDL:WorldState:1.0",
    (char*)"WorldState",
    3,
    _OB_TC__OBE_C_WorldState__OB_tc_member_names,
    _OB_TC__OBE_C_WorldState__OB_tc_member_types,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_WorldState(&_OB_TC__OBE_C_WorldState);

//
// IDL:dsequence:1.0
//

static _CORBA_TypeCode _OB_TC_0__OBE_C_dsequence =
{
    CORBA_tk_sequence,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_0__OBE_C_TorqueSeq,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC__OBE_C_dsequence =
{
    CORBA_tk_alias,
    (char*)"IDL:dsequence:1.0",
    (char*)"dsequence",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_0__OBE_C_dsequence,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_dsequence(&_OB_TC__OBE_C_dsequence);

//
// IDL:PixelFormat:1.0
//

static char* _OB_TC__OBE_C_PixelFormat__OB_tc_member_names[] =
{
    (char*)"ARGB",
    (char*)"GRAY",
    (char*)"DEPTH",
    (char*)"RGB"
};

static _CORBA_TypeCode _OB_TC__OBE_C_PixelFormat =
{
    CORBA_tk_enum,
    (char*)"IDL:PixelFormat:1.0",
    (char*)"PixelFormat",
    4,
    _OB_TC__OBE_C_PixelFormat__OB_tc_member_names,
    NULL,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_PixelFormat(&_OB_TC__OBE_C_PixelFormat);

//
// IDL:ImageData:1.0
//

extern _CORBA_TypeCode _OB_TC__OBE_C_ImageData;

static _CORBA_TypeCode _OB_TC_0__OBE_C_ImageData =
{
    CORBA_tk_long,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC_1__OBE_C_ImageData =
{
    CORBA_tk_octet,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC_2__OBE_C_ImageData =
{
    CORBA_tk_sequence,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_1__OBE_C_ImageData,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC_3__OBE_C_ImageData =
{
    CORBA_tk_sequence,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_0__OBE_C_ImageData,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC_4__OBE_C_ImageData =
{
    CORBA_tk_sequence,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_0__OBE_C_Transform,
    OBEC_TRUE
};

static _CORBA_TypeCode* _OB_TC__OBE_C_ImageData__OB_tc_member_types[] =
{
    &_OB_TC__OBE_C_PixelFormat,
    &_OB_TC_0__OBE_C_ImageData,
    &_OB_TC_0__OBE_C_ImageData,
    &_OB_TC_2__OBE_C_ImageData,
    &_OB_TC_3__OBE_C_ImageData,
    &_OB_TC_4__OBE_C_ImageData
};

static char* _OB_TC__OBE_C_ImageData__OB_tc_member_names[] =
{
    (char*)"format",
    (char*)"width",
    (char*)"height",
    (char*)"octetData",
    (char*)"longData",
    (char*)"floatData"
};

_CORBA_TypeCode _OB_TC__OBE_C_ImageData =
{
    CORBA_tk_struct,
    (char*)"IDL:ImageData:1.0",
    (char*)"ImageData",
    6,
    _OB_TC__OBE_C_ImageData__OB_tc_member_names,
    _OB_TC__OBE_C_ImageData__OB_tc_member_types,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_ImageData(&_OB_TC__OBE_C_ImageData);

//
// IDL:RobotState:1.0
//

extern _CORBA_TypeCode _OB_TC__OBE_C_RobotState;

static _CORBA_TypeCode _OB_TC_0__OBE_C_RobotState =
{
    CORBA_tk_sequence,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC__OBE_C_dsequence,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC_1__OBE_C_RobotState =
{
    CORBA_tk_sequence,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC__OBE_C_dsequence,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC_2__OBE_C_RobotState =
{
    CORBA_tk_sequence,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC__OBE_C_dsequence,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC_3__OBE_C_RobotState =
{
    CORBA_tk_sequence,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC__OBE_C_dsequence,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC_4__OBE_C_RobotState =
{
    CORBA_tk_sequence,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC__OBE_C_ImageData,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC_5__OBE_C_RobotState =
{
    CORBA_tk_sequence,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_0__OBE_C_ImageData,
    OBEC_TRUE
};

static _CORBA_TypeCode* _OB_TC__OBE_C_RobotState__OB_tc_member_types[] =
{
    &_OB_TC__OBE_C_dsequence,
    &_OB_TC__OBE_C_dsequence,
    &_OB_TC__OBE_C_dsequence,
    &_OB_TC_0__OBE_C_RobotState,
    &_OB_TC_1__OBE_C_RobotState,
    &_OB_TC_2__OBE_C_RobotState,
    &_OB_TC_3__OBE_C_RobotState,
    &_OB_TC__OBE_C_dsequence,
    &_OB_TC__OBE_C_dsequence,
    &_OB_TC__OBE_C_dsequence,
    &_OB_TC_4__OBE_C_RobotState,
    &_OB_TC_5__OBE_C_RobotState
};

static char* _OB_TC__OBE_C_RobotState__OB_tc_member_names[] =
{
    (char*)"angle",
    (char*)"velocity",
    (char*)"torque",
    (char*)"force",
    (char*)"rate",
    (char*)"accel",
    (char*)"attitude",
    (char*)"zmp",
    (char*)"waistPos",
    (char*)"waistRpy",
    (char*)"image",
    (char*)"dio"
};

_CORBA_TypeCode _OB_TC__OBE_C_RobotState =
{
    CORBA_tk_struct,
    (char*)"IDL:RobotState:1.0",
    (char*)"RobotState",
    12,
    _OB_TC__OBE_C_RobotState__OB_tc_member_names,
    _OB_TC__OBE_C_RobotState__OB_tc_member_types,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_RobotState(&_OB_TC__OBE_C_RobotState);

//
// IDL:ValueMatrix:1.0
//

static _CORBA_TypeCode _OB_TC__OBE_C_ValueMatrix =
{
    CORBA_tk_alias,
    (char*)"IDL:ValueMatrix:1.0",
    (char*)"ValueMatrix",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC__OBE_C_Value,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_ValueMatrix(&_OB_TC__OBE_C_ValueMatrix);

//
// IDL:SensorType:1.0
//

static char* _OB_TC__OBE_C_SensorType__OB_tc_member_names[] =
{
    (char*)"FORCE_SENSOR",
    (char*)"GYRO",
    (char*)"ACCELERATION_SENSOR",
    (char*)"PRESSURE_SENSOR",
    (char*)"PHOTO_INTERRUPTER",
    (char*)"VISION_SENSOR",
    (char*)"TORQUE_SENSOR"
};

static _CORBA_TypeCode _OB_TC__OBE_C_SensorType =
{
    CORBA_tk_enum,
    (char*)"IDL:SensorType:1.0",
    (char*)"SensorType",
    7,
    _OB_TC__OBE_C_SensorType__OB_tc_member_names,
    NULL,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_SensorType(&_OB_TC__OBE_C_SensorType);

//
// IDL:SensorInfo:1.0
//
static _CORBA_TypeCode _OB_TC__OBE_C_SensorInfo =
{
    CORBA_tk_objref,
    (char*)"IDL:SensorInfo:1.0",
    (char*)"SensorInfo",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_SensorInfo(&_OB_TC__OBE_C_SensorInfo);

//
// IDL:SensorInfoSeq:1.0
//

static _CORBA_TypeCode _OB_TC_0__OBE_C_SensorInfoSeq =
{
    CORBA_tk_sequence,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC__OBE_C_SensorInfo,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC__OBE_C_SensorInfoSeq =
{
    CORBA_tk_alias,
    (char*)"IDL:SensorInfoSeq:1.0",
    (char*)"SensorInfoSeq",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_0__OBE_C_SensorInfoSeq,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_SensorInfoSeq(&_OB_TC__OBE_C_SensorInfoSeq);

//
// IDL:ParserModelObject:1.0
//
static _CORBA_TypeCode _OB_TC__OBE_C_ParserModelObject =
{
    CORBA_tk_objref,
    (char*)"IDL:ParserModelObject:1.0",
    (char*)"ParserModelObject",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_ParserModelObject(&_OB_TC__OBE_C_ParserModelObject);

//
// IDL:stringSeq:1.0
//

static _CORBA_TypeCode _OB_TC_0__OBE_C_stringSeq =
{
    CORBA_tk_sequence,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_0__OBE_C_LinkNameSeq,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC__OBE_C_stringSeq =
{
    CORBA_tk_alias,
    (char*)"IDL:stringSeq:1.0",
    (char*)"stringSeq",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_0__OBE_C_stringSeq,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_stringSeq(&_OB_TC__OBE_C_stringSeq);

//
// IDL:ParserModelObjectSeq:1.0
//

static _CORBA_TypeCode _OB_TC_0__OBE_C_ParserModelObjectSeq =
{
    CORBA_tk_sequence,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC__OBE_C_ParserModelObject,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC__OBE_C_ParserModelObjectSeq =
{
    CORBA_tk_alias,
    (char*)"IDL:ParserModelObjectSeq:1.0",
    (char*)"ParserModelObjectSeq",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_0__OBE_C_ParserModelObjectSeq,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_ParserModelObjectSeq(&_OB_TC__OBE_C_ParserModelObjectSeq);

//
// IDL:ParserCharObject:1.0
//
static _CORBA_TypeCode _OB_TC__OBE_C_ParserCharObject =
{
    CORBA_tk_objref,
    (char*)"IDL:ParserCharObject:1.0",
    (char*)"ParserCharObject",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_ParserCharObject(&_OB_TC__OBE_C_ParserCharObject);

//
// IDL:ModelInfo:1.0
//
static _CORBA_TypeCode _OB_TC__OBE_C_ModelInfo =
{
    CORBA_tk_objref,
    (char*)"IDL:ModelInfo:1.0",
    (char*)"ModelInfo",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_ModelInfo(&_OB_TC__OBE_C_ModelInfo);

//
// IDL:ModelInfo/floatSeq:1.0
//

static _CORBA_TypeCode _OB_TC_0__OBE_C_ModelInfo_floatSeq =
{
    CORBA_tk_sequence,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_0__OBE_C_Transform,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC__OBE_C_ModelInfo_floatSeq =
{
    CORBA_tk_alias,
    (char*)"IDL:ModelInfo/floatSeq:1.0",
    (char*)"floatSeq",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_0__OBE_C_ModelInfo_floatSeq,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_ModelInfo_floatSeq(&_OB_TC__OBE_C_ModelInfo_floatSeq);

//
// IDL:ModelInfo/NameSeq:1.0
//

static _CORBA_TypeCode _OB_TC_0__OBE_C_ModelInfo_NameSeq =
{
    CORBA_tk_sequence,
    NULL,
    NULL,
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_0__OBE_C_LinkNameSeq,
    OBEC_TRUE
};

static _CORBA_TypeCode _OB_TC__OBE_C_ModelInfo_NameSeq =
{
    CORBA_tk_alias,
    (char*)"IDL:ModelInfo/NameSeq:1.0",
    (char*)"NameSeq",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    &_OB_TC_0__OBE_C_ModelInfo_NameSeq,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_ModelInfo_NameSeq(&_OB_TC__OBE_C_ModelInfo_NameSeq);

//
// IDL:OpenHRPObject:1.0
//
static _CORBA_TypeCode _OB_TC__OBE_C_OpenHRPObject =
{
    CORBA_tk_objref,
    (char*)"IDL:OpenHRPObject:1.0",
    (char*)"OpenHRPObject",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_OpenHRPObject(&_OB_TC__OBE_C_OpenHRPObject);

//
// IDL:CommandReceiver:1.0
//
static _CORBA_TypeCode _OB_TC__OBE_C_CommandReceiver =
{
    CORBA_tk_objref,
    (char*)"IDL:CommandReceiver:1.0",
    (char*)"CommandReceiver",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_CommandReceiver(&_OB_TC__OBE_C_CommandReceiver);

//
// IDL:Plugin:1.0
//
static _CORBA_TypeCode _OB_TC__OBE_C_Plugin =
{
    CORBA_tk_objref,
    (char*)"IDL:Plugin:1.0",
    (char*)"Plugin",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_Plugin(&_OB_TC__OBE_C_Plugin);

//
// IDL:PluginManager:1.0
//
static _CORBA_TypeCode _OB_TC__OBE_C_PluginManager =
{
    CORBA_tk_objref,
    (char*)"IDL:PluginManager:1.0",
    (char*)"PluginManager",
    0,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    NULL,
    OBEC_TRUE
};

static OB::TypeCodeConst _OBE_TC_PluginManager(&_OB_TC__OBE_C_PluginManager);

CORBA::TypeCode_ptr _tc_TorqueSeq = &_OBE_TC_TorqueSeq;

CORBA::TypeCode_ptr _tc_DataId = &_OBE_TC_DataId;

CORBA::TypeCode_ptr _tc_LinkData = &_OBE_TC_LinkData;

CORBA::TypeCode_ptr _tc_LinkDataSeq = &_OBE_TC_LinkDataSeq;

CORBA::TypeCode_ptr _tc_Value = &_OBE_TC_Value;

CORBA::TypeCode_ptr _tc_FSValue = &_OBE_TC_FSValue;

CORBA::TypeCode_ptr _tc_LinkNameSeq = &_OBE_TC_LinkNameSeq;

CORBA::TypeCode_ptr _tc_Transform = &_OBE_TC_Transform;

CORBA::TypeCode_ptr _tc_TransformQuaternion = &_OBE_TC_TransformQuaternion;

CORBA::TypeCode_ptr _tc_LinkInfo = &_OBE_TC_LinkInfo;

CORBA::TypeCode_ptr _tc_LinkValue = &_OBE_TC_LinkValue;

CORBA::TypeCode_ptr _tc_LinkValueSeq = &_OBE_TC_LinkValueSeq;

CORBA::TypeCode_ptr _tc_LinkInfoSeq = &_OBE_TC_LinkInfoSeq;

CORBA::TypeCode_ptr _tc_Vector3 = &_OBE_TC_Vector3;

CORBA::TypeCode_ptr _tc_CollisionData = &_OBE_TC_CollisionData;

CORBA::TypeCode_ptr _tc_CollisionDataSeq = &_OBE_TC_CollisionDataSeq;

CORBA::TypeCode_ptr _tc_WorldState = &_OBE_TC_WorldState;

CORBA::TypeCode_ptr _tc_dsequence = &_OBE_TC_dsequence;

CORBA::TypeCode_ptr _tc_PixelFormat = &_OBE_TC_PixelFormat;

CORBA::TypeCode_ptr _tc_ImageData = &_OBE_TC_ImageData;

CORBA::TypeCode_ptr _tc_RobotState = &_OBE_TC_RobotState;

CORBA::TypeCode_ptr _tc_ValueMatrix = &_OBE_TC_ValueMatrix;

CORBA::TypeCode_ptr _tc_SensorType = &_OBE_TC_SensorType;

CORBA::TypeCode_ptr _tc_SensorInfo = &_OBE_TC_SensorInfo;

CORBA::TypeCode_ptr _tc_SensorInfoSeq = &_OBE_TC_SensorInfoSeq;

CORBA::TypeCode_ptr _tc_ParserModelObject = &_OBE_TC_ParserModelObject;

CORBA::TypeCode_ptr _tc_stringSeq = &_OBE_TC_stringSeq;

CORBA::TypeCode_ptr _tc_ParserModelObjectSeq = &_OBE_TC_ParserModelObjectSeq;

CORBA::TypeCode_ptr _tc_ParserCharObject = &_OBE_TC_ParserCharObject;

CORBA::TypeCode_ptr _tc_ModelInfo = &_OBE_TC_ModelInfo;

CORBA::TypeCode_ptr ModelInfo::_tc_floatSeq = &_OBE_TC_ModelInfo_floatSeq;

CORBA::TypeCode_ptr ModelInfo::_tc_NameSeq = &_OBE_TC_ModelInfo_NameSeq;

CORBA::TypeCode_ptr _tc_OpenHRPObject = &_OBE_TC_OpenHRPObject;

CORBA::TypeCode_ptr _tc_CommandReceiver = &_OBE_TC_CommandReceiver;

CORBA::TypeCode_ptr _tc_Plugin = &_OBE_TC_Plugin;

CORBA::TypeCode_ptr _tc_PluginManager = &_OBE_TC_PluginManager;

//
// IDL:TorqueSeq:1.0
//
static CORBA::AnyContentDestroyerDelete<TorqueSeq> OBAnyContentDestroyerInstance_TorqueSeq;

void
operator<<=(CORBA::Any& any, TorqueSeq* v)
{
    _OBE_C_CORBA_sequence_double* p = (_OBE_C_CORBA_sequence_double*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_TorqueSeq->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence_double));
    (*p)._length = (*v).length();
    (*p)._maximum = (*v).length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (CORBA_double*)OBEC_allocate_buffer(NULL, sizeof(CORBA_double) * (*p)._length, (*p)._length, OBEC_FALSE);

    memcpy((*p)._buffer, (*v).get_buffer(), sizeof(CORBA_double) * (*p)._length);
    any.replace(_tc_TorqueSeq, p, false, v, &OBAnyContentDestroyerInstance_TorqueSeq);
}

void
operator<<=(CORBA::Any& any, const TorqueSeq& v)
{
    _OBE_C_CORBA_sequence_double* p = (_OBE_C_CORBA_sequence_double*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_TorqueSeq->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence_double));
    (*p)._length = v.length();
    (*p)._maximum = v.length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (CORBA_double*)OBEC_allocate_buffer(NULL, sizeof(CORBA_double) * (*p)._length, (*p)._length, OBEC_FALSE);

    memcpy((*p)._buffer, v.get_buffer(), sizeof(CORBA_double) * (*p)._length);
    any.replace(_tc_TorqueSeq, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const TorqueSeq*& v)
{
    if (!any.check_type(_tc_TorqueSeq))
        return false;

    v = (const TorqueSeq*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_CORBA_sequence_double* p = (_OBE_C_CORBA_sequence_double*)any.value();
        assert(p != NULL);
        TorqueSeq* val = new TorqueSeq;
        (*val).length((*p)._length);

        memcpy((*val).get_buffer(), (*p)._buffer, sizeof(CORBA_double) * (*p)._length);
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_TorqueSeq);
        v = val;
    }

    return true;
}

//
// IDL:DataId:1.0
//
void
operator<<=(CORBA::Any& any, DataId v)
{
    CORBA_unsigned_long* p = (CORBA_unsigned_long*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_DataId->_OB_impl_nodup(), sizeof(CORBA_unsigned_long)); 
    *p = (CORBA_unsigned_long)v;
    any.replace(_tc_DataId, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, DataId& v)
{
    if (!any.check_type(_tc_DataId))
        return false;

    v = (DataId)(*(CORBA_unsigned_long*)any.value());

    return true;
}

//
// IDL:LinkData:1.0
//
static CORBA::AnyContentDestroyerDeleteArray< CORBA::Double > OBAnyContentDestroyerInstance_LinkData;

void
operator<<=(CORBA::Any& any, const LinkData_forany& r)
{
    const LinkData_slice* s = r.in();
    CORBA_double* p = (CORBA_double*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_LinkData->_OB_impl_nodup(), sizeof(CORBA_double) * 3);
    memcpy(p, s, sizeof(CORBA_double) * 3);

    if (r.nocopy())
        any.replace(_tc_LinkData, p, false, (void*)s, &OBAnyContentDestroyerInstance_LinkData);
    else
        any.replace(_tc_LinkData, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, LinkData_forany& r)
{
    if (!any.check_type(_tc_LinkData))
        return false;

    LinkData_slice* s = (LinkData_slice*)any.cpp_value();
    if (s != 0)
        r = s;
    else
    {
        CORBA_double* p = (CORBA_double*)any.value();
        assert(p != 0);
        LinkData_slice* s = LinkData_alloc();
        memcpy(s, p, sizeof(CORBA_double) * 3);
        ((CORBA::Any&)any).cpp_value(s, &OBAnyContentDestroyerInstance_LinkData);
        r = s;
    }

    return true;
}

//
// IDL:LinkDataSeq:1.0
//
static CORBA::AnyContentDestroyerDelete<LinkDataSeq> OBAnyContentDestroyerInstance_LinkDataSeq;

void
operator<<=(CORBA::Any& any, LinkDataSeq* v)
{
    _OBE_C_CORBA_sequence__OBE_C_LinkData* p = (_OBE_C_CORBA_sequence__OBE_C_LinkData*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_LinkDataSeq->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence__OBE_C_LinkData));
    (*p)._length = (*v).length();
    (*p)._maximum = (*v).length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (_OBE_C_LinkData*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_LinkData) * (*p)._length, (*p)._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
    {
        memcpy((*p)._buffer[_ob_i0], (*v)[_ob_i0], sizeof(CORBA_double) * 3);
    }
    any.replace(_tc_LinkDataSeq, p, false, v, &OBAnyContentDestroyerInstance_LinkDataSeq);
}

void
operator<<=(CORBA::Any& any, const LinkDataSeq& v)
{
    _OBE_C_CORBA_sequence__OBE_C_LinkData* p = (_OBE_C_CORBA_sequence__OBE_C_LinkData*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_LinkDataSeq->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence__OBE_C_LinkData));
    (*p)._length = v.length();
    (*p)._maximum = v.length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (_OBE_C_LinkData*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_LinkData) * (*p)._length, (*p)._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
    {
        memcpy((*p)._buffer[_ob_i0], v[_ob_i0], sizeof(CORBA_double) * 3);
    }
    any.replace(_tc_LinkDataSeq, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const LinkDataSeq*& v)
{
    if (!any.check_type(_tc_LinkDataSeq))
        return false;

    v = (const LinkDataSeq*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_CORBA_sequence__OBE_C_LinkData* p = (_OBE_C_CORBA_sequence__OBE_C_LinkData*)any.value();
        assert(p != NULL);
        LinkDataSeq* val = new LinkDataSeq;
        (*val).length((*p)._length);

        for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
        {
            memcpy((*val)[_ob_i0], (*p)._buffer[_ob_i0], sizeof(CORBA_double) * 3);
        }
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_LinkDataSeq);
        v = val;
    }

    return true;
}

//
// IDL:Value:1.0
//
static CORBA::AnyContentDestroyerDelete<Value> OBAnyContentDestroyerInstance_Value;

void
operator<<=(CORBA::Any& any, Value* v)
{
    _OBE_C_CORBA_sequence_double* p = (_OBE_C_CORBA_sequence_double*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_Value->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence_double));
    (*p)._length = (*v).length();
    (*p)._maximum = (*v).length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (CORBA_double*)OBEC_allocate_buffer(NULL, sizeof(CORBA_double) * (*p)._length, (*p)._length, OBEC_FALSE);

    memcpy((*p)._buffer, (*v).get_buffer(), sizeof(CORBA_double) * (*p)._length);
    any.replace(_tc_Value, p, false, v, &OBAnyContentDestroyerInstance_Value);
}

void
operator<<=(CORBA::Any& any, const Value& v)
{
    _OBE_C_CORBA_sequence_double* p = (_OBE_C_CORBA_sequence_double*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_Value->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence_double));
    (*p)._length = v.length();
    (*p)._maximum = v.length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (CORBA_double*)OBEC_allocate_buffer(NULL, sizeof(CORBA_double) * (*p)._length, (*p)._length, OBEC_FALSE);

    memcpy((*p)._buffer, v.get_buffer(), sizeof(CORBA_double) * (*p)._length);
    any.replace(_tc_Value, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const Value*& v)
{
    if (!any.check_type(_tc_Value))
        return false;

    v = (const Value*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_CORBA_sequence_double* p = (_OBE_C_CORBA_sequence_double*)any.value();
        assert(p != NULL);
        Value* val = new Value;
        (*val).length((*p)._length);

        memcpy((*val).get_buffer(), (*p)._buffer, sizeof(CORBA_double) * (*p)._length);
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_Value);
        v = val;
    }

    return true;
}

//
// IDL:FSValue:1.0
//
static CORBA::AnyContentDestroyerDelete<FSValue> OBAnyContentDestroyerInstance_FSValue;

void
operator<<=(CORBA::Any& any, FSValue* v)
{
    _OBE_C_CORBA_sequence_double* p = (_OBE_C_CORBA_sequence_double*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_FSValue->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence_double));
    (*p)._length = (*v).length();
    (*p)._maximum = (*v).length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (CORBA_double*)OBEC_allocate_buffer(NULL, sizeof(CORBA_double) * (*p)._length, (*p)._length, OBEC_FALSE);

    memcpy((*p)._buffer, (*v).get_buffer(), sizeof(CORBA_double) * (*p)._length);
    any.replace(_tc_FSValue, p, false, v, &OBAnyContentDestroyerInstance_FSValue);
}

void
operator<<=(CORBA::Any& any, const FSValue& v)
{
    _OBE_C_CORBA_sequence_double* p = (_OBE_C_CORBA_sequence_double*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_FSValue->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence_double));
    (*p)._length = v.length();
    (*p)._maximum = v.length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (CORBA_double*)OBEC_allocate_buffer(NULL, sizeof(CORBA_double) * (*p)._length, (*p)._length, OBEC_FALSE);

    memcpy((*p)._buffer, v.get_buffer(), sizeof(CORBA_double) * (*p)._length);
    any.replace(_tc_FSValue, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const FSValue*& v)
{
    if (!any.check_type(_tc_FSValue))
        return false;

    v = (const FSValue*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_CORBA_sequence_double* p = (_OBE_C_CORBA_sequence_double*)any.value();
        assert(p != NULL);
        FSValue* val = new FSValue;
        (*val).length((*p)._length);

        memcpy((*val).get_buffer(), (*p)._buffer, sizeof(CORBA_double) * (*p)._length);
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_FSValue);
        v = val;
    }

    return true;
}

//
// IDL:LinkNameSeq:1.0
//
static CORBA::AnyContentDestroyerDelete<LinkNameSeq> OBAnyContentDestroyerInstance_LinkNameSeq;

void
operator<<=(CORBA::Any& any, LinkNameSeq* v)
{
    _OBE_C_CORBA_sequence_string* p = (_OBE_C_CORBA_sequence_string*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_LinkNameSeq->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence_string));
    (*p)._length = (*v).length();
    (*p)._maximum = (*v).length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (CORBA_char**)OBEC_allocate_buffer(NULL, sizeof(CORBA_char*) * (*p)._length, (*p)._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
    {
        (*p)._buffer[_ob_i0] = CORBA_string_dup((*v)[_ob_i0]);
    }
    any.replace(_tc_LinkNameSeq, p, false, v, &OBAnyContentDestroyerInstance_LinkNameSeq);
}

void
operator<<=(CORBA::Any& any, const LinkNameSeq& v)
{
    _OBE_C_CORBA_sequence_string* p = (_OBE_C_CORBA_sequence_string*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_LinkNameSeq->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence_string));
    (*p)._length = v.length();
    (*p)._maximum = v.length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (CORBA_char**)OBEC_allocate_buffer(NULL, sizeof(CORBA_char*) * (*p)._length, (*p)._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
    {
        (*p)._buffer[_ob_i0] = CORBA_string_dup(v[_ob_i0]);
    }
    any.replace(_tc_LinkNameSeq, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const LinkNameSeq*& v)
{
    if (!any.check_type(_tc_LinkNameSeq))
        return false;

    v = (const LinkNameSeq*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_CORBA_sequence_string* p = (_OBE_C_CORBA_sequence_string*)any.value();
        assert(p != NULL);
        LinkNameSeq* val = new LinkNameSeq;
        (*val).length((*p)._length);

        for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
        {
            (*val)[_ob_i0] = CORBA::string_dup((*p)._buffer[_ob_i0]);
        }
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_LinkNameSeq);
        v = val;
    }

    return true;
}

//
// IDL:Transform:1.0
//
void
Transform::_OB_marshal(
    OBEC_OutputStreamImpl* _ob_out,
    CORBA_Environment* _ob_cev
) const
{
    OBEC_OutputStreamImpl_write_float(_ob_out, posX, _ob_cev);
    OBEC_OutputStreamImpl_write_float(_ob_out, posY, _ob_cev);
    OBEC_OutputStreamImpl_write_float(_ob_out, posZ, _ob_cev);
    OBEC_OutputStreamImpl_write_float(_ob_out, axisX, _ob_cev);
    OBEC_OutputStreamImpl_write_float(_ob_out, axisY, _ob_cev);
    OBEC_OutputStreamImpl_write_float(_ob_out, axisZ, _ob_cev);
    OBEC_OutputStreamImpl_write_float(_ob_out, angle, _ob_cev);
}

void
Transform::_OB_unmarshal(
    Transform& _ob_v,
    OBEC_InputStreamImpl* _ob_in,
    CORBA_Environment* _ob_cev
)
{
    _ob_v.posX = OBEC_InputStreamImpl_read_float(_ob_in, _ob_cev);
    _ob_v.posY = OBEC_InputStreamImpl_read_float(_ob_in, _ob_cev);
    _ob_v.posZ = OBEC_InputStreamImpl_read_float(_ob_in, _ob_cev);
    _ob_v.axisX = OBEC_InputStreamImpl_read_float(_ob_in, _ob_cev);
    _ob_v.axisY = OBEC_InputStreamImpl_read_float(_ob_in, _ob_cev);
    _ob_v.axisZ = OBEC_InputStreamImpl_read_float(_ob_in, _ob_cev);
    _ob_v.angle = OBEC_InputStreamImpl_read_float(_ob_in, _ob_cev);
}

void
Transform::_OB_convert_to(
    void* _ob_data
) const
{
    _OBE_C_Transform* _ob_p = (_OBE_C_Transform*)_ob_data;
    _ob_p->posX = posX;
    _ob_p->posY = posY;
    _ob_p->posZ = posZ;
    _ob_p->axisX = axisX;
    _ob_p->axisY = axisY;
    _ob_p->axisZ = axisZ;
    _ob_p->angle = angle;
}

void
Transform::_OB_convert_from(
    Transform& _ob_v,
    void* _ob_data
)
{
    _OBE_C_Transform* _ob_p = (_OBE_C_Transform*)_ob_data;
    _ob_v.posX = _ob_p->posX;
    _ob_v.posY = _ob_p->posY;
    _ob_v.posZ = _ob_p->posZ;
    _ob_v.axisX = _ob_p->axisX;
    _ob_v.axisY = _ob_p->axisY;
    _ob_v.axisZ = _ob_p->axisZ;
    _ob_v.angle = _ob_p->angle;
}

static CORBA::AnyContentDestroyerDelete<Transform> OBAnyContentDestroyerInstance_Transform;

void
operator<<=(CORBA::Any& any, Transform* v)
{
    _OBE_C_Transform* p = (_OBE_C_Transform*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_Transform->_OB_impl_nodup(), sizeof(_OBE_C_Transform));
    (*v)._OB_convert_to(&(*p));
    any.replace(_tc_Transform, p, false, v, &OBAnyContentDestroyerInstance_Transform);
}

void
operator<<=(CORBA::Any& any, const Transform& v)
{
    _OBE_C_Transform* p = (_OBE_C_Transform*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_Transform->_OB_impl_nodup(), sizeof(_OBE_C_Transform));
    v._OB_convert_to(&(*p));
    any.replace(_tc_Transform, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const Transform*& v)
{
    if (!any.check_type(_tc_Transform))
        return 0;

    v = (const Transform*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_Transform* p = (_OBE_C_Transform*)any.value();
        assert(p != NULL);
        Transform* val = new Transform;
        Transform::_OB_convert_from((*val), &(*p));
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_Transform);
        v = val;
    }

    return 1;
}

//
// IDL:TransformQuaternion:1.0
//
void
TransformQuaternion::_OB_marshal(
    OBEC_OutputStreamImpl* _ob_out,
    CORBA_Environment* _ob_cev
) const
{
    OBEC_OutputStreamImpl_write_float(_ob_out, px, _ob_cev);
    OBEC_OutputStreamImpl_write_float(_ob_out, py, _ob_cev);
    OBEC_OutputStreamImpl_write_float(_ob_out, pz, _ob_cev);
    OBEC_OutputStreamImpl_write_float(_ob_out, qx, _ob_cev);
    OBEC_OutputStreamImpl_write_float(_ob_out, qy, _ob_cev);
    OBEC_OutputStreamImpl_write_float(_ob_out, qz, _ob_cev);
    OBEC_OutputStreamImpl_write_float(_ob_out, qw, _ob_cev);
}

void
TransformQuaternion::_OB_unmarshal(
    TransformQuaternion& _ob_v,
    OBEC_InputStreamImpl* _ob_in,
    CORBA_Environment* _ob_cev
)
{
    _ob_v.px = OBEC_InputStreamImpl_read_float(_ob_in, _ob_cev);
    _ob_v.py = OBEC_InputStreamImpl_read_float(_ob_in, _ob_cev);
    _ob_v.pz = OBEC_InputStreamImpl_read_float(_ob_in, _ob_cev);
    _ob_v.qx = OBEC_InputStreamImpl_read_float(_ob_in, _ob_cev);
    _ob_v.qy = OBEC_InputStreamImpl_read_float(_ob_in, _ob_cev);
    _ob_v.qz = OBEC_InputStreamImpl_read_float(_ob_in, _ob_cev);
    _ob_v.qw = OBEC_InputStreamImpl_read_float(_ob_in, _ob_cev);
}

void
TransformQuaternion::_OB_convert_to(
    void* _ob_data
) const
{
    _OBE_C_TransformQuaternion* _ob_p = (_OBE_C_TransformQuaternion*)_ob_data;
    _ob_p->px = px;
    _ob_p->py = py;
    _ob_p->pz = pz;
    _ob_p->qx = qx;
    _ob_p->qy = qy;
    _ob_p->qz = qz;
    _ob_p->qw = qw;
}

void
TransformQuaternion::_OB_convert_from(
    TransformQuaternion& _ob_v,
    void* _ob_data
)
{
    _OBE_C_TransformQuaternion* _ob_p = (_OBE_C_TransformQuaternion*)_ob_data;
    _ob_v.px = _ob_p->px;
    _ob_v.py = _ob_p->py;
    _ob_v.pz = _ob_p->pz;
    _ob_v.qx = _ob_p->qx;
    _ob_v.qy = _ob_p->qy;
    _ob_v.qz = _ob_p->qz;
    _ob_v.qw = _ob_p->qw;
}

static CORBA::AnyContentDestroyerDelete<TransformQuaternion> OBAnyContentDestroyerInstance_TransformQuaternion;

void
operator<<=(CORBA::Any& any, TransformQuaternion* v)
{
    _OBE_C_TransformQuaternion* p = (_OBE_C_TransformQuaternion*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_TransformQuaternion->_OB_impl_nodup(), sizeof(_OBE_C_TransformQuaternion));
    (*v)._OB_convert_to(&(*p));
    any.replace(_tc_TransformQuaternion, p, false, v, &OBAnyContentDestroyerInstance_TransformQuaternion);
}

void
operator<<=(CORBA::Any& any, const TransformQuaternion& v)
{
    _OBE_C_TransformQuaternion* p = (_OBE_C_TransformQuaternion*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_TransformQuaternion->_OB_impl_nodup(), sizeof(_OBE_C_TransformQuaternion));
    v._OB_convert_to(&(*p));
    any.replace(_tc_TransformQuaternion, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const TransformQuaternion*& v)
{
    if (!any.check_type(_tc_TransformQuaternion))
        return 0;

    v = (const TransformQuaternion*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_TransformQuaternion* p = (_OBE_C_TransformQuaternion*)any.value();
        assert(p != NULL);
        TransformQuaternion* val = new TransformQuaternion;
        TransformQuaternion::_OB_convert_from((*val), &(*p));
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_TransformQuaternion);
        v = val;
    }

    return 1;
}

//
// IDL:LinkInfo:1.0
//
#ifdef OB_PURIFY_CLEAN
LinkInfo::LinkInfo()
{
    memset(&JointValue, 0, sizeof(JointValue));
    memset(&JointVel, 0, sizeof(JointVel));
    memset(&JointAcc, 0, sizeof(JointAcc));
}
#endif

LinkInfo::LinkInfo(const LinkInfo& _ob_a)
    : name(_ob_a.name),
      pos(_ob_a.pos),
      rot(_ob_a.rot),
      JointValue(_ob_a.JointValue),
      JointVel(_ob_a.JointVel),
      JointAcc(_ob_a.JointAcc),
      jpos(_ob_a.jpos),
      jatt(_ob_a.jatt),
      vel(_ob_a.vel),
      acc(_ob_a.acc)
{
}

LinkInfo&
LinkInfo::operator=(const LinkInfo& _ob_a)
{
    if(this != &_ob_a)
    {
        name = _ob_a.name;
        pos = _ob_a.pos;
        rot = _ob_a.rot;
        JointValue = _ob_a.JointValue;
        JointVel = _ob_a.JointVel;
        JointAcc = _ob_a.JointAcc;
        jpos = _ob_a.jpos;
        jatt = _ob_a.jatt;
        vel = _ob_a.vel;
        acc = _ob_a.acc;
    }
    return *this;
}

void
LinkInfo::_OB_marshal(
    OBEC_OutputStreamImpl* _ob_out,
    CORBA_Environment* _ob_cev
) const
{
    OBEC_OutputStreamImpl_write_string(_ob_out, name, _ob_cev);
    CORBA::ULong _ob_len0 = pos.length();
    OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len0, _ob_cev);
    OBEC_OutputStreamImpl_write_double_array(_ob_out, pos.get_buffer(), _ob_len0, _ob_cev);
    CORBA::ULong _ob_len1 = rot.length();
    OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len1, _ob_cev);
    OBEC_OutputStreamImpl_write_double_array(_ob_out, rot.get_buffer(), _ob_len1, _ob_cev);
    OBEC_OutputStreamImpl_write_double(_ob_out, JointValue, _ob_cev);
    OBEC_OutputStreamImpl_write_double(_ob_out, JointVel, _ob_cev);
    OBEC_OutputStreamImpl_write_double(_ob_out, JointAcc, _ob_cev);
    CORBA::ULong _ob_len2 = jpos.length();
    OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len2, _ob_cev);
    OBEC_OutputStreamImpl_write_double_array(_ob_out, jpos.get_buffer(), _ob_len2, _ob_cev);
    CORBA::ULong _ob_len3 = jatt.length();
    OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len3, _ob_cev);
    OBEC_OutputStreamImpl_write_double_array(_ob_out, jatt.get_buffer(), _ob_len3, _ob_cev);
    CORBA::ULong _ob_len4 = vel.length();
    OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len4, _ob_cev);
    OBEC_OutputStreamImpl_write_double_array(_ob_out, vel.get_buffer(), _ob_len4, _ob_cev);
    CORBA::ULong _ob_len5 = acc.length();
    OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len5, _ob_cev);
    OBEC_OutputStreamImpl_write_double_array(_ob_out, acc.get_buffer(), _ob_len5, _ob_cev);
}

void
LinkInfo::_OB_unmarshal(
    LinkInfo& _ob_v,
    OBEC_InputStreamImpl* _ob_in,
    CORBA_Environment* _ob_cev
)
{
    _ob_v.name = OBEC_InputStreamImpl_read_string(_ob_in, _ob_cev);
    CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.pos.length(_ob_len0);
    OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_v.pos.get_buffer(), _ob_len0, _ob_cev);
    CORBA::ULong _ob_len1 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.rot.length(_ob_len1);
    OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_v.rot.get_buffer(), _ob_len1, _ob_cev);
    _ob_v.JointValue = OBEC_InputStreamImpl_read_double(_ob_in, _ob_cev);
    _ob_v.JointVel = OBEC_InputStreamImpl_read_double(_ob_in, _ob_cev);
    _ob_v.JointAcc = OBEC_InputStreamImpl_read_double(_ob_in, _ob_cev);
    CORBA::ULong _ob_len2 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.jpos.length(_ob_len2);
    OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_v.jpos.get_buffer(), _ob_len2, _ob_cev);
    CORBA::ULong _ob_len3 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.jatt.length(_ob_len3);
    OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_v.jatt.get_buffer(), _ob_len3, _ob_cev);
    CORBA::ULong _ob_len4 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.vel.length(_ob_len4);
    OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_v.vel.get_buffer(), _ob_len4, _ob_cev);
    CORBA::ULong _ob_len5 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.acc.length(_ob_len5);
    OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_v.acc.get_buffer(), _ob_len5, _ob_cev);
}

void
LinkInfo::_OB_convert_to(
    void* _ob_data
) const
{
    _OBE_C_LinkInfo* _ob_p = (_OBE_C_LinkInfo*)_ob_data;
    _ob_p->name = CORBA_string_dup(name);
    _ob_p->pos._length = pos.length();
    _ob_p->pos._maximum = pos.length();
    _ob_p->pos._release = OBEC_TRUE;
    _ob_p->pos._buffer = (CORBA_double*)OBEC_allocate_buffer(NULL, sizeof(CORBA_double) * _ob_p->pos._length, _ob_p->pos._length, OBEC_FALSE);

    memcpy(_ob_p->pos._buffer, pos.get_buffer(), sizeof(CORBA_double) * _ob_p->pos._length);
    _ob_p->rot._length = rot.length();
    _ob_p->rot._maximum = rot.length();
    _ob_p->rot._release = OBEC_TRUE;
    _ob_p->rot._buffer = (CORBA_double*)OBEC_allocate_buffer(NULL, sizeof(CORBA_double) * _ob_p->rot._length, _ob_p->rot._length, OBEC_FALSE);

    memcpy(_ob_p->rot._buffer, rot.get_buffer(), sizeof(CORBA_double) * _ob_p->rot._length);
    _ob_p->JointValue = JointValue;
    _ob_p->JointVel = JointVel;
    _ob_p->JointAcc = JointAcc;
    _ob_p->jpos._length = jpos.length();
    _ob_p->jpos._maximum = jpos.length();
    _ob_p->jpos._release = OBEC_TRUE;
    _ob_p->jpos._buffer = (CORBA_double*)OBEC_allocate_buffer(NULL, sizeof(CORBA_double) * _ob_p->jpos._length, _ob_p->jpos._length, OBEC_FALSE);

    memcpy(_ob_p->jpos._buffer, jpos.get_buffer(), sizeof(CORBA_double) * _ob_p->jpos._length);
    _ob_p->jatt._length = jatt.length();
    _ob_p->jatt._maximum = jatt.length();
    _ob_p->jatt._release = OBEC_TRUE;
    _ob_p->jatt._buffer = (CORBA_double*)OBEC_allocate_buffer(NULL, sizeof(CORBA_double) * _ob_p->jatt._length, _ob_p->jatt._length, OBEC_FALSE);

    memcpy(_ob_p->jatt._buffer, jatt.get_buffer(), sizeof(CORBA_double) * _ob_p->jatt._length);
    _ob_p->vel._length = vel.length();
    _ob_p->vel._maximum = vel.length();
    _ob_p->vel._release = OBEC_TRUE;
    _ob_p->vel._buffer = (CORBA_double*)OBEC_allocate_buffer(NULL, sizeof(CORBA_double) * _ob_p->vel._length, _ob_p->vel._length, OBEC_FALSE);

    memcpy(_ob_p->vel._buffer, vel.get_buffer(), sizeof(CORBA_double) * _ob_p->vel._length);
    _ob_p->acc._length = acc.length();
    _ob_p->acc._maximum = acc.length();
    _ob_p->acc._release = OBEC_TRUE;
    _ob_p->acc._buffer = (CORBA_double*)OBEC_allocate_buffer(NULL, sizeof(CORBA_double) * _ob_p->acc._length, _ob_p->acc._length, OBEC_FALSE);

    memcpy(_ob_p->acc._buffer, acc.get_buffer(), sizeof(CORBA_double) * _ob_p->acc._length);
}

void
LinkInfo::_OB_convert_from(
    LinkInfo& _ob_v,
    void* _ob_data
)
{
    _OBE_C_LinkInfo* _ob_p = (_OBE_C_LinkInfo*)_ob_data;
    _ob_v.name = CORBA::string_dup(_ob_p->name);
    _ob_v.pos.length(_ob_p->pos._length);

    memcpy(_ob_v.pos.get_buffer(), _ob_p->pos._buffer, sizeof(CORBA_double) * _ob_p->pos._length);
    _ob_v.rot.length(_ob_p->rot._length);

    memcpy(_ob_v.rot.get_buffer(), _ob_p->rot._buffer, sizeof(CORBA_double) * _ob_p->rot._length);
    _ob_v.JointValue = _ob_p->JointValue;
    _ob_v.JointVel = _ob_p->JointVel;
    _ob_v.JointAcc = _ob_p->JointAcc;
    _ob_v.jpos.length(_ob_p->jpos._length);

    memcpy(_ob_v.jpos.get_buffer(), _ob_p->jpos._buffer, sizeof(CORBA_double) * _ob_p->jpos._length);
    _ob_v.jatt.length(_ob_p->jatt._length);

    memcpy(_ob_v.jatt.get_buffer(), _ob_p->jatt._buffer, sizeof(CORBA_double) * _ob_p->jatt._length);
    _ob_v.vel.length(_ob_p->vel._length);

    memcpy(_ob_v.vel.get_buffer(), _ob_p->vel._buffer, sizeof(CORBA_double) * _ob_p->vel._length);
    _ob_v.acc.length(_ob_p->acc._length);

    memcpy(_ob_v.acc.get_buffer(), _ob_p->acc._buffer, sizeof(CORBA_double) * _ob_p->acc._length);
}

static CORBA::AnyContentDestroyerDelete<LinkInfo> OBAnyContentDestroyerInstance_LinkInfo;

void
operator<<=(CORBA::Any& any, LinkInfo* v)
{
    _OBE_C_LinkInfo* p = (_OBE_C_LinkInfo*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_LinkInfo->_OB_impl_nodup(), sizeof(_OBE_C_LinkInfo));
    (*v)._OB_convert_to(&(*p));
    any.replace(_tc_LinkInfo, p, false, v, &OBAnyContentDestroyerInstance_LinkInfo);
}

void
operator<<=(CORBA::Any& any, const LinkInfo& v)
{
    _OBE_C_LinkInfo* p = (_OBE_C_LinkInfo*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_LinkInfo->_OB_impl_nodup(), sizeof(_OBE_C_LinkInfo));
    v._OB_convert_to(&(*p));
    any.replace(_tc_LinkInfo, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const LinkInfo*& v)
{
    if (!any.check_type(_tc_LinkInfo))
        return 0;

    v = (const LinkInfo*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_LinkInfo* p = (_OBE_C_LinkInfo*)any.value();
        assert(p != NULL);
        LinkInfo* val = new LinkInfo;
        LinkInfo::_OB_convert_from((*val), &(*p));
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_LinkInfo);
        v = val;
    }

    return 1;
}

//
// IDL:LinkValue:1.0
//
LinkValue::LinkValue(const LinkValue& _ob_a)
    : name(_ob_a.name),
      param(_ob_a.param),
      data(_ob_a.data)
{
}

LinkValue&
LinkValue::operator=(const LinkValue& _ob_a)
{
    if(this != &_ob_a)
    {
        name = _ob_a.name;
        param = _ob_a.param;
        data = _ob_a.data;
    }
    return *this;
}

void
LinkValue::_OB_marshal(
    OBEC_OutputStreamImpl* _ob_out,
    CORBA_Environment* _ob_cev
) const
{
    OBEC_OutputStreamImpl_write_string(_ob_out, name, _ob_cev);
    OBEC_OutputStreamImpl_write_string(_ob_out, param, _ob_cev);
    CORBA::ULong _ob_len0 = data.length();
    OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len0, _ob_cev);
    OBEC_OutputStreamImpl_write_double_array(_ob_out, data.get_buffer(), _ob_len0, _ob_cev);
}

void
LinkValue::_OB_unmarshal(
    LinkValue& _ob_v,
    OBEC_InputStreamImpl* _ob_in,
    CORBA_Environment* _ob_cev
)
{
    _ob_v.name = OBEC_InputStreamImpl_read_string(_ob_in, _ob_cev);
    _ob_v.param = OBEC_InputStreamImpl_read_string(_ob_in, _ob_cev);
    CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.data.length(_ob_len0);
    OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_v.data.get_buffer(), _ob_len0, _ob_cev);
}

void
LinkValue::_OB_convert_to(
    void* _ob_data
) const
{
    _OBE_C_LinkValue* _ob_p = (_OBE_C_LinkValue*)_ob_data;
    _ob_p->name = CORBA_string_dup(name);
    _ob_p->param = CORBA_string_dup(param);
    _ob_p->data._length = data.length();
    _ob_p->data._maximum = data.length();
    _ob_p->data._release = OBEC_TRUE;
    _ob_p->data._buffer = (CORBA_double*)OBEC_allocate_buffer(NULL, sizeof(CORBA_double) * _ob_p->data._length, _ob_p->data._length, OBEC_FALSE);

    memcpy(_ob_p->data._buffer, data.get_buffer(), sizeof(CORBA_double) * _ob_p->data._length);
}

void
LinkValue::_OB_convert_from(
    LinkValue& _ob_v,
    void* _ob_data
)
{
    _OBE_C_LinkValue* _ob_p = (_OBE_C_LinkValue*)_ob_data;
    _ob_v.name = CORBA::string_dup(_ob_p->name);
    _ob_v.param = CORBA::string_dup(_ob_p->param);
    _ob_v.data.length(_ob_p->data._length);

    memcpy(_ob_v.data.get_buffer(), _ob_p->data._buffer, sizeof(CORBA_double) * _ob_p->data._length);
}

static CORBA::AnyContentDestroyerDelete<LinkValue> OBAnyContentDestroyerInstance_LinkValue;

void
operator<<=(CORBA::Any& any, LinkValue* v)
{
    _OBE_C_LinkValue* p = (_OBE_C_LinkValue*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_LinkValue->_OB_impl_nodup(), sizeof(_OBE_C_LinkValue));
    (*v)._OB_convert_to(&(*p));
    any.replace(_tc_LinkValue, p, false, v, &OBAnyContentDestroyerInstance_LinkValue);
}

void
operator<<=(CORBA::Any& any, const LinkValue& v)
{
    _OBE_C_LinkValue* p = (_OBE_C_LinkValue*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_LinkValue->_OB_impl_nodup(), sizeof(_OBE_C_LinkValue));
    v._OB_convert_to(&(*p));
    any.replace(_tc_LinkValue, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const LinkValue*& v)
{
    if (!any.check_type(_tc_LinkValue))
        return 0;

    v = (const LinkValue*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_LinkValue* p = (_OBE_C_LinkValue*)any.value();
        assert(p != NULL);
        LinkValue* val = new LinkValue;
        LinkValue::_OB_convert_from((*val), &(*p));
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_LinkValue);
        v = val;
    }

    return 1;
}

//
// IDL:LinkValueSeq:1.0
//
static CORBA::AnyContentDestroyerDelete<LinkValueSeq> OBAnyContentDestroyerInstance_LinkValueSeq;

void
operator<<=(CORBA::Any& any, LinkValueSeq* v)
{
    _OBE_C_CORBA_sequence__OBE_C_LinkValue* p = (_OBE_C_CORBA_sequence__OBE_C_LinkValue*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_LinkValueSeq->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence__OBE_C_LinkValue));
    (*p)._length = (*v).length();
    (*p)._maximum = (*v).length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (_OBE_C_LinkValue*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_LinkValue) * (*p)._length, (*p)._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
    {
        (*v)[_ob_i0]._OB_convert_to(&(*p)._buffer[_ob_i0]);
    }
    any.replace(_tc_LinkValueSeq, p, false, v, &OBAnyContentDestroyerInstance_LinkValueSeq);
}

void
operator<<=(CORBA::Any& any, const LinkValueSeq& v)
{
    _OBE_C_CORBA_sequence__OBE_C_LinkValue* p = (_OBE_C_CORBA_sequence__OBE_C_LinkValue*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_LinkValueSeq->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence__OBE_C_LinkValue));
    (*p)._length = v.length();
    (*p)._maximum = v.length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (_OBE_C_LinkValue*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_LinkValue) * (*p)._length, (*p)._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
    {
        v[_ob_i0]._OB_convert_to(&(*p)._buffer[_ob_i0]);
    }
    any.replace(_tc_LinkValueSeq, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const LinkValueSeq*& v)
{
    if (!any.check_type(_tc_LinkValueSeq))
        return false;

    v = (const LinkValueSeq*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_CORBA_sequence__OBE_C_LinkValue* p = (_OBE_C_CORBA_sequence__OBE_C_LinkValue*)any.value();
        assert(p != NULL);
        LinkValueSeq* val = new LinkValueSeq;
        (*val).length((*p)._length);

        for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
        {
            LinkValue::_OB_convert_from((*val)[_ob_i0], &(*p)._buffer[_ob_i0]);
        }
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_LinkValueSeq);
        v = val;
    }

    return true;
}

//
// IDL:LinkInfoSeq:1.0
//
static CORBA::AnyContentDestroyerDelete<LinkInfoSeq> OBAnyContentDestroyerInstance_LinkInfoSeq;

void
operator<<=(CORBA::Any& any, LinkInfoSeq* v)
{
    _OBE_C_CORBA_sequence__OBE_C_LinkInfo* p = (_OBE_C_CORBA_sequence__OBE_C_LinkInfo*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_LinkInfoSeq->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence__OBE_C_LinkInfo));
    (*p)._length = (*v).length();
    (*p)._maximum = (*v).length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (_OBE_C_LinkInfo*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_LinkInfo) * (*p)._length, (*p)._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
    {
        (*v)[_ob_i0]._OB_convert_to(&(*p)._buffer[_ob_i0]);
    }
    any.replace(_tc_LinkInfoSeq, p, false, v, &OBAnyContentDestroyerInstance_LinkInfoSeq);
}

void
operator<<=(CORBA::Any& any, const LinkInfoSeq& v)
{
    _OBE_C_CORBA_sequence__OBE_C_LinkInfo* p = (_OBE_C_CORBA_sequence__OBE_C_LinkInfo*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_LinkInfoSeq->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence__OBE_C_LinkInfo));
    (*p)._length = v.length();
    (*p)._maximum = v.length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (_OBE_C_LinkInfo*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_LinkInfo) * (*p)._length, (*p)._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
    {
        v[_ob_i0]._OB_convert_to(&(*p)._buffer[_ob_i0]);
    }
    any.replace(_tc_LinkInfoSeq, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const LinkInfoSeq*& v)
{
    if (!any.check_type(_tc_LinkInfoSeq))
        return false;

    v = (const LinkInfoSeq*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_CORBA_sequence__OBE_C_LinkInfo* p = (_OBE_C_CORBA_sequence__OBE_C_LinkInfo*)any.value();
        assert(p != NULL);
        LinkInfoSeq* val = new LinkInfoSeq;
        (*val).length((*p)._length);

        for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
        {
            LinkInfo::_OB_convert_from((*val)[_ob_i0], &(*p)._buffer[_ob_i0]);
        }
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_LinkInfoSeq);
        v = val;
    }

    return true;
}

//
// IDL:Vector3:1.0
//
static CORBA::AnyContentDestroyerDeleteArray< CORBA::Float > OBAnyContentDestroyerInstance_Vector3;

void
operator<<=(CORBA::Any& any, const Vector3_forany& r)
{
    const Vector3_slice* s = r.in();
    CORBA_float* p = (CORBA_float*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_Vector3->_OB_impl_nodup(), sizeof(CORBA_float) * 3);
    memcpy(p, s, sizeof(CORBA_float) * 3);

    if (r.nocopy())
        any.replace(_tc_Vector3, p, false, (void*)s, &OBAnyContentDestroyerInstance_Vector3);
    else
        any.replace(_tc_Vector3, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, Vector3_forany& r)
{
    if (!any.check_type(_tc_Vector3))
        return false;

    Vector3_slice* s = (Vector3_slice*)any.cpp_value();
    if (s != 0)
        r = s;
    else
    {
        CORBA_float* p = (CORBA_float*)any.value();
        assert(p != 0);
        Vector3_slice* s = Vector3_alloc();
        memcpy(s, p, sizeof(CORBA_float) * 3);
        ((CORBA::Any&)any).cpp_value(s, &OBAnyContentDestroyerInstance_Vector3);
        r = s;
    }

    return true;
}

//
// IDL:CollisionData:1.0
//
void
CollisionData::_OB_marshal(
    OBEC_OutputStreamImpl* _ob_out,
    CORBA_Environment* _ob_cev
) const
{
    OBEC_OutputStreamImpl_write_float_array(_ob_out, (const CORBA::Float*)coord, 3, _ob_cev);
    OBEC_OutputStreamImpl_write_float_array(_ob_out, (const CORBA::Float*)normal, 3, _ob_cev);
    OBEC_OutputStreamImpl_write_double(_ob_out, idepth, _ob_cev);
}

void
CollisionData::_OB_unmarshal(
    CollisionData& _ob_v,
    OBEC_InputStreamImpl* _ob_in,
    CORBA_Environment* _ob_cev
)
{
    OBEC_InputStreamImpl_read_float_array(_ob_in, (CORBA::Float*)_ob_v.coord, 3, _ob_cev);
    OBEC_InputStreamImpl_read_float_array(_ob_in, (CORBA::Float*)_ob_v.normal, 3, _ob_cev);
    _ob_v.idepth = OBEC_InputStreamImpl_read_double(_ob_in, _ob_cev);
}

void
CollisionData::_OB_convert_to(
    void* _ob_data
) const
{
    _OBE_C_CollisionData* _ob_p = (_OBE_C_CollisionData*)_ob_data;
    memcpy(_ob_p->coord, coord, sizeof(CORBA_float) * 3);
    memcpy(_ob_p->normal, normal, sizeof(CORBA_float) * 3);
    _ob_p->idepth = idepth;
}

void
CollisionData::_OB_convert_from(
    CollisionData& _ob_v,
    void* _ob_data
)
{
    _OBE_C_CollisionData* _ob_p = (_OBE_C_CollisionData*)_ob_data;
    memcpy(_ob_v.coord, _ob_p->coord, sizeof(CORBA_float) * 3);
    memcpy(_ob_v.normal, _ob_p->normal, sizeof(CORBA_float) * 3);
    _ob_v.idepth = _ob_p->idepth;
}

static CORBA::AnyContentDestroyerDelete<CollisionData> OBAnyContentDestroyerInstance_CollisionData;

void
operator<<=(CORBA::Any& any, CollisionData* v)
{
    _OBE_C_CollisionData* p = (_OBE_C_CollisionData*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_CollisionData->_OB_impl_nodup(), sizeof(_OBE_C_CollisionData));
    (*v)._OB_convert_to(&(*p));
    any.replace(_tc_CollisionData, p, false, v, &OBAnyContentDestroyerInstance_CollisionData);
}

void
operator<<=(CORBA::Any& any, const CollisionData& v)
{
    _OBE_C_CollisionData* p = (_OBE_C_CollisionData*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_CollisionData->_OB_impl_nodup(), sizeof(_OBE_C_CollisionData));
    v._OB_convert_to(&(*p));
    any.replace(_tc_CollisionData, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CollisionData*& v)
{
    if (!any.check_type(_tc_CollisionData))
        return 0;

    v = (const CollisionData*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_CollisionData* p = (_OBE_C_CollisionData*)any.value();
        assert(p != NULL);
        CollisionData* val = new CollisionData;
        CollisionData::_OB_convert_from((*val), &(*p));
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_CollisionData);
        v = val;
    }

    return 1;
}

//
// IDL:CollisionDataSeq:1.0
//
static CORBA::AnyContentDestroyerDelete<CollisionDataSeq> OBAnyContentDestroyerInstance_CollisionDataSeq;

void
operator<<=(CORBA::Any& any, CollisionDataSeq* v)
{
    _OBE_C_CORBA_sequence__OBE_C_CollisionData* p = (_OBE_C_CORBA_sequence__OBE_C_CollisionData*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_CollisionDataSeq->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence__OBE_C_CollisionData));
    (*p)._length = (*v).length();
    (*p)._maximum = (*v).length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (_OBE_C_CollisionData*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_CollisionData) * (*p)._length, (*p)._length, OBEC_FALSE);

    memcpy((*p)._buffer, (*v).get_buffer(), sizeof(_OBE_C_CollisionData) * (*p)._length);
    any.replace(_tc_CollisionDataSeq, p, false, v, &OBAnyContentDestroyerInstance_CollisionDataSeq);
}

void
operator<<=(CORBA::Any& any, const CollisionDataSeq& v)
{
    _OBE_C_CORBA_sequence__OBE_C_CollisionData* p = (_OBE_C_CORBA_sequence__OBE_C_CollisionData*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_CollisionDataSeq->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence__OBE_C_CollisionData));
    (*p)._length = v.length();
    (*p)._maximum = v.length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (_OBE_C_CollisionData*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_CollisionData) * (*p)._length, (*p)._length, OBEC_FALSE);

    memcpy((*p)._buffer, v.get_buffer(), sizeof(_OBE_C_CollisionData) * (*p)._length);
    any.replace(_tc_CollisionDataSeq, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const CollisionDataSeq*& v)
{
    if (!any.check_type(_tc_CollisionDataSeq))
        return false;

    v = (const CollisionDataSeq*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_CORBA_sequence__OBE_C_CollisionData* p = (_OBE_C_CORBA_sequence__OBE_C_CollisionData*)any.value();
        assert(p != NULL);
        CollisionDataSeq* val = new CollisionDataSeq;
        (*val).length((*p)._length);

        memcpy((*val).get_buffer(), (*p)._buffer, sizeof(_OBE_C_CollisionData) * (*p)._length);
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_CollisionDataSeq);
        v = val;
    }

    return true;
}

//
// IDL:WorldState:1.0
//
#ifdef OB_PURIFY_CLEAN
WorldState::WorldState()
{
    memset(&time, 0, sizeof(time));
}
#endif

WorldState::WorldState(const WorldState& _ob_a)
    : time(_ob_a.time),
      linkinfo(_ob_a.linkinfo),
      collision(_ob_a.collision)
{
}

WorldState&
WorldState::operator=(const WorldState& _ob_a)
{
    if(this != &_ob_a)
    {
        time = _ob_a.time;
        linkinfo = _ob_a.linkinfo;
        collision = _ob_a.collision;
    }
    return *this;
}

void
WorldState::_OB_marshal(
    OBEC_OutputStreamImpl* _ob_out,
    CORBA_Environment* _ob_cev
) const
{
    OBEC_OutputStreamImpl_write_double(_ob_out, time, _ob_cev);
    CORBA::ULong _ob_len0 = linkinfo.length();
    OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len0, _ob_cev);
    ::LinkInfo const * _ob_buf0 = linkinfo.get_buffer();
    for(CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
    {
        _ob_buf0[_ob_i0]._OB_marshal(_ob_out, _ob_cev);
    }
    CORBA::ULong _ob_len1 = collision.length();
    OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len1, _ob_cev);
    ::CollisionData const * _ob_buf1 = collision.get_buffer();
    for(CORBA::ULong _ob_i1 = 0 ; _ob_i1 < _ob_len1 ; _ob_i1++)
    {
        _ob_buf1[_ob_i1]._OB_marshal(_ob_out, _ob_cev);
    }
}

void
WorldState::_OB_unmarshal(
    WorldState& _ob_v,
    OBEC_InputStreamImpl* _ob_in,
    CORBA_Environment* _ob_cev
)
{
    _ob_v.time = OBEC_InputStreamImpl_read_double(_ob_in, _ob_cev);
    CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.linkinfo.length(_ob_len0);
    ::LinkInfo * _ob_buf0 = _ob_v.linkinfo.get_buffer();
    for(CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
    {
        ::LinkInfo::_OB_unmarshal(_ob_buf0[_ob_i0], _ob_in, _ob_cev);
    }
    CORBA::ULong _ob_len1 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.collision.length(_ob_len1);
    ::CollisionData * _ob_buf1 = _ob_v.collision.get_buffer();
    for(CORBA::ULong _ob_i1 = 0 ; _ob_i1 < _ob_len1 ; _ob_i1++)
    {
        ::CollisionData::_OB_unmarshal(_ob_buf1[_ob_i1], _ob_in, _ob_cev);
    }
}

void
WorldState::_OB_convert_to(
    void* _ob_data
) const
{
    _OBE_C_WorldState* _ob_p = (_OBE_C_WorldState*)_ob_data;
    _ob_p->time = time;
    _ob_p->linkinfo._length = linkinfo.length();
    _ob_p->linkinfo._maximum = linkinfo.length();
    _ob_p->linkinfo._release = OBEC_TRUE;
    _ob_p->linkinfo._buffer = (_OBE_C_LinkInfo*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_LinkInfo) * _ob_p->linkinfo._length, _ob_p->linkinfo._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i1 = 0; _ob_i1 < _ob_p->linkinfo._length; _ob_i1++)
    {
        linkinfo[_ob_i1]._OB_convert_to(&_ob_p->linkinfo._buffer[_ob_i1]);
    }
    _ob_p->collision._length = collision.length();
    _ob_p->collision._maximum = collision.length();
    _ob_p->collision._release = OBEC_TRUE;
    _ob_p->collision._buffer = (_OBE_C_CollisionData*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_CollisionData) * _ob_p->collision._length, _ob_p->collision._length, OBEC_FALSE);

    memcpy(_ob_p->collision._buffer, collision.get_buffer(), sizeof(_OBE_C_CollisionData) * _ob_p->collision._length);
}

void
WorldState::_OB_convert_from(
    WorldState& _ob_v,
    void* _ob_data
)
{
    _OBE_C_WorldState* _ob_p = (_OBE_C_WorldState*)_ob_data;
    _ob_v.time = _ob_p->time;
    _ob_v.linkinfo.length(_ob_p->linkinfo._length);

    for (CORBA::ULong _ob_i1 = 0; _ob_i1 < _ob_p->linkinfo._length; _ob_i1++)
    {
        LinkInfo::_OB_convert_from(_ob_v.linkinfo[_ob_i1], &_ob_p->linkinfo._buffer[_ob_i1]);
    }
    _ob_v.collision.length(_ob_p->collision._length);

    memcpy(_ob_v.collision.get_buffer(), _ob_p->collision._buffer, sizeof(_OBE_C_CollisionData) * _ob_p->collision._length);
}

static CORBA::AnyContentDestroyerDelete<WorldState> OBAnyContentDestroyerInstance_WorldState;

void
operator<<=(CORBA::Any& any, WorldState* v)
{
    _OBE_C_WorldState* p = (_OBE_C_WorldState*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_WorldState->_OB_impl_nodup(), sizeof(_OBE_C_WorldState));
    (*v)._OB_convert_to(&(*p));
    any.replace(_tc_WorldState, p, false, v, &OBAnyContentDestroyerInstance_WorldState);
}

void
operator<<=(CORBA::Any& any, const WorldState& v)
{
    _OBE_C_WorldState* p = (_OBE_C_WorldState*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_WorldState->_OB_impl_nodup(), sizeof(_OBE_C_WorldState));
    v._OB_convert_to(&(*p));
    any.replace(_tc_WorldState, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const WorldState*& v)
{
    if (!any.check_type(_tc_WorldState))
        return 0;

    v = (const WorldState*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_WorldState* p = (_OBE_C_WorldState*)any.value();
        assert(p != NULL);
        WorldState* val = new WorldState;
        WorldState::_OB_convert_from((*val), &(*p));
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_WorldState);
        v = val;
    }

    return 1;
}

//
// IDL:dsequence:1.0
//
static CORBA::AnyContentDestroyerDelete<dsequence> OBAnyContentDestroyerInstance_dsequence;

void
operator<<=(CORBA::Any& any, dsequence* v)
{
    _OBE_C_CORBA_sequence_double* p = (_OBE_C_CORBA_sequence_double*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_dsequence->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence_double));
    (*p)._length = (*v).length();
    (*p)._maximum = (*v).length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (CORBA_double*)OBEC_allocate_buffer(NULL, sizeof(CORBA_double) * (*p)._length, (*p)._length, OBEC_FALSE);

    memcpy((*p)._buffer, (*v).get_buffer(), sizeof(CORBA_double) * (*p)._length);
    any.replace(_tc_dsequence, p, false, v, &OBAnyContentDestroyerInstance_dsequence);
}

void
operator<<=(CORBA::Any& any, const dsequence& v)
{
    _OBE_C_CORBA_sequence_double* p = (_OBE_C_CORBA_sequence_double*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_dsequence->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence_double));
    (*p)._length = v.length();
    (*p)._maximum = v.length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (CORBA_double*)OBEC_allocate_buffer(NULL, sizeof(CORBA_double) * (*p)._length, (*p)._length, OBEC_FALSE);

    memcpy((*p)._buffer, v.get_buffer(), sizeof(CORBA_double) * (*p)._length);
    any.replace(_tc_dsequence, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const dsequence*& v)
{
    if (!any.check_type(_tc_dsequence))
        return false;

    v = (const dsequence*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_CORBA_sequence_double* p = (_OBE_C_CORBA_sequence_double*)any.value();
        assert(p != NULL);
        dsequence* val = new dsequence;
        (*val).length((*p)._length);

        memcpy((*val).get_buffer(), (*p)._buffer, sizeof(CORBA_double) * (*p)._length);
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_dsequence);
        v = val;
    }

    return true;
}

//
// IDL:PixelFormat:1.0
//
void
operator<<=(CORBA::Any& any, PixelFormat v)
{
    CORBA_unsigned_long* p = (CORBA_unsigned_long*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_PixelFormat->_OB_impl_nodup(), sizeof(CORBA_unsigned_long)); 
    *p = (CORBA_unsigned_long)v;
    any.replace(_tc_PixelFormat, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, PixelFormat& v)
{
    if (!any.check_type(_tc_PixelFormat))
        return false;

    v = (PixelFormat)(*(CORBA_unsigned_long*)any.value());

    return true;
}

//
// IDL:ImageData:1.0
//
#ifdef OB_PURIFY_CLEAN
ImageData::ImageData()
{
    memset(&format, 0, sizeof(format));
    memset(&width, 0, sizeof(width));
    memset(&height, 0, sizeof(height));
}
#endif

ImageData::ImageData(const ImageData& _ob_a)
    : format(_ob_a.format),
      width(_ob_a.width),
      height(_ob_a.height),
      octetData(_ob_a.octetData),
      longData(_ob_a.longData),
      floatData(_ob_a.floatData)
{
}

ImageData&
ImageData::operator=(const ImageData& _ob_a)
{
    if(this != &_ob_a)
    {
        format = _ob_a.format;
        width = _ob_a.width;
        height = _ob_a.height;
        octetData = _ob_a.octetData;
        longData = _ob_a.longData;
        floatData = _ob_a.floatData;
    }
    return *this;
}

void
ImageData::_OB_marshal(
    OBEC_OutputStreamImpl* _ob_out,
    CORBA_Environment* _ob_cev
) const
{
    OBEC_OutputStreamImpl_write_ulong(_ob_out, (CORBA::ULong)format, _ob_cev);
    OBEC_OutputStreamImpl_write_long(_ob_out, width, _ob_cev);
    OBEC_OutputStreamImpl_write_long(_ob_out, height, _ob_cev);
    CORBA::ULong _ob_len0 = octetData.length();
    OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len0, _ob_cev);
    OBEC_OutputStreamImpl_write_octet_array(_ob_out, octetData.get_buffer(), _ob_len0, _ob_cev);
    CORBA::ULong _ob_len1 = longData.length();
    OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len1, _ob_cev);
    OBEC_OutputStreamImpl_write_long_array(_ob_out, longData.get_buffer(), _ob_len1, _ob_cev);
    CORBA::ULong _ob_len2 = floatData.length();
    OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len2, _ob_cev);
    OBEC_OutputStreamImpl_write_float_array(_ob_out, floatData.get_buffer(), _ob_len2, _ob_cev);
}

void
ImageData::_OB_unmarshal(
    ImageData& _ob_v,
    OBEC_InputStreamImpl* _ob_in,
    CORBA_Environment* _ob_cev
)
{
    _ob_v.format = (::PixelFormat)OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.width = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    _ob_v.height = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
    CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.octetData.length(_ob_len0);
    OBEC_InputStreamImpl_read_octet_array(_ob_in, _ob_v.octetData.get_buffer(), _ob_len0, _ob_cev);
    CORBA::ULong _ob_len1 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.longData.length(_ob_len1);
    OBEC_InputStreamImpl_read_long_array(_ob_in, _ob_v.longData.get_buffer(), _ob_len1, _ob_cev);
    CORBA::ULong _ob_len2 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.floatData.length(_ob_len2);
    OBEC_InputStreamImpl_read_float_array(_ob_in, _ob_v.floatData.get_buffer(), _ob_len2, _ob_cev);
}

void
ImageData::_OB_convert_to(
    void* _ob_data
) const
{
    _OBE_C_ImageData* _ob_p = (_OBE_C_ImageData*)_ob_data;
    _ob_p->format = (CORBA_unsigned_long)format;
    _ob_p->width = width;
    _ob_p->height = height;
    _ob_p->octetData._length = octetData.length();
    _ob_p->octetData._maximum = octetData.length();
    _ob_p->octetData._release = OBEC_TRUE;
    _ob_p->octetData._buffer = (CORBA_octet*)OBEC_allocate_buffer(NULL, sizeof(CORBA_octet) * _ob_p->octetData._length, _ob_p->octetData._length, OBEC_FALSE);

    memcpy(_ob_p->octetData._buffer, octetData.get_buffer(), sizeof(CORBA_octet) * _ob_p->octetData._length);
    _ob_p->longData._length = longData.length();
    _ob_p->longData._maximum = longData.length();
    _ob_p->longData._release = OBEC_TRUE;
    _ob_p->longData._buffer = (CORBA_long*)OBEC_allocate_buffer(NULL, sizeof(CORBA_long) * _ob_p->longData._length, _ob_p->longData._length, OBEC_FALSE);

    memcpy(_ob_p->longData._buffer, longData.get_buffer(), sizeof(CORBA_long) * _ob_p->longData._length);
    _ob_p->floatData._length = floatData.length();
    _ob_p->floatData._maximum = floatData.length();
    _ob_p->floatData._release = OBEC_TRUE;
    _ob_p->floatData._buffer = (CORBA_float*)OBEC_allocate_buffer(NULL, sizeof(CORBA_float) * _ob_p->floatData._length, _ob_p->floatData._length, OBEC_FALSE);

    memcpy(_ob_p->floatData._buffer, floatData.get_buffer(), sizeof(CORBA_float) * _ob_p->floatData._length);
}

void
ImageData::_OB_convert_from(
    ImageData& _ob_v,
    void* _ob_data
)
{
    _OBE_C_ImageData* _ob_p = (_OBE_C_ImageData*)_ob_data;
    _ob_v.format = (PixelFormat)_ob_p->format;
    _ob_v.width = _ob_p->width;
    _ob_v.height = _ob_p->height;
    _ob_v.octetData.length(_ob_p->octetData._length);

    memcpy(_ob_v.octetData.get_buffer(), _ob_p->octetData._buffer, sizeof(CORBA_octet) * _ob_p->octetData._length);
    _ob_v.longData.length(_ob_p->longData._length);

    memcpy(_ob_v.longData.get_buffer(), _ob_p->longData._buffer, sizeof(CORBA_long) * _ob_p->longData._length);
    _ob_v.floatData.length(_ob_p->floatData._length);

    memcpy(_ob_v.floatData.get_buffer(), _ob_p->floatData._buffer, sizeof(CORBA_float) * _ob_p->floatData._length);
}

static CORBA::AnyContentDestroyerDelete<ImageData> OBAnyContentDestroyerInstance_ImageData;

void
operator<<=(CORBA::Any& any, ImageData* v)
{
    _OBE_C_ImageData* p = (_OBE_C_ImageData*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_ImageData->_OB_impl_nodup(), sizeof(_OBE_C_ImageData));
    (*v)._OB_convert_to(&(*p));
    any.replace(_tc_ImageData, p, false, v, &OBAnyContentDestroyerInstance_ImageData);
}

void
operator<<=(CORBA::Any& any, const ImageData& v)
{
    _OBE_C_ImageData* p = (_OBE_C_ImageData*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_ImageData->_OB_impl_nodup(), sizeof(_OBE_C_ImageData));
    v._OB_convert_to(&(*p));
    any.replace(_tc_ImageData, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const ImageData*& v)
{
    if (!any.check_type(_tc_ImageData))
        return 0;

    v = (const ImageData*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_ImageData* p = (_OBE_C_ImageData*)any.value();
        assert(p != NULL);
        ImageData* val = new ImageData;
        ImageData::_OB_convert_from((*val), &(*p));
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_ImageData);
        v = val;
    }

    return 1;
}

//
// IDL:RobotState:1.0
//
RobotState::RobotState(const RobotState& _ob_a)
    : angle(_ob_a.angle),
      velocity(_ob_a.velocity),
      torque(_ob_a.torque),
      force(_ob_a.force),
      rate(_ob_a.rate),
      accel(_ob_a.accel),
      attitude(_ob_a.attitude),
      zmp(_ob_a.zmp),
      waistPos(_ob_a.waistPos),
      waistRpy(_ob_a.waistRpy),
      image(_ob_a.image),
      dio(_ob_a.dio)
{
}

RobotState&
RobotState::operator=(const RobotState& _ob_a)
{
    if(this != &_ob_a)
    {
        angle = _ob_a.angle;
        velocity = _ob_a.velocity;
        torque = _ob_a.torque;
        force = _ob_a.force;
        rate = _ob_a.rate;
        accel = _ob_a.accel;
        attitude = _ob_a.attitude;
        zmp = _ob_a.zmp;
        waistPos = _ob_a.waistPos;
        waistRpy = _ob_a.waistRpy;
        image = _ob_a.image;
        dio = _ob_a.dio;
    }
    return *this;
}

void
RobotState::_OB_marshal(
    OBEC_OutputStreamImpl* _ob_out,
    CORBA_Environment* _ob_cev
) const
{
    CORBA::ULong _ob_len0 = angle.length();
    OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len0, _ob_cev);
    OBEC_OutputStreamImpl_write_double_array(_ob_out, angle.get_buffer(), _ob_len0, _ob_cev);
    CORBA::ULong _ob_len1 = velocity.length();
    OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len1, _ob_cev);
    OBEC_OutputStreamImpl_write_double_array(_ob_out, velocity.get_buffer(), _ob_len1, _ob_cev);
    CORBA::ULong _ob_len2 = torque.length();
    OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len2, _ob_cev);
    OBEC_OutputStreamImpl_write_double_array(_ob_out, torque.get_buffer(), _ob_len2, _ob_cev);
    CORBA::ULong _ob_len3 = force.length();
    OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len3, _ob_cev);
    ::dsequence const * _ob_buf3 = force.get_buffer();
    for(CORBA::ULong _ob_i3 = 0 ; _ob_i3 < _ob_len3 ; _ob_i3++)
    {
        CORBA::ULong _ob_len4 = _ob_buf3[_ob_i3].length();
        OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len4, _ob_cev);
        OBEC_OutputStreamImpl_write_double_array(_ob_out, _ob_buf3[_ob_i3].get_buffer(), _ob_len4, _ob_cev);
    }
    CORBA::ULong _ob_len5 = rate.length();
    OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len5, _ob_cev);
    ::dsequence const * _ob_buf5 = rate.get_buffer();
    for(CORBA::ULong _ob_i5 = 0 ; _ob_i5 < _ob_len5 ; _ob_i5++)
    {
        CORBA::ULong _ob_len6 = _ob_buf5[_ob_i5].length();
        OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len6, _ob_cev);
        OBEC_OutputStreamImpl_write_double_array(_ob_out, _ob_buf5[_ob_i5].get_buffer(), _ob_len6, _ob_cev);
    }
    CORBA::ULong _ob_len7 = accel.length();
    OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len7, _ob_cev);
    ::dsequence const * _ob_buf7 = accel.get_buffer();
    for(CORBA::ULong _ob_i7 = 0 ; _ob_i7 < _ob_len7 ; _ob_i7++)
    {
        CORBA::ULong _ob_len8 = _ob_buf7[_ob_i7].length();
        OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len8, _ob_cev);
        OBEC_OutputStreamImpl_write_double_array(_ob_out, _ob_buf7[_ob_i7].get_buffer(), _ob_len8, _ob_cev);
    }
    CORBA::ULong _ob_len9 = attitude.length();
    OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len9, _ob_cev);
    ::dsequence const * _ob_buf9 = attitude.get_buffer();
    for(CORBA::ULong _ob_i9 = 0 ; _ob_i9 < _ob_len9 ; _ob_i9++)
    {
        CORBA::ULong _ob_len10 = _ob_buf9[_ob_i9].length();
        OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len10, _ob_cev);
        OBEC_OutputStreamImpl_write_double_array(_ob_out, _ob_buf9[_ob_i9].get_buffer(), _ob_len10, _ob_cev);
    }
    CORBA::ULong _ob_len11 = zmp.length();
    OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len11, _ob_cev);
    OBEC_OutputStreamImpl_write_double_array(_ob_out, zmp.get_buffer(), _ob_len11, _ob_cev);
    CORBA::ULong _ob_len12 = waistPos.length();
    OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len12, _ob_cev);
    OBEC_OutputStreamImpl_write_double_array(_ob_out, waistPos.get_buffer(), _ob_len12, _ob_cev);
    CORBA::ULong _ob_len13 = waistRpy.length();
    OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len13, _ob_cev);
    OBEC_OutputStreamImpl_write_double_array(_ob_out, waistRpy.get_buffer(), _ob_len13, _ob_cev);
    CORBA::ULong _ob_len14 = image.length();
    OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len14, _ob_cev);
    ::ImageData const * _ob_buf14 = image.get_buffer();
    for(CORBA::ULong _ob_i14 = 0 ; _ob_i14 < _ob_len14 ; _ob_i14++)
    {
        _ob_buf14[_ob_i14]._OB_marshal(_ob_out, _ob_cev);
    }
    CORBA::ULong _ob_len15 = dio.length();
    OBEC_OutputStreamImpl_write_ulong(_ob_out, _ob_len15, _ob_cev);
    OBEC_OutputStreamImpl_write_long_array(_ob_out, dio.get_buffer(), _ob_len15, _ob_cev);
}

void
RobotState::_OB_unmarshal(
    RobotState& _ob_v,
    OBEC_InputStreamImpl* _ob_in,
    CORBA_Environment* _ob_cev
)
{
    CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.angle.length(_ob_len0);
    OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_v.angle.get_buffer(), _ob_len0, _ob_cev);
    CORBA::ULong _ob_len1 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.velocity.length(_ob_len1);
    OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_v.velocity.get_buffer(), _ob_len1, _ob_cev);
    CORBA::ULong _ob_len2 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.torque.length(_ob_len2);
    OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_v.torque.get_buffer(), _ob_len2, _ob_cev);
    CORBA::ULong _ob_len3 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.force.length(_ob_len3);
    ::dsequence * _ob_buf3 = _ob_v.force.get_buffer();
    for(CORBA::ULong _ob_i3 = 0 ; _ob_i3 < _ob_len3 ; _ob_i3++)
    {
        CORBA::ULong _ob_len4 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
        _ob_buf3[_ob_i3].length(_ob_len4);
        OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_buf3[_ob_i3].get_buffer(), _ob_len4, _ob_cev);
    }
    CORBA::ULong _ob_len5 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.rate.length(_ob_len5);
    ::dsequence * _ob_buf5 = _ob_v.rate.get_buffer();
    for(CORBA::ULong _ob_i5 = 0 ; _ob_i5 < _ob_len5 ; _ob_i5++)
    {
        CORBA::ULong _ob_len6 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
        _ob_buf5[_ob_i5].length(_ob_len6);
        OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_buf5[_ob_i5].get_buffer(), _ob_len6, _ob_cev);
    }
    CORBA::ULong _ob_len7 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.accel.length(_ob_len7);
    ::dsequence * _ob_buf7 = _ob_v.accel.get_buffer();
    for(CORBA::ULong _ob_i7 = 0 ; _ob_i7 < _ob_len7 ; _ob_i7++)
    {
        CORBA::ULong _ob_len8 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
        _ob_buf7[_ob_i7].length(_ob_len8);
        OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_buf7[_ob_i7].get_buffer(), _ob_len8, _ob_cev);
    }
    CORBA::ULong _ob_len9 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.attitude.length(_ob_len9);
    ::dsequence * _ob_buf9 = _ob_v.attitude.get_buffer();
    for(CORBA::ULong _ob_i9 = 0 ; _ob_i9 < _ob_len9 ; _ob_i9++)
    {
        CORBA::ULong _ob_len10 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
        _ob_buf9[_ob_i9].length(_ob_len10);
        OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_buf9[_ob_i9].get_buffer(), _ob_len10, _ob_cev);
    }
    CORBA::ULong _ob_len11 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.zmp.length(_ob_len11);
    OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_v.zmp.get_buffer(), _ob_len11, _ob_cev);
    CORBA::ULong _ob_len12 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.waistPos.length(_ob_len12);
    OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_v.waistPos.get_buffer(), _ob_len12, _ob_cev);
    CORBA::ULong _ob_len13 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.waistRpy.length(_ob_len13);
    OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_v.waistRpy.get_buffer(), _ob_len13, _ob_cev);
    CORBA::ULong _ob_len14 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.image.length(_ob_len14);
    ::ImageData * _ob_buf14 = _ob_v.image.get_buffer();
    for(CORBA::ULong _ob_i14 = 0 ; _ob_i14 < _ob_len14 ; _ob_i14++)
    {
        ::ImageData::_OB_unmarshal(_ob_buf14[_ob_i14], _ob_in, _ob_cev);
    }
    CORBA::ULong _ob_len15 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
    _ob_v.dio.length(_ob_len15);
    OBEC_InputStreamImpl_read_long_array(_ob_in, _ob_v.dio.get_buffer(), _ob_len15, _ob_cev);
}

void
RobotState::_OB_convert_to(
    void* _ob_data
) const
{
    _OBE_C_RobotState* _ob_p = (_OBE_C_RobotState*)_ob_data;
    _ob_p->angle._length = angle.length();
    _ob_p->angle._maximum = angle.length();
    _ob_p->angle._release = OBEC_TRUE;
    _ob_p->angle._buffer = (CORBA_double*)OBEC_allocate_buffer(NULL, sizeof(CORBA_double) * _ob_p->angle._length, _ob_p->angle._length, OBEC_FALSE);

    memcpy(_ob_p->angle._buffer, angle.get_buffer(), sizeof(CORBA_double) * _ob_p->angle._length);
    _ob_p->velocity._length = velocity.length();
    _ob_p->velocity._maximum = velocity.length();
    _ob_p->velocity._release = OBEC_TRUE;
    _ob_p->velocity._buffer = (CORBA_double*)OBEC_allocate_buffer(NULL, sizeof(CORBA_double) * _ob_p->velocity._length, _ob_p->velocity._length, OBEC_FALSE);

    memcpy(_ob_p->velocity._buffer, velocity.get_buffer(), sizeof(CORBA_double) * _ob_p->velocity._length);
    _ob_p->torque._length = torque.length();
    _ob_p->torque._maximum = torque.length();
    _ob_p->torque._release = OBEC_TRUE;
    _ob_p->torque._buffer = (CORBA_double*)OBEC_allocate_buffer(NULL, sizeof(CORBA_double) * _ob_p->torque._length, _ob_p->torque._length, OBEC_FALSE);

    memcpy(_ob_p->torque._buffer, torque.get_buffer(), sizeof(CORBA_double) * _ob_p->torque._length);
    _ob_p->force._length = force.length();
    _ob_p->force._maximum = force.length();
    _ob_p->force._release = OBEC_TRUE;
    _ob_p->force._buffer = (_OBE_C_dsequence*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_dsequence) * _ob_p->force._length, _ob_p->force._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i3 = 0; _ob_i3 < _ob_p->force._length; _ob_i3++)
    {
        _ob_p->force._buffer[_ob_i3]._length = force[_ob_i3].length();
        _ob_p->force._buffer[_ob_i3]._maximum = force[_ob_i3].length();
        _ob_p->force._buffer[_ob_i3]._release = OBEC_TRUE;
        _ob_p->force._buffer[_ob_i3]._buffer = (CORBA_double*)OBEC_allocate_buffer(NULL, sizeof(CORBA_double) * _ob_p->force._buffer[_ob_i3]._length, _ob_p->force._buffer[_ob_i3]._length, OBEC_FALSE);

        memcpy(_ob_p->force._buffer[_ob_i3]._buffer, force[_ob_i3].get_buffer(), sizeof(CORBA_double) * _ob_p->force._buffer[_ob_i3]._length);
    }
    _ob_p->rate._length = rate.length();
    _ob_p->rate._maximum = rate.length();
    _ob_p->rate._release = OBEC_TRUE;
    _ob_p->rate._buffer = (_OBE_C_dsequence*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_dsequence) * _ob_p->rate._length, _ob_p->rate._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i5 = 0; _ob_i5 < _ob_p->rate._length; _ob_i5++)
    {
        _ob_p->rate._buffer[_ob_i5]._length = rate[_ob_i5].length();
        _ob_p->rate._buffer[_ob_i5]._maximum = rate[_ob_i5].length();
        _ob_p->rate._buffer[_ob_i5]._release = OBEC_TRUE;
        _ob_p->rate._buffer[_ob_i5]._buffer = (CORBA_double*)OBEC_allocate_buffer(NULL, sizeof(CORBA_double) * _ob_p->rate._buffer[_ob_i5]._length, _ob_p->rate._buffer[_ob_i5]._length, OBEC_FALSE);

        memcpy(_ob_p->rate._buffer[_ob_i5]._buffer, rate[_ob_i5].get_buffer(), sizeof(CORBA_double) * _ob_p->rate._buffer[_ob_i5]._length);
    }
    _ob_p->accel._length = accel.length();
    _ob_p->accel._maximum = accel.length();
    _ob_p->accel._release = OBEC_TRUE;
    _ob_p->accel._buffer = (_OBE_C_dsequence*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_dsequence) * _ob_p->accel._length, _ob_p->accel._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i7 = 0; _ob_i7 < _ob_p->accel._length; _ob_i7++)
    {
        _ob_p->accel._buffer[_ob_i7]._length = accel[_ob_i7].length();
        _ob_p->accel._buffer[_ob_i7]._maximum = accel[_ob_i7].length();
        _ob_p->accel._buffer[_ob_i7]._release = OBEC_TRUE;
        _ob_p->accel._buffer[_ob_i7]._buffer = (CORBA_double*)OBEC_allocate_buffer(NULL, sizeof(CORBA_double) * _ob_p->accel._buffer[_ob_i7]._length, _ob_p->accel._buffer[_ob_i7]._length, OBEC_FALSE);

        memcpy(_ob_p->accel._buffer[_ob_i7]._buffer, accel[_ob_i7].get_buffer(), sizeof(CORBA_double) * _ob_p->accel._buffer[_ob_i7]._length);
    }
    _ob_p->attitude._length = attitude.length();
    _ob_p->attitude._maximum = attitude.length();
    _ob_p->attitude._release = OBEC_TRUE;
    _ob_p->attitude._buffer = (_OBE_C_dsequence*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_dsequence) * _ob_p->attitude._length, _ob_p->attitude._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i9 = 0; _ob_i9 < _ob_p->attitude._length; _ob_i9++)
    {
        _ob_p->attitude._buffer[_ob_i9]._length = attitude[_ob_i9].length();
        _ob_p->attitude._buffer[_ob_i9]._maximum = attitude[_ob_i9].length();
        _ob_p->attitude._buffer[_ob_i9]._release = OBEC_TRUE;
        _ob_p->attitude._buffer[_ob_i9]._buffer = (CORBA_double*)OBEC_allocate_buffer(NULL, sizeof(CORBA_double) * _ob_p->attitude._buffer[_ob_i9]._length, _ob_p->attitude._buffer[_ob_i9]._length, OBEC_FALSE);

        memcpy(_ob_p->attitude._buffer[_ob_i9]._buffer, attitude[_ob_i9].get_buffer(), sizeof(CORBA_double) * _ob_p->attitude._buffer[_ob_i9]._length);
    }
    _ob_p->zmp._length = zmp.length();
    _ob_p->zmp._maximum = zmp.length();
    _ob_p->zmp._release = OBEC_TRUE;
    _ob_p->zmp._buffer = (CORBA_double*)OBEC_allocate_buffer(NULL, sizeof(CORBA_double) * _ob_p->zmp._length, _ob_p->zmp._length, OBEC_FALSE);

    memcpy(_ob_p->zmp._buffer, zmp.get_buffer(), sizeof(CORBA_double) * _ob_p->zmp._length);
    _ob_p->waistPos._length = waistPos.length();
    _ob_p->waistPos._maximum = waistPos.length();
    _ob_p->waistPos._release = OBEC_TRUE;
    _ob_p->waistPos._buffer = (CORBA_double*)OBEC_allocate_buffer(NULL, sizeof(CORBA_double) * _ob_p->waistPos._length, _ob_p->waistPos._length, OBEC_FALSE);

    memcpy(_ob_p->waistPos._buffer, waistPos.get_buffer(), sizeof(CORBA_double) * _ob_p->waistPos._length);
    _ob_p->waistRpy._length = waistRpy.length();
    _ob_p->waistRpy._maximum = waistRpy.length();
    _ob_p->waistRpy._release = OBEC_TRUE;
    _ob_p->waistRpy._buffer = (CORBA_double*)OBEC_allocate_buffer(NULL, sizeof(CORBA_double) * _ob_p->waistRpy._length, _ob_p->waistRpy._length, OBEC_FALSE);

    memcpy(_ob_p->waistRpy._buffer, waistRpy.get_buffer(), sizeof(CORBA_double) * _ob_p->waistRpy._length);
    _ob_p->image._length = image.length();
    _ob_p->image._maximum = image.length();
    _ob_p->image._release = OBEC_TRUE;
    _ob_p->image._buffer = (_OBE_C_ImageData*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_ImageData) * _ob_p->image._length, _ob_p->image._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i14 = 0; _ob_i14 < _ob_p->image._length; _ob_i14++)
    {
        image[_ob_i14]._OB_convert_to(&_ob_p->image._buffer[_ob_i14]);
    }
    _ob_p->dio._length = dio.length();
    _ob_p->dio._maximum = dio.length();
    _ob_p->dio._release = OBEC_TRUE;
    _ob_p->dio._buffer = (CORBA_long*)OBEC_allocate_buffer(NULL, sizeof(CORBA_long) * _ob_p->dio._length, _ob_p->dio._length, OBEC_FALSE);

    memcpy(_ob_p->dio._buffer, dio.get_buffer(), sizeof(CORBA_long) * _ob_p->dio._length);
}

void
RobotState::_OB_convert_from(
    RobotState& _ob_v,
    void* _ob_data
)
{
    _OBE_C_RobotState* _ob_p = (_OBE_C_RobotState*)_ob_data;
    _ob_v.angle.length(_ob_p->angle._length);

    memcpy(_ob_v.angle.get_buffer(), _ob_p->angle._buffer, sizeof(CORBA_double) * _ob_p->angle._length);
    _ob_v.velocity.length(_ob_p->velocity._length);

    memcpy(_ob_v.velocity.get_buffer(), _ob_p->velocity._buffer, sizeof(CORBA_double) * _ob_p->velocity._length);
    _ob_v.torque.length(_ob_p->torque._length);

    memcpy(_ob_v.torque.get_buffer(), _ob_p->torque._buffer, sizeof(CORBA_double) * _ob_p->torque._length);
    _ob_v.force.length(_ob_p->force._length);

    for (CORBA::ULong _ob_i3 = 0; _ob_i3 < _ob_p->force._length; _ob_i3++)
    {
        _ob_v.force[_ob_i3].length(_ob_p->force._buffer[_ob_i3]._length);

        memcpy(_ob_v.force[_ob_i3].get_buffer(), _ob_p->force._buffer[_ob_i3]._buffer, sizeof(CORBA_double) * _ob_p->force._buffer[_ob_i3]._length);
    }
    _ob_v.rate.length(_ob_p->rate._length);

    for (CORBA::ULong _ob_i5 = 0; _ob_i5 < _ob_p->rate._length; _ob_i5++)
    {
        _ob_v.rate[_ob_i5].length(_ob_p->rate._buffer[_ob_i5]._length);

        memcpy(_ob_v.rate[_ob_i5].get_buffer(), _ob_p->rate._buffer[_ob_i5]._buffer, sizeof(CORBA_double) * _ob_p->rate._buffer[_ob_i5]._length);
    }
    _ob_v.accel.length(_ob_p->accel._length);

    for (CORBA::ULong _ob_i7 = 0; _ob_i7 < _ob_p->accel._length; _ob_i7++)
    {
        _ob_v.accel[_ob_i7].length(_ob_p->accel._buffer[_ob_i7]._length);

        memcpy(_ob_v.accel[_ob_i7].get_buffer(), _ob_p->accel._buffer[_ob_i7]._buffer, sizeof(CORBA_double) * _ob_p->accel._buffer[_ob_i7]._length);
    }
    _ob_v.attitude.length(_ob_p->attitude._length);

    for (CORBA::ULong _ob_i9 = 0; _ob_i9 < _ob_p->attitude._length; _ob_i9++)
    {
        _ob_v.attitude[_ob_i9].length(_ob_p->attitude._buffer[_ob_i9]._length);

        memcpy(_ob_v.attitude[_ob_i9].get_buffer(), _ob_p->attitude._buffer[_ob_i9]._buffer, sizeof(CORBA_double) * _ob_p->attitude._buffer[_ob_i9]._length);
    }
    _ob_v.zmp.length(_ob_p->zmp._length);

    memcpy(_ob_v.zmp.get_buffer(), _ob_p->zmp._buffer, sizeof(CORBA_double) * _ob_p->zmp._length);
    _ob_v.waistPos.length(_ob_p->waistPos._length);

    memcpy(_ob_v.waistPos.get_buffer(), _ob_p->waistPos._buffer, sizeof(CORBA_double) * _ob_p->waistPos._length);
    _ob_v.waistRpy.length(_ob_p->waistRpy._length);

    memcpy(_ob_v.waistRpy.get_buffer(), _ob_p->waistRpy._buffer, sizeof(CORBA_double) * _ob_p->waistRpy._length);
    _ob_v.image.length(_ob_p->image._length);

    for (CORBA::ULong _ob_i14 = 0; _ob_i14 < _ob_p->image._length; _ob_i14++)
    {
        ImageData::_OB_convert_from(_ob_v.image[_ob_i14], &_ob_p->image._buffer[_ob_i14]);
    }
    _ob_v.dio.length(_ob_p->dio._length);

    memcpy(_ob_v.dio.get_buffer(), _ob_p->dio._buffer, sizeof(CORBA_long) * _ob_p->dio._length);
}

static CORBA::AnyContentDestroyerDelete<RobotState> OBAnyContentDestroyerInstance_RobotState;

void
operator<<=(CORBA::Any& any, RobotState* v)
{
    _OBE_C_RobotState* p = (_OBE_C_RobotState*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_RobotState->_OB_impl_nodup(), sizeof(_OBE_C_RobotState));
    (*v)._OB_convert_to(&(*p));
    any.replace(_tc_RobotState, p, false, v, &OBAnyContentDestroyerInstance_RobotState);
}

void
operator<<=(CORBA::Any& any, const RobotState& v)
{
    _OBE_C_RobotState* p = (_OBE_C_RobotState*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_RobotState->_OB_impl_nodup(), sizeof(_OBE_C_RobotState));
    v._OB_convert_to(&(*p));
    any.replace(_tc_RobotState, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const RobotState*& v)
{
    if (!any.check_type(_tc_RobotState))
        return 0;

    v = (const RobotState*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_RobotState* p = (_OBE_C_RobotState*)any.value();
        assert(p != NULL);
        RobotState* val = new RobotState;
        RobotState::_OB_convert_from((*val), &(*p));
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_RobotState);
        v = val;
    }

    return 1;
}

//
// IDL:SensorType:1.0
//
void
operator<<=(CORBA::Any& any, SensorType v)
{
    CORBA_unsigned_long* p = (CORBA_unsigned_long*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_SensorType->_OB_impl_nodup(), sizeof(CORBA_unsigned_long)); 
    *p = (CORBA_unsigned_long)v;
    any.replace(_tc_SensorType, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, SensorType& v)
{
    if (!any.check_type(_tc_SensorType))
        return false;

    v = (SensorType)(*(CORBA_unsigned_long*)any.value());

    return true;
}

//
// IDL:SensorInfo:1.0
//
const char* SensorInfo::ids_[] =
{
    "IDL:SensorInfo:1.0",
    0
};

void
OBDuplicate(SensorInfo_ptr p)
{
    if(p)
        p -> _OB_incRef();
}

void
OBRelease(SensorInfo_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

SensorInfo_ptr
SensorInfo::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        SensorInfo_ptr v = dynamic_cast<SensorInfo_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            ::SensorInfo* val = new ::SensorInfo;
            val -> _OB_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

const char**
SensorInfo::_OB_staticIds()
{
    return ids_;
}

const char**
SensorInfo::_OB_ids() const
{
    return ::SensorInfo::ids_;
}

void
OBMarshal(
    SensorInfo_ptr _ob_v,
    OBEC_OutputStreamImpl* _ob_out,
    CORBA_Environment* _ob_cev
)
{
    CORBA_Object _ob_cobj = NULL;
    if (_ob_v)
    {
        _ob_cobj = _ob_v->_OB_impl_nodup();
        assert(_ob_cobj != NULL);
    }
    OBEC_OutputStreamImpl_write_Object(_ob_out, _ob_cobj, _ob_cev);
}

void
OBUnmarshal(
    SensorInfo_ptr& _ob_v,
    OBEC_InputStreamImpl* _ob_in,
    CORBA_Environment* _ob_cev
)
{
    SensorInfo_var old = _ob_v;
    CORBA_Object _ob_cobj = OBEC_InputStreamImpl_read_Object(_ob_in, _ob_cev);

    if (_ob_cobj != NULL && _ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_v = new SensorInfo;
        _ob_v->_OB_setup(_ob_cobj);
        CORBA_Object_release(_ob_cobj);
    }
    else
        _ob_v = SensorInfo::_nil();
}

//
// IDL:SensorInfo/id:1.0
//
CORBA::Long
SensorInfo::_OB_att_id(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    CORBA::Long _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    _ob_r = 0;
    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_id", 7, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r;
}

//
// IDL:SensorInfo/name:1.0
//
char*
SensorInfo::_OB_att_name(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    CORBA::String_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_name", 9, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = OBEC_InputStreamImpl_read_string(_ob_in, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

//
// IDL:SensorInfo/type:1.0
//
::SensorType
SensorInfo::_OB_att_type(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::SensorType _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    _ob_r = (::SensorType)0;
    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_type", 9, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = (::SensorType)OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r;
}

//
// IDL:SensorInfo/relPos:1.0
//
::ValueMatrix*
SensorInfo::_OB_att_relPos(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::ValueMatrix_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_relPos", 11, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = new ::ValueMatrix;
                CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
                _ob_r -> length(_ob_len0);
                OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_r -> get_buffer(), _ob_len0, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

//
// IDL:SensorInfo/relAttitude:1.0
//
::ValueMatrix*
SensorInfo::_OB_att_relAttitude(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::ValueMatrix_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_relAttitude", 16, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = new ::ValueMatrix;
                CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
                _ob_r -> length(_ob_len0);
                OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_r -> get_buffer(), _ob_len0, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

//
// IDL:SensorInfo/maxValue:1.0
//
::ValueMatrix*
SensorInfo::_OB_att_maxValue(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::ValueMatrix_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_maxValue", 13, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = new ::ValueMatrix;
                CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
                _ob_r -> length(_ob_len0);
                OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_r -> get_buffer(), _ob_len0, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

void
operator<<=(CORBA::Any& any, SensorInfo_ptr* v)
{
    CORBA_Object cobj = CORBA_OBJECT_NIL;
    if (!CORBA::is_nil(*v))
    {
        cobj = (*v)->_OB_impl_nodup();
    }
    any.replace(_tc_SensorInfo, &cobj, true, (CORBA::Object_ptr)*v, &CORBA::Any::sm_any_content_destroyer_object);
}

void
operator<<=(CORBA::Any& any, SensorInfo_ptr v)
{
    SensorInfo_ptr val = SensorInfo::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, SensorInfo_ptr& v)
{
    if (any.check_type(_tc_SensorInfo))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.cpp_value();
        if (!CORBA::is_nil(val))
            v = dynamic_cast<SensorInfo_ptr>(val);
        else
        {
            CORBA_Object cobj = *(CORBA_Object*)any.value();
            if (cobj != CORBA_OBJECT_NIL)
            {
                SensorInfo* obj = new SensorInfo;
                obj->_OB_setup(cobj);
                v = obj;
                ((CORBA::Any&)any).cpp_value((CORBA::Object_ptr)obj, &CORBA::Any::sm_any_content_destroyer_object);
            }
            else
                v = SensorInfo::_nil();
        }

        return true;
    }
    else
        return false;
}

//
// IDL:SensorInfo/id:1.0
//
CORBA::Long
SensorInfo::id(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA::Long _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    _ob_r = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_id(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r;
}

//
// IDL:SensorInfo/name:1.0
//
char*
SensorInfo::name(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA::String_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_name(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:SensorInfo/type:1.0
//
::SensorType
SensorInfo::type(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::SensorType _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    _ob_r = (::SensorType)0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_type(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r;
}

//
// IDL:SensorInfo/relPos:1.0
//
::ValueMatrix*
SensorInfo::relPos(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::ValueMatrix_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_relPos(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:SensorInfo/relAttitude:1.0
//
::ValueMatrix*
SensorInfo::relAttitude(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::ValueMatrix_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_relAttitude(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:SensorInfo/maxValue:1.0
//
::ValueMatrix*
SensorInfo::maxValue(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::ValueMatrix_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_maxValue(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:SensorInfoSeq:1.0
//
static CORBA::AnyContentDestroyerDelete<SensorInfoSeq> OBAnyContentDestroyerInstance_SensorInfoSeq;

void
operator<<=(CORBA::Any& any, SensorInfoSeq* v)
{
    _OBE_C_CORBA_sequence__OBE_C_SensorInfo* p = (_OBE_C_CORBA_sequence__OBE_C_SensorInfo*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_SensorInfoSeq->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence__OBE_C_SensorInfo));
    (*p)._length = (*v).length();
    (*p)._maximum = (*v).length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (_OBE_C_SensorInfo*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_SensorInfo) * (*p)._length, (*p)._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
    {
        if (CORBA::is_nil((*v)[_ob_i0]))
            (*p)._buffer[_ob_i0] = CORBA_OBJECT_NIL;
        else
            (*p)._buffer[_ob_i0] = CORBA_Object_duplicate((*v)[_ob_i0]->_OB_impl_nodup());
    }
    any.replace(_tc_SensorInfoSeq, p, false, v, &OBAnyContentDestroyerInstance_SensorInfoSeq);
}

void
operator<<=(CORBA::Any& any, const SensorInfoSeq& v)
{
    _OBE_C_CORBA_sequence__OBE_C_SensorInfo* p = (_OBE_C_CORBA_sequence__OBE_C_SensorInfo*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_SensorInfoSeq->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence__OBE_C_SensorInfo));
    (*p)._length = v.length();
    (*p)._maximum = v.length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (_OBE_C_SensorInfo*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_SensorInfo) * (*p)._length, (*p)._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
    {
        if (CORBA::is_nil(v[_ob_i0]))
            (*p)._buffer[_ob_i0] = CORBA_OBJECT_NIL;
        else
            (*p)._buffer[_ob_i0] = CORBA_Object_duplicate(v[_ob_i0]->_OB_impl_nodup());
    }
    any.replace(_tc_SensorInfoSeq, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const SensorInfoSeq*& v)
{
    if (!any.check_type(_tc_SensorInfoSeq))
        return false;

    v = (const SensorInfoSeq*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_CORBA_sequence__OBE_C_SensorInfo* p = (_OBE_C_CORBA_sequence__OBE_C_SensorInfo*)any.value();
        assert(p != NULL);
        SensorInfoSeq* val = new SensorInfoSeq;
        (*val).length((*p)._length);

        for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
        {
            if ((*p)._buffer[_ob_i0] == CORBA_OBJECT_NIL)
                (*val)[_ob_i0] = SensorInfo::_nil();
            else
            {
                (*val)[_ob_i0] = new SensorInfo;
                (*val)[_ob_i0]->_OB_setup((*p)._buffer[_ob_i0]);
            }
        }
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_SensorInfoSeq);
        v = val;
    }

    return true;
}

//
// IDL:ParserModelObject:1.0
//
const char* ParserModelObject::ids_[] =
{
    "IDL:ParserModelObject:1.0",
    0
};

void
OBDuplicate(ParserModelObject_ptr p)
{
    if(p)
        p -> _OB_incRef();
}

void
OBRelease(ParserModelObject_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

ParserModelObject_ptr
ParserModelObject::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        ParserModelObject_ptr v = dynamic_cast<ParserModelObject_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            ::ParserModelObject* val = new ::ParserModelObject;
            val -> _OB_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

const char**
ParserModelObject::_OB_staticIds()
{
    return ids_;
}

const char**
ParserModelObject::_OB_ids() const
{
    return ::ParserModelObject::ids_;
}

void
OBMarshal(
    ParserModelObject_ptr _ob_v,
    OBEC_OutputStreamImpl* _ob_out,
    CORBA_Environment* _ob_cev
)
{
    CORBA_Object _ob_cobj = NULL;
    if (_ob_v)
    {
        _ob_cobj = _ob_v->_OB_impl_nodup();
        assert(_ob_cobj != NULL);
    }
    OBEC_OutputStreamImpl_write_Object(_ob_out, _ob_cobj, _ob_cev);
}

void
OBUnmarshal(
    ParserModelObject_ptr& _ob_v,
    OBEC_InputStreamImpl* _ob_in,
    CORBA_Environment* _ob_cev
)
{
    ParserModelObject_var old = _ob_v;
    CORBA_Object _ob_cobj = OBEC_InputStreamImpl_read_Object(_ob_in, _ob_cev);

    if (_ob_cobj != NULL && _ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_v = new ParserModelObject;
        _ob_v->_OB_setup(_ob_cobj);
        CORBA_Object_release(_ob_cobj);
    }
    else
        _ob_v = ParserModelObject::_nil();
}

//
// IDL:ParserModelObject/positionGiven:1.0
//
CORBA::Boolean
ParserModelObject::_OB_att_positionGiven(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    CORBA::Boolean _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    _ob_r = 0;
    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_positionGiven", 18, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = OBEC_InputStreamImpl_read_boolean(_ob_in, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r;
}

//
// IDL:ParserModelObject/rotateJoint:1.0
//
CORBA::Boolean
ParserModelObject::_OB_att_rotateJoint(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    CORBA::Boolean _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    _ob_r = 0;
    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_rotateJoint", 16, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = OBEC_InputStreamImpl_read_boolean(_ob_in, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r;
}

//
// IDL:ParserModelObject/mass:1.0
//
CORBA::Double
ParserModelObject::_OB_att_mass(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    CORBA::Double _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    _ob_r = 0;
    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_mass", 9, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = OBEC_InputStreamImpl_read_double(_ob_in, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r;
}

//
// IDL:ParserModelObject/jointValue:1.0
//
CORBA::Double
ParserModelObject::_OB_att_jointValue(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    CORBA::Double _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    _ob_r = 0;
    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_jointValue", 15, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = OBEC_InputStreamImpl_read_double(_ob_in, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r;
}

//
// IDL:ParserModelObject/jointVel:1.0
//
CORBA::Double
ParserModelObject::_OB_att_jointVel(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    CORBA::Double _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    _ob_r = 0;
    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_jointVel", 13, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = OBEC_InputStreamImpl_read_double(_ob_in, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r;
}

//
// IDL:ParserModelObject/jointAcc:1.0
//
CORBA::Double
ParserModelObject::_OB_att_jointAcc(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    CORBA::Double _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    _ob_r = 0;
    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_jointAcc", 13, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = OBEC_InputStreamImpl_read_double(_ob_in, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r;
}

//
// IDL:ParserModelObject/absPos:1.0
//
::ValueMatrix*
ParserModelObject::_OB_att_absPos(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::ValueMatrix_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_absPos", 11, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = new ::ValueMatrix;
                CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
                _ob_r -> length(_ob_len0);
                OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_r -> get_buffer(), _ob_len0, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/relPos:1.0
//
::ValueMatrix*
ParserModelObject::_OB_att_relPos(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::ValueMatrix_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_relPos", 11, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = new ::ValueMatrix;
                CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
                _ob_r -> length(_ob_len0);
                OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_r -> get_buffer(), _ob_len0, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/relComPos:1.0
//
::ValueMatrix*
ParserModelObject::_OB_att_relComPos(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::ValueMatrix_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_relComPos", 14, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = new ::ValueMatrix;
                CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
                _ob_r -> length(_ob_len0);
                OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_r -> get_buffer(), _ob_len0, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/absComPos:1.0
//
::ValueMatrix*
ParserModelObject::_OB_att_absComPos(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::ValueMatrix_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_absComPos", 14, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = new ::ValueMatrix;
                CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
                _ob_r -> length(_ob_len0);
                OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_r -> get_buffer(), _ob_len0, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/relComAcc:1.0
//
::ValueMatrix*
ParserModelObject::_OB_att_relComAcc(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::ValueMatrix_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_relComAcc", 14, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = new ::ValueMatrix;
                CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
                _ob_r -> length(_ob_len0);
                OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_r -> get_buffer(), _ob_len0, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/omega:1.0
//
::ValueMatrix*
ParserModelObject::_OB_att_omega(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::ValueMatrix_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_omega", 10, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = new ::ValueMatrix;
                CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
                _ob_r -> length(_ob_len0);
                OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_r -> get_buffer(), _ob_len0, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/omega_d:1.0
//
::ValueMatrix*
ParserModelObject::_OB_att_omega_d(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::ValueMatrix_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_omega_d", 12, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = new ::ValueMatrix;
                CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
                _ob_r -> length(_ob_len0);
                OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_r -> get_buffer(), _ob_len0, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/relAcc:1.0
//
::ValueMatrix*
ParserModelObject::_OB_att_relAcc(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::ValueMatrix_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_relAcc", 11, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = new ::ValueMatrix;
                CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
                _ob_r -> length(_ob_len0);
                OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_r -> get_buffer(), _ob_len0, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/absVel:1.0
//
::ValueMatrix*
ParserModelObject::_OB_att_absVel(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::ValueMatrix_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_absVel", 11, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = new ::ValueMatrix;
                CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
                _ob_r -> length(_ob_len0);
                OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_r -> get_buffer(), _ob_len0, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/absComVel:1.0
//
::ValueMatrix*
ParserModelObject::_OB_att_absComVel(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::ValueMatrix_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_absComVel", 14, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = new ::ValueMatrix;
                CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
                _ob_r -> length(_ob_len0);
                OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_r -> get_buffer(), _ob_len0, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/relForce:1.0
//
::ValueMatrix*
ParserModelObject::_OB_att_relForce(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::ValueMatrix_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_relForce", 13, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = new ::ValueMatrix;
                CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
                _ob_r -> length(_ob_len0);
                OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_r -> get_buffer(), _ob_len0, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/relTorque:1.0
//
::ValueMatrix*
ParserModelObject::_OB_att_relTorque(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::ValueMatrix_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_relTorque", 14, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = new ::ValueMatrix;
                CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
                _ob_r -> length(_ob_len0);
                OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_r -> get_buffer(), _ob_len0, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/absAttitude:1.0
//
::ValueMatrix*
ParserModelObject::_OB_att_absAttitude(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::ValueMatrix_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_absAttitude", 16, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = new ::ValueMatrix;
                CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
                _ob_r -> length(_ob_len0);
                OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_r -> get_buffer(), _ob_len0, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/relAttitude:1.0
//
::ValueMatrix*
ParserModelObject::_OB_att_relAttitude(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::ValueMatrix_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_relAttitude", 16, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = new ::ValueMatrix;
                CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
                _ob_r -> length(_ob_len0);
                OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_r -> get_buffer(), _ob_len0, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/inertia:1.0
//
::ValueMatrix*
ParserModelObject::_OB_att_inertia(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::ValueMatrix_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_inertia", 12, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = new ::ValueMatrix;
                CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
                _ob_r -> length(_ob_len0);
                OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_r -> get_buffer(), _ob_len0, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/dh:1.0
//
::Value*
ParserModelObject::_OB_att_dh(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::Value_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_dh", 7, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = new ::Value;
                CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
                _ob_r -> length(_ob_len0);
                OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_r -> get_buffer(), _ob_len0, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/ulimit:1.0
//
::Value*
ParserModelObject::_OB_att_ulimit(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::Value_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_ulimit", 11, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = new ::Value;
                CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
                _ob_r -> length(_ob_len0);
                OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_r -> get_buffer(), _ob_len0, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/llimit:1.0
//
::Value*
ParserModelObject::_OB_att_llimit(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::Value_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_llimit", 11, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = new ::Value;
                CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
                _ob_r -> length(_ob_len0);
                OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_r -> get_buffer(), _ob_len0, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/uvlimit:1.0
//
::Value*
ParserModelObject::_OB_att_uvlimit(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::Value_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_uvlimit", 12, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = new ::Value;
                CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
                _ob_r -> length(_ob_len0);
                OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_r -> get_buffer(), _ob_len0, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/lvlimit:1.0
//
::Value*
ParserModelObject::_OB_att_lvlimit(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::Value_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_lvlimit", 12, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = new ::Value;
                CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
                _ob_r -> length(_ob_len0);
                OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_r -> get_buffer(), _ob_len0, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/rotorInertia:1.0
//
CORBA::Double
ParserModelObject::_OB_att_rotorInertia(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    CORBA::Double _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    _ob_r = 0;
    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_rotorInertia", 17, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = OBEC_InputStreamImpl_read_double(_ob_in, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r;
}

//
// IDL:ParserModelObject/rotorResistor:1.0
//
CORBA::Double
ParserModelObject::_OB_att_rotorResistor(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    CORBA::Double _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    _ob_r = 0;
    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_rotorResistor", 18, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = OBEC_InputStreamImpl_read_double(_ob_in, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r;
}

//
// IDL:ParserModelObject/gearRatio:1.0
//
CORBA::Double
ParserModelObject::_OB_att_gearRatio(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    CORBA::Double _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    _ob_r = 0;
    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_gearRatio", 14, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = OBEC_InputStreamImpl_read_double(_ob_in, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r;
}

//
// IDL:ParserModelObject/torqueConst:1.0
//
CORBA::Double
ParserModelObject::_OB_att_torqueConst(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    CORBA::Double _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    _ob_r = 0;
    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_torqueConst", 16, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = OBEC_InputStreamImpl_read_double(_ob_in, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r;
}

//
// IDL:ParserModelObject/encoderPulse:1.0
//
CORBA::Double
ParserModelObject::_OB_att_encoderPulse(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    CORBA::Double _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    _ob_r = 0;
    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_encoderPulse", 17, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = OBEC_InputStreamImpl_read_double(_ob_in, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r;
}

//
// IDL:ParserModelObject/bboxCenter:1.0
//
::Value*
ParserModelObject::_OB_att_bboxCenter(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::Value_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_bboxCenter", 15, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = new ::Value;
                CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
                _ob_r -> length(_ob_len0);
                OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_r -> get_buffer(), _ob_len0, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/bboxSize:1.0
//
::Value*
ParserModelObject::_OB_att_bboxSize(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::Value_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_bboxSize", 13, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = new ::Value;
                CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
                _ob_r -> length(_ob_len0);
                OBEC_InputStreamImpl_read_double_array(_ob_in, _ob_r -> get_buffer(), _ob_len0, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/name:1.0
//
char*
ParserModelObject::_OB_att_name(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    CORBA::String_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_name", 9, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = OBEC_InputStreamImpl_read_string(_ob_in, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/jointType:1.0
//
char*
ParserModelObject::_OB_att_jointType(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    CORBA::String_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_jointType", 14, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = OBEC_InputStreamImpl_read_string(_ob_in, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/jointId:1.0
//
CORBA::Short
ParserModelObject::_OB_att_jointId(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    CORBA::Short _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    _ob_r = 0;
    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_jointId", 12, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = OBEC_InputStreamImpl_read_short(_ob_in, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r;
}

//
// IDL:ParserModelObject/jointAxis:1.0
//
char*
ParserModelObject::_OB_att_jointAxis(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    CORBA::String_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_jointAxis", 14, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = OBEC_InputStreamImpl_read_string(_ob_in, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/mother:1.0
//
CORBA::Long
ParserModelObject::_OB_att_mother(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    CORBA::Long _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    _ob_r = 0;
    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_mother", 11, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r;
}

//
// IDL:ParserModelObject/sister:1.0
//
CORBA::Long
ParserModelObject::_OB_att_sister(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    CORBA::Long _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    _ob_r = 0;
    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_sister", 11, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r;
}

//
// IDL:ParserModelObject/daughter:1.0
//
CORBA::Long
ParserModelObject::_OB_att_daughter(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    CORBA::Long _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    _ob_r = 0;
    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_daughter", 13, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = OBEC_InputStreamImpl_read_long(_ob_in, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r;
}

//
// IDL:ParserModelObject/sensors:1.0
//
::SensorInfoSeq*
ParserModelObject::_OB_att_sensors(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::SensorInfoSeq_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_sensors", 12, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = new ::SensorInfoSeq;
                CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
                _ob_r -> length(_ob_len0);
                ::SensorInfo_ptr * _ob_buf0 = _ob_r -> get_buffer();
                for(CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
                {
                    OBUnmarshal(_ob_buf0[_ob_i0], _ob_in, _ob_cev);
                }
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

void
operator<<=(CORBA::Any& any, ParserModelObject_ptr* v)
{
    CORBA_Object cobj = CORBA_OBJECT_NIL;
    if (!CORBA::is_nil(*v))
    {
        cobj = (*v)->_OB_impl_nodup();
    }
    any.replace(_tc_ParserModelObject, &cobj, true, (CORBA::Object_ptr)*v, &CORBA::Any::sm_any_content_destroyer_object);
}

void
operator<<=(CORBA::Any& any, ParserModelObject_ptr v)
{
    ParserModelObject_ptr val = ParserModelObject::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, ParserModelObject_ptr& v)
{
    if (any.check_type(_tc_ParserModelObject))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.cpp_value();
        if (!CORBA::is_nil(val))
            v = dynamic_cast<ParserModelObject_ptr>(val);
        else
        {
            CORBA_Object cobj = *(CORBA_Object*)any.value();
            if (cobj != CORBA_OBJECT_NIL)
            {
                ParserModelObject* obj = new ParserModelObject;
                obj->_OB_setup(cobj);
                v = obj;
                ((CORBA::Any&)any).cpp_value((CORBA::Object_ptr)obj, &CORBA::Any::sm_any_content_destroyer_object);
            }
            else
                v = ParserModelObject::_nil();
        }

        return true;
    }
    else
        return false;
}

//
// IDL:ParserModelObject/positionGiven:1.0
//
CORBA::Boolean
ParserModelObject::positionGiven(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA::Boolean _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    _ob_r = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_positionGiven(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r;
}

//
// IDL:ParserModelObject/rotateJoint:1.0
//
CORBA::Boolean
ParserModelObject::rotateJoint(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA::Boolean _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    _ob_r = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_rotateJoint(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r;
}

//
// IDL:ParserModelObject/mass:1.0
//
CORBA::Double
ParserModelObject::mass(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA::Double _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    _ob_r = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_mass(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r;
}

//
// IDL:ParserModelObject/jointValue:1.0
//
CORBA::Double
ParserModelObject::jointValue(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA::Double _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    _ob_r = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_jointValue(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r;
}

//
// IDL:ParserModelObject/jointVel:1.0
//
CORBA::Double
ParserModelObject::jointVel(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA::Double _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    _ob_r = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_jointVel(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r;
}

//
// IDL:ParserModelObject/jointAcc:1.0
//
CORBA::Double
ParserModelObject::jointAcc(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA::Double _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    _ob_r = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_jointAcc(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r;
}

//
// IDL:ParserModelObject/absPos:1.0
//
::ValueMatrix*
ParserModelObject::absPos(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::ValueMatrix_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_absPos(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/relPos:1.0
//
::ValueMatrix*
ParserModelObject::relPos(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::ValueMatrix_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_relPos(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/relComPos:1.0
//
::ValueMatrix*
ParserModelObject::relComPos(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::ValueMatrix_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_relComPos(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/absComPos:1.0
//
::ValueMatrix*
ParserModelObject::absComPos(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::ValueMatrix_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_absComPos(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/relComAcc:1.0
//
::ValueMatrix*
ParserModelObject::relComAcc(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::ValueMatrix_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_relComAcc(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/omega:1.0
//
::ValueMatrix*
ParserModelObject::omega(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::ValueMatrix_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_omega(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/omega_d:1.0
//
::ValueMatrix*
ParserModelObject::omega_d(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::ValueMatrix_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_omega_d(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/relAcc:1.0
//
::ValueMatrix*
ParserModelObject::relAcc(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::ValueMatrix_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_relAcc(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/absVel:1.0
//
::ValueMatrix*
ParserModelObject::absVel(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::ValueMatrix_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_absVel(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/absComVel:1.0
//
::ValueMatrix*
ParserModelObject::absComVel(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::ValueMatrix_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_absComVel(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/relForce:1.0
//
::ValueMatrix*
ParserModelObject::relForce(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::ValueMatrix_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_relForce(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/relTorque:1.0
//
::ValueMatrix*
ParserModelObject::relTorque(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::ValueMatrix_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_relTorque(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/absAttitude:1.0
//
::ValueMatrix*
ParserModelObject::absAttitude(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::ValueMatrix_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_absAttitude(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/relAttitude:1.0
//
::ValueMatrix*
ParserModelObject::relAttitude(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::ValueMatrix_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_relAttitude(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/inertia:1.0
//
::ValueMatrix*
ParserModelObject::inertia(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::ValueMatrix_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_inertia(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/dh:1.0
//
::Value*
ParserModelObject::dh(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::Value_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_dh(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/ulimit:1.0
//
::Value*
ParserModelObject::ulimit(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::Value_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_ulimit(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/llimit:1.0
//
::Value*
ParserModelObject::llimit(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::Value_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_llimit(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/uvlimit:1.0
//
::Value*
ParserModelObject::uvlimit(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::Value_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_uvlimit(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/lvlimit:1.0
//
::Value*
ParserModelObject::lvlimit(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::Value_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_lvlimit(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/rotorInertia:1.0
//
CORBA::Double
ParserModelObject::rotorInertia(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA::Double _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    _ob_r = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_rotorInertia(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r;
}

//
// IDL:ParserModelObject/rotorResistor:1.0
//
CORBA::Double
ParserModelObject::rotorResistor(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA::Double _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    _ob_r = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_rotorResistor(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r;
}

//
// IDL:ParserModelObject/gearRatio:1.0
//
CORBA::Double
ParserModelObject::gearRatio(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA::Double _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    _ob_r = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_gearRatio(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r;
}

//
// IDL:ParserModelObject/torqueConst:1.0
//
CORBA::Double
ParserModelObject::torqueConst(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA::Double _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    _ob_r = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_torqueConst(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r;
}

//
// IDL:ParserModelObject/encoderPulse:1.0
//
CORBA::Double
ParserModelObject::encoderPulse(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA::Double _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    _ob_r = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_encoderPulse(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r;
}

//
// IDL:ParserModelObject/bboxCenter:1.0
//
::Value*
ParserModelObject::bboxCenter(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::Value_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_bboxCenter(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/bboxSize:1.0
//
::Value*
ParserModelObject::bboxSize(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::Value_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_bboxSize(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/name:1.0
//
char*
ParserModelObject::name(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA::String_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_name(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/jointType:1.0
//
char*
ParserModelObject::jointType(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA::String_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_jointType(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/jointId:1.0
//
CORBA::Short
ParserModelObject::jointId(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA::Short _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    _ob_r = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_jointId(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r;
}

//
// IDL:ParserModelObject/jointAxis:1.0
//
char*
ParserModelObject::jointAxis(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA::String_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_jointAxis(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:ParserModelObject/mother:1.0
//
CORBA::Long
ParserModelObject::mother(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA::Long _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    _ob_r = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_mother(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r;
}

//
// IDL:ParserModelObject/sister:1.0
//
CORBA::Long
ParserModelObject::sister(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA::Long _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    _ob_r = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_sister(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r;
}

//
// IDL:ParserModelObject/daughter:1.0
//
CORBA::Long
ParserModelObject::daughter(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA::Long _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    _ob_r = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_daughter(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r;
}

//
// IDL:ParserModelObject/sensors:1.0
//
::SensorInfoSeq*
ParserModelObject::sensors(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::SensorInfoSeq_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_sensors(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:stringSeq:1.0
//
static CORBA::AnyContentDestroyerDelete<stringSeq> OBAnyContentDestroyerInstance_stringSeq;

void
operator<<=(CORBA::Any& any, stringSeq* v)
{
    _OBE_C_CORBA_sequence_string* p = (_OBE_C_CORBA_sequence_string*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_stringSeq->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence_string));
    (*p)._length = (*v).length();
    (*p)._maximum = (*v).length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (CORBA_char**)OBEC_allocate_buffer(NULL, sizeof(CORBA_char*) * (*p)._length, (*p)._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
    {
        (*p)._buffer[_ob_i0] = CORBA_string_dup((*v)[_ob_i0]);
    }
    any.replace(_tc_stringSeq, p, false, v, &OBAnyContentDestroyerInstance_stringSeq);
}

void
operator<<=(CORBA::Any& any, const stringSeq& v)
{
    _OBE_C_CORBA_sequence_string* p = (_OBE_C_CORBA_sequence_string*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_stringSeq->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence_string));
    (*p)._length = v.length();
    (*p)._maximum = v.length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (CORBA_char**)OBEC_allocate_buffer(NULL, sizeof(CORBA_char*) * (*p)._length, (*p)._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
    {
        (*p)._buffer[_ob_i0] = CORBA_string_dup(v[_ob_i0]);
    }
    any.replace(_tc_stringSeq, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const stringSeq*& v)
{
    if (!any.check_type(_tc_stringSeq))
        return false;

    v = (const stringSeq*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_CORBA_sequence_string* p = (_OBE_C_CORBA_sequence_string*)any.value();
        assert(p != NULL);
        stringSeq* val = new stringSeq;
        (*val).length((*p)._length);

        for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
        {
            (*val)[_ob_i0] = CORBA::string_dup((*p)._buffer[_ob_i0]);
        }
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_stringSeq);
        v = val;
    }

    return true;
}

//
// IDL:ParserModelObjectSeq:1.0
//
static CORBA::AnyContentDestroyerDelete<ParserModelObjectSeq> OBAnyContentDestroyerInstance_ParserModelObjectSeq;

void
operator<<=(CORBA::Any& any, ParserModelObjectSeq* v)
{
    _OBE_C_CORBA_sequence__OBE_C_ParserModelObject* p = (_OBE_C_CORBA_sequence__OBE_C_ParserModelObject*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_ParserModelObjectSeq->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence__OBE_C_ParserModelObject));
    (*p)._length = (*v).length();
    (*p)._maximum = (*v).length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (_OBE_C_ParserModelObject*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_ParserModelObject) * (*p)._length, (*p)._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
    {
        if (CORBA::is_nil((*v)[_ob_i0]))
            (*p)._buffer[_ob_i0] = CORBA_OBJECT_NIL;
        else
            (*p)._buffer[_ob_i0] = CORBA_Object_duplicate((*v)[_ob_i0]->_OB_impl_nodup());
    }
    any.replace(_tc_ParserModelObjectSeq, p, false, v, &OBAnyContentDestroyerInstance_ParserModelObjectSeq);
}

void
operator<<=(CORBA::Any& any, const ParserModelObjectSeq& v)
{
    _OBE_C_CORBA_sequence__OBE_C_ParserModelObject* p = (_OBE_C_CORBA_sequence__OBE_C_ParserModelObject*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, _tc_ParserModelObjectSeq->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence__OBE_C_ParserModelObject));
    (*p)._length = v.length();
    (*p)._maximum = v.length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (_OBE_C_ParserModelObject*)OBEC_allocate_buffer(NULL, sizeof(_OBE_C_ParserModelObject) * (*p)._length, (*p)._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
    {
        if (CORBA::is_nil(v[_ob_i0]))
            (*p)._buffer[_ob_i0] = CORBA_OBJECT_NIL;
        else
            (*p)._buffer[_ob_i0] = CORBA_Object_duplicate(v[_ob_i0]->_OB_impl_nodup());
    }
    any.replace(_tc_ParserModelObjectSeq, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const ParserModelObjectSeq*& v)
{
    if (!any.check_type(_tc_ParserModelObjectSeq))
        return false;

    v = (const ParserModelObjectSeq*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_CORBA_sequence__OBE_C_ParserModelObject* p = (_OBE_C_CORBA_sequence__OBE_C_ParserModelObject*)any.value();
        assert(p != NULL);
        ParserModelObjectSeq* val = new ParserModelObjectSeq;
        (*val).length((*p)._length);

        for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
        {
            if ((*p)._buffer[_ob_i0] == CORBA_OBJECT_NIL)
                (*val)[_ob_i0] = ParserModelObject::_nil();
            else
            {
                (*val)[_ob_i0] = new ParserModelObject;
                (*val)[_ob_i0]->_OB_setup((*p)._buffer[_ob_i0]);
            }
        }
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_ParserModelObjectSeq);
        v = val;
    }

    return true;
}

//
// IDL:ParserCharObject:1.0
//
const char* ParserCharObject::ids_[] =
{
    "IDL:ParserCharObject:1.0",
    0
};

void
OBDuplicate(ParserCharObject_ptr p)
{
    if(p)
        p -> _OB_incRef();
}

void
OBRelease(ParserCharObject_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

ParserCharObject_ptr
ParserCharObject::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        ParserCharObject_ptr v = dynamic_cast<ParserCharObject_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            ::ParserCharObject* val = new ::ParserCharObject;
            val -> _OB_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

const char**
ParserCharObject::_OB_staticIds()
{
    return ids_;
}

const char**
ParserCharObject::_OB_ids() const
{
    return ::ParserCharObject::ids_;
}

void
OBMarshal(
    ParserCharObject_ptr _ob_v,
    OBEC_OutputStreamImpl* _ob_out,
    CORBA_Environment* _ob_cev
)
{
    CORBA_Object _ob_cobj = NULL;
    if (_ob_v)
    {
        _ob_cobj = _ob_v->_OB_impl_nodup();
        assert(_ob_cobj != NULL);
    }
    OBEC_OutputStreamImpl_write_Object(_ob_out, _ob_cobj, _ob_cev);
}

void
OBUnmarshal(
    ParserCharObject_ptr& _ob_v,
    OBEC_InputStreamImpl* _ob_in,
    CORBA_Environment* _ob_cev
)
{
    ParserCharObject_var old = _ob_v;
    CORBA_Object _ob_cobj = OBEC_InputStreamImpl_read_Object(_ob_in, _ob_cev);

    if (_ob_cobj != NULL && _ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_v = new ParserCharObject;
        _ob_v->_OB_setup(_ob_cobj);
        CORBA_Object_release(_ob_cobj);
    }
    else
        _ob_v = ParserCharObject::_nil();
}

//
// IDL:ParserCharObject/name:1.0
//
char*
ParserCharObject::_OB_att_name(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    CORBA::String_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_name", 9, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = OBEC_InputStreamImpl_read_string(_ob_in, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

//
// IDL:ParserCharObject/info:1.0
//
::stringSeq*
ParserCharObject::_OB_att_info(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::stringSeq_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_info", 9, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = new ::stringSeq;
                CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
                _ob_r -> length(_ob_len0);
                char* * _ob_buf0 = _ob_r -> get_buffer();
                for(CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
                {
                    CORBA::string_free(_ob_buf0[_ob_i0]);
                    _ob_buf0[_ob_i0] = 0;
                    _ob_buf0[_ob_i0] = OBEC_InputStreamImpl_read_string(_ob_in, _ob_cev);
                }
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

//
// IDL:ParserCharObject/modelObjectSeq:1.0
//
::ParserModelObjectSeq*
ParserCharObject::_OB_att_modelObjectSeq(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::ParserModelObjectSeq_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile,  _ob_stub_impl->m_policies, "_get_modelObjectSeq", 19, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (!OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                _ob_r = new ::ParserModelObjectSeq;
                CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
                _ob_r -> length(_ob_len0);
                ::ParserModelObject_ptr * _ob_buf0 = _ob_r -> get_buffer();
                for(CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
                {
                    OBUnmarshal(_ob_buf0[_ob_i0], _ob_in, _ob_cev);
                }
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }
            }

            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

void
operator<<=(CORBA::Any& any, ParserCharObject_ptr* v)
{
    CORBA_Object cobj = CORBA_OBJECT_NIL;
    if (!CORBA::is_nil(*v))
    {
        cobj = (*v)->_OB_impl_nodup();
    }
    any.replace(_tc_ParserCharObject, &cobj, true, (CORBA::Object_ptr)*v, &CORBA::Any::sm_any_content_destroyer_object);
}

void
operator<<=(CORBA::Any& any, ParserCharObject_ptr v)
{
    ParserCharObject_ptr val = ParserCharObject::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, ParserCharObject_ptr& v)
{
    if (any.check_type(_tc_ParserCharObject))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.cpp_value();
        if (!CORBA::is_nil(val))
            v = dynamic_cast<ParserCharObject_ptr>(val);
        else
        {
            CORBA_Object cobj = *(CORBA_Object*)any.value();
            if (cobj != CORBA_OBJECT_NIL)
            {
                ParserCharObject* obj = new ParserCharObject;
                obj->_OB_setup(cobj);
                v = obj;
                ((CORBA::Any&)any).cpp_value((CORBA::Object_ptr)obj, &CORBA::Any::sm_any_content_destroyer_object);
            }
            else
                v = ParserCharObject::_nil();
        }

        return true;
    }
    else
        return false;
}

//
// IDL:ParserCharObject/name:1.0
//
char*
ParserCharObject::name(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA::String_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_name(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:ParserCharObject/info:1.0
//
::stringSeq*
ParserCharObject::info(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::stringSeq_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_info(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:ParserCharObject/modelObjectSeq:1.0
//
::ParserModelObjectSeq*
ParserCharObject::modelObjectSeq(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::ParserModelObjectSeq_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_att_modelObjectSeq(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:ModelInfo:1.0
//
const char* ModelInfo::ids_[] =
{
    "IDL:ModelInfo:1.0",
    0
};

void
OBDuplicate(ModelInfo_ptr p)
{
    if(p)
        p -> _OB_incRef();
}

void
OBRelease(ModelInfo_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

ModelInfo_ptr
ModelInfo::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        ModelInfo_ptr v = dynamic_cast<ModelInfo_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            ::ModelInfo* val = new ::ModelInfo;
            val -> _OB_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

const char**
ModelInfo::_OB_staticIds()
{
    return ids_;
}

const char**
ModelInfo::_OB_ids() const
{
    return ::ModelInfo::ids_;
}

void
OBMarshal(
    ModelInfo_ptr _ob_v,
    OBEC_OutputStreamImpl* _ob_out,
    CORBA_Environment* _ob_cev
)
{
    CORBA_Object _ob_cobj = NULL;
    if (_ob_v)
    {
        _ob_cobj = _ob_v->_OB_impl_nodup();
        assert(_ob_cobj != NULL);
    }
    OBEC_OutputStreamImpl_write_Object(_ob_out, _ob_cobj, _ob_cev);
}

void
OBUnmarshal(
    ModelInfo_ptr& _ob_v,
    OBEC_InputStreamImpl* _ob_in,
    CORBA_Environment* _ob_cev
)
{
    ModelInfo_var old = _ob_v;
    CORBA_Object _ob_cobj = OBEC_InputStreamImpl_read_Object(_ob_in, _ob_cev);

    if (_ob_cobj != NULL && _ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_v = new ModelInfo;
        _ob_v->_OB_setup(_ob_cobj);
        CORBA_Object_release(_ob_cobj);
    }
    else
        _ob_v = ModelInfo::_nil();
}

//
// IDL:ModelInfo/getUrl:1.0
//
char*
ModelInfo::_OB_op_getUrl(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    CORBA::String_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile, _ob_stub_impl->m_policies, "getUrl", 6, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }
            else
            {
                _ob_r = OBEC_InputStreamImpl_read_string(_ob_in, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }

                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

//
// IDL:ModelInfo/getCharObject:1.0
//
::ParserCharObject_ptr
ModelInfo::_OB_op_getCharObject(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::ParserCharObject_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile, _ob_stub_impl->m_policies, "getCharObject", 13, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }
            else
            {
                OBUnmarshal(_ob_r.inout(), _ob_in, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }

                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

//
// IDL:ModelInfo/getJointList:1.0
//
::ModelInfo::NameSeq*
ModelInfo::_OB_op_getJointList(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::ModelInfo::NameSeq_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile, _ob_stub_impl->m_policies, "getJointList", 12, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }
            else
            {
                _ob_r = new ::ModelInfo::NameSeq;
                CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
                _ob_r -> length(_ob_len0);
                char* * _ob_buf0 = _ob_r -> get_buffer();
                for(CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
                {
                    CORBA::string_free(_ob_buf0[_ob_i0]);
                    _ob_buf0[_ob_i0] = 0;
                    _ob_buf0[_ob_i0] = OBEC_InputStreamImpl_read_string(_ob_in, _ob_cev);
                }
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }

                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

//
// IDL:ModelInfo/readTriangles:1.0
//
::ModelInfo::floatSeq*
ModelInfo::_OB_op_readTriangles(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    const char* jointName,
    CORBA::Long count,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::ModelInfo::floatSeq_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_OutputStreamImpl* _ob_out;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile, _ob_stub_impl->m_policies, "readTriangles", 13, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            _ob_out = OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            OBEC_OutputStreamImpl_write_string(_ob_out, jointName, _ob_cev);
            OBEC_OutputStreamImpl_write_long(_ob_out, count, _ob_cev);
            if (_ob_cev->_major == CORBA_SYSTEM_EXCEPTION)
            {
                OBEC_DowncallImpl_marshalEx(&_ob_down, _ob_cev);
                break;
            }

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }
            else
            {
                _ob_r = new ::ModelInfo::floatSeq;
                CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
                _ob_r -> length(_ob_len0);
                OBEC_InputStreamImpl_read_float_array(_ob_in, _ob_r -> get_buffer(), _ob_len0, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }

                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

//
// IDL:ModelInfo/destroy:1.0
//
void
ModelInfo::_OB_op_destroy(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile, _ob_stub_impl->m_policies, "destroy", 7, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);



            if (OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }
            else
            {
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);
}

void
operator<<=(CORBA::Any& any, ModelInfo_ptr* v)
{
    CORBA_Object cobj = CORBA_OBJECT_NIL;
    if (!CORBA::is_nil(*v))
    {
        cobj = (*v)->_OB_impl_nodup();
    }
    any.replace(_tc_ModelInfo, &cobj, true, (CORBA::Object_ptr)*v, &CORBA::Any::sm_any_content_destroyer_object);
}

void
operator<<=(CORBA::Any& any, ModelInfo_ptr v)
{
    ModelInfo_ptr val = ModelInfo::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, ModelInfo_ptr& v)
{
    if (any.check_type(_tc_ModelInfo))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.cpp_value();
        if (!CORBA::is_nil(val))
            v = dynamic_cast<ModelInfo_ptr>(val);
        else
        {
            CORBA_Object cobj = *(CORBA_Object*)any.value();
            if (cobj != CORBA_OBJECT_NIL)
            {
                ModelInfo* obj = new ModelInfo;
                obj->_OB_setup(cobj);
                v = obj;
                ((CORBA::Any&)any).cpp_value((CORBA::Object_ptr)obj, &CORBA::Any::sm_any_content_destroyer_object);
            }
            else
                v = ModelInfo::_nil();
        }

        return true;
    }
    else
        return false;
}

//
// IDL:ModelInfo/floatSeq:1.0
//
static CORBA::AnyContentDestroyerDelete<ModelInfo::floatSeq> OBAnyContentDestroyerInstance_ModelInfo_floatSeq;

void
operator<<=(CORBA::Any& any, ModelInfo::floatSeq* v)
{
    _OBE_C_CORBA_sequence_float* p = (_OBE_C_CORBA_sequence_float*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, ModelInfo::_tc_floatSeq->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence_float));
    (*p)._length = (*v).length();
    (*p)._maximum = (*v).length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (CORBA_float*)OBEC_allocate_buffer(NULL, sizeof(CORBA_float) * (*p)._length, (*p)._length, OBEC_FALSE);

    memcpy((*p)._buffer, (*v).get_buffer(), sizeof(CORBA_float) * (*p)._length);
    any.replace(ModelInfo::_tc_floatSeq, p, false, v, &OBAnyContentDestroyerInstance_ModelInfo_floatSeq);
}

void
operator<<=(CORBA::Any& any, const ModelInfo::floatSeq& v)
{
    _OBE_C_CORBA_sequence_float* p = (_OBE_C_CORBA_sequence_float*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, ModelInfo::_tc_floatSeq->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence_float));
    (*p)._length = v.length();
    (*p)._maximum = v.length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (CORBA_float*)OBEC_allocate_buffer(NULL, sizeof(CORBA_float) * (*p)._length, (*p)._length, OBEC_FALSE);

    memcpy((*p)._buffer, v.get_buffer(), sizeof(CORBA_float) * (*p)._length);
    any.replace(ModelInfo::_tc_floatSeq, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const ModelInfo::floatSeq*& v)
{
    if (!any.check_type(ModelInfo::_tc_floatSeq))
        return false;

    v = (const ModelInfo::floatSeq*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_CORBA_sequence_float* p = (_OBE_C_CORBA_sequence_float*)any.value();
        assert(p != NULL);
        ModelInfo::floatSeq* val = new ModelInfo::floatSeq;
        (*val).length((*p)._length);

        memcpy((*val).get_buffer(), (*p)._buffer, sizeof(CORBA_float) * (*p)._length);
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_ModelInfo_floatSeq);
        v = val;
    }

    return true;
}

//
// IDL:ModelInfo/NameSeq:1.0
//
static CORBA::AnyContentDestroyerDelete<ModelInfo::NameSeq> OBAnyContentDestroyerInstance_ModelInfo_NameSeq;

void
operator<<=(CORBA::Any& any, ModelInfo::NameSeq* v)
{
    _OBE_C_CORBA_sequence_string* p = (_OBE_C_CORBA_sequence_string*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, ModelInfo::_tc_NameSeq->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence_string));
    (*p)._length = (*v).length();
    (*p)._maximum = (*v).length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (CORBA_char**)OBEC_allocate_buffer(NULL, sizeof(CORBA_char*) * (*p)._length, (*p)._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
    {
        (*p)._buffer[_ob_i0] = CORBA_string_dup((*v)[_ob_i0]);
    }
    any.replace(ModelInfo::_tc_NameSeq, p, false, v, &OBAnyContentDestroyerInstance_ModelInfo_NameSeq);
}

void
operator<<=(CORBA::Any& any, const ModelInfo::NameSeq& v)
{
    _OBE_C_CORBA_sequence_string* p = (_OBE_C_CORBA_sequence_string*)OBEC_allocate_with_arg(CORBA_any__fini_with_typecode, ModelInfo::_tc_NameSeq->_OB_impl_nodup(), sizeof(_OBE_C_CORBA_sequence_string));
    (*p)._length = v.length();
    (*p)._maximum = v.length();
    (*p)._release = OBEC_TRUE;
    (*p)._buffer = (CORBA_char**)OBEC_allocate_buffer(NULL, sizeof(CORBA_char*) * (*p)._length, (*p)._length, OBEC_FALSE);

    for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
    {
        (*p)._buffer[_ob_i0] = CORBA_string_dup(v[_ob_i0]);
    }
    any.replace(ModelInfo::_tc_NameSeq, p, 0);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const ModelInfo::NameSeq*& v)
{
    if (!any.check_type(ModelInfo::_tc_NameSeq))
        return false;

    v = (const ModelInfo::NameSeq*)any.cpp_value();
    if (v == 0)
    {
        _OBE_C_CORBA_sequence_string* p = (_OBE_C_CORBA_sequence_string*)any.value();
        assert(p != NULL);
        ModelInfo::NameSeq* val = new ModelInfo::NameSeq;
        (*val).length((*p)._length);

        for (CORBA::ULong _ob_i0 = 0; _ob_i0 < (*p)._length; _ob_i0++)
        {
            (*val)[_ob_i0] = CORBA::string_dup((*p)._buffer[_ob_i0]);
        }
        ((CORBA::Any&)any).cpp_value(val, &OBAnyContentDestroyerInstance_ModelInfo_NameSeq);
        v = val;
    }

    return true;
}

//
// IDL:ModelInfo/getUrl:1.0
//
char*
ModelInfo::getUrl(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA::String_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_op_getUrl(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:ModelInfo/getCharObject:1.0
//
::ParserCharObject_ptr
ModelInfo::getCharObject(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::ParserCharObject_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_op_getCharObject(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:ModelInfo/getJointList:1.0
//
::ModelInfo::NameSeq*
ModelInfo::getJointList(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::ModelInfo::NameSeq_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_op_getJointList(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:ModelInfo/readTriangles:1.0
//
::ModelInfo::floatSeq*
ModelInfo::readTriangles(
    const char* jointName,
    CORBA::Long count
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::ModelInfo::floatSeq_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_op_readTriangles(_ob_stub_impl, jointName, count, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:ModelInfo/destroy:1.0
//
void
ModelInfo::destroy(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _OB_op_destroy(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();
}

//
// IDL:OpenHRPObject:1.0
//
const char* OpenHRPObject::ids_[] =
{
    "IDL:OpenHRPObject:1.0",
    0
};

void
OBDuplicate(OpenHRPObject_ptr p)
{
    if(p)
        p -> _OB_incRef();
}

void
OBRelease(OpenHRPObject_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

OpenHRPObject_ptr
OpenHRPObject::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        OpenHRPObject_ptr v = dynamic_cast<OpenHRPObject_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            ::OpenHRPObject* val = new ::OpenHRPObject;
            val -> _OB_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

const char**
OpenHRPObject::_OB_staticIds()
{
    return ids_;
}

const char**
OpenHRPObject::_OB_ids() const
{
    return ::OpenHRPObject::ids_;
}

void
OBMarshal(
    OpenHRPObject_ptr _ob_v,
    OBEC_OutputStreamImpl* _ob_out,
    CORBA_Environment* _ob_cev
)
{
    CORBA_Object _ob_cobj = NULL;
    if (_ob_v)
    {
        _ob_cobj = _ob_v->_OB_impl_nodup();
        assert(_ob_cobj != NULL);
    }
    OBEC_OutputStreamImpl_write_Object(_ob_out, _ob_cobj, _ob_cev);
}

void
OBUnmarshal(
    OpenHRPObject_ptr& _ob_v,
    OBEC_InputStreamImpl* _ob_in,
    CORBA_Environment* _ob_cev
)
{
    OpenHRPObject_var old = _ob_v;
    CORBA_Object _ob_cobj = OBEC_InputStreamImpl_read_Object(_ob_in, _ob_cev);

    if (_ob_cobj != NULL && _ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_v = new OpenHRPObject;
        _ob_v->_OB_setup(_ob_cobj);
        CORBA_Object_release(_ob_cobj);
    }
    else
        _ob_v = OpenHRPObject::_nil();
}

//
// IDL:OpenHRPObject/shutdown:1.0
//
void
OpenHRPObject::_OB_op_shutdown(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile, _ob_stub_impl->m_policies, "shutdown", 8, OBEC_FALSE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_oneway(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);



            OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);
}

void
operator<<=(CORBA::Any& any, OpenHRPObject_ptr* v)
{
    CORBA_Object cobj = CORBA_OBJECT_NIL;
    if (!CORBA::is_nil(*v))
    {
        cobj = (*v)->_OB_impl_nodup();
    }
    any.replace(_tc_OpenHRPObject, &cobj, true, (CORBA::Object_ptr)*v, &CORBA::Any::sm_any_content_destroyer_object);
}

void
operator<<=(CORBA::Any& any, OpenHRPObject_ptr v)
{
    OpenHRPObject_ptr val = OpenHRPObject::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, OpenHRPObject_ptr& v)
{
    if (any.check_type(_tc_OpenHRPObject))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.cpp_value();
        if (!CORBA::is_nil(val))
            v = dynamic_cast<OpenHRPObject_ptr>(val);
        else
        {
            CORBA_Object cobj = *(CORBA_Object*)any.value();
            if (cobj != CORBA_OBJECT_NIL)
            {
                OpenHRPObject* obj = new OpenHRPObject;
                obj->_OB_setup(cobj);
                v = obj;
                ((CORBA::Any&)any).cpp_value((CORBA::Object_ptr)obj, &CORBA::Any::sm_any_content_destroyer_object);
            }
            else
                v = OpenHRPObject::_nil();
        }

        return true;
    }
    else
        return false;
}

//
// IDL:OpenHRPObject/shutdown:1.0
//
void
OpenHRPObject::shutdown(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _OB_op_shutdown(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();
}

//
// IDL:CommandReceiver:1.0
//
const char* CommandReceiver::ids_[] =
{
    "IDL:CommandReceiver:1.0",
    0
};

void
OBDuplicate(CommandReceiver_ptr p)
{
    if(p)
        p -> _OB_incRef();
}

void
OBRelease(CommandReceiver_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

CommandReceiver_ptr
CommandReceiver::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        CommandReceiver_ptr v = dynamic_cast<CommandReceiver_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            ::CommandReceiver* val = new ::CommandReceiver;
            val -> _OB_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

const char**
CommandReceiver::_OB_staticIds()
{
    return ids_;
}

const char**
CommandReceiver::_OB_ids() const
{
    return ::CommandReceiver::ids_;
}

void
OBMarshal(
    CommandReceiver_ptr _ob_v,
    OBEC_OutputStreamImpl* _ob_out,
    CORBA_Environment* _ob_cev
)
{
    CORBA_Object _ob_cobj = NULL;
    if (_ob_v)
    {
        _ob_cobj = _ob_v->_OB_impl_nodup();
        assert(_ob_cobj != NULL);
    }
    OBEC_OutputStreamImpl_write_Object(_ob_out, _ob_cobj, _ob_cev);
}

void
OBUnmarshal(
    CommandReceiver_ptr& _ob_v,
    OBEC_InputStreamImpl* _ob_in,
    CORBA_Environment* _ob_cev
)
{
    CommandReceiver_var old = _ob_v;
    CORBA_Object _ob_cobj = OBEC_InputStreamImpl_read_Object(_ob_in, _ob_cev);

    if (_ob_cobj != NULL && _ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_v = new CommandReceiver;
        _ob_v->_OB_setup(_ob_cobj);
        CORBA_Object_release(_ob_cobj);
    }
    else
        _ob_v = CommandReceiver::_nil();
}

//
// IDL:CommandReceiver/sendMsg:1.0
//
void
CommandReceiver::_OB_op_sendMsg(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    const char* msg,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_OutputStreamImpl* _ob_out;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile, _ob_stub_impl->m_policies, "sendMsg", 7, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            _ob_out = OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            OBEC_OutputStreamImpl_write_string(_ob_out, msg, _ob_cev);
            if (_ob_cev->_major == CORBA_SYSTEM_EXCEPTION)
            {
                OBEC_DowncallImpl_marshalEx(&_ob_down, _ob_cev);
                break;
            }

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);



            if (OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }
            else
            {
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);
}

void
operator<<=(CORBA::Any& any, CommandReceiver_ptr* v)
{
    CORBA_Object cobj = CORBA_OBJECT_NIL;
    if (!CORBA::is_nil(*v))
    {
        cobj = (*v)->_OB_impl_nodup();
    }
    any.replace(_tc_CommandReceiver, &cobj, true, (CORBA::Object_ptr)*v, &CORBA::Any::sm_any_content_destroyer_object);
}

void
operator<<=(CORBA::Any& any, CommandReceiver_ptr v)
{
    CommandReceiver_ptr val = CommandReceiver::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, CommandReceiver_ptr& v)
{
    if (any.check_type(_tc_CommandReceiver))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.cpp_value();
        if (!CORBA::is_nil(val))
            v = dynamic_cast<CommandReceiver_ptr>(val);
        else
        {
            CORBA_Object cobj = *(CORBA_Object*)any.value();
            if (cobj != CORBA_OBJECT_NIL)
            {
                CommandReceiver* obj = new CommandReceiver;
                obj->_OB_setup(cobj);
                v = obj;
                ((CORBA::Any&)any).cpp_value((CORBA::Object_ptr)obj, &CORBA::Any::sm_any_content_destroyer_object);
            }
            else
                v = CommandReceiver::_nil();
        }

        return true;
    }
    else
        return false;
}

//
// IDL:CommandReceiver/sendMsg:1.0
//
void
CommandReceiver::sendMsg(
    const char* msg
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _OB_op_sendMsg(_ob_stub_impl, msg, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();
}

//
// IDL:Plugin:1.0
//
const char* Plugin::ids_[] =
{
    "IDL:Plugin:1.0",
    "IDL:CommandReceiver:1.0",
    0
};

void
OBDuplicate(Plugin_ptr p)
{
    if(p)
        p -> _OB_incRef();
}

void
OBRelease(Plugin_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

Plugin_ptr
Plugin::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        Plugin_ptr v = dynamic_cast<Plugin_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            ::Plugin* val = new ::Plugin;
            val -> _OB_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

const char**
Plugin::_OB_staticIds()
{
    return ids_;
}

const char**
Plugin::_OB_ids() const
{
    return ::Plugin::ids_;
}

void
OBMarshal(
    Plugin_ptr _ob_v,
    OBEC_OutputStreamImpl* _ob_out,
    CORBA_Environment* _ob_cev
)
{
    CORBA_Object _ob_cobj = NULL;
    if (_ob_v)
    {
        _ob_cobj = _ob_v->_OB_impl_nodup();
        assert(_ob_cobj != NULL);
    }
    OBEC_OutputStreamImpl_write_Object(_ob_out, _ob_cobj, _ob_cev);
}

void
OBUnmarshal(
    Plugin_ptr& _ob_v,
    OBEC_InputStreamImpl* _ob_in,
    CORBA_Environment* _ob_cev
)
{
    Plugin_var old = _ob_v;
    CORBA_Object _ob_cobj = OBEC_InputStreamImpl_read_Object(_ob_in, _ob_cev);

    if (_ob_cobj != NULL && _ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_v = new Plugin;
        _ob_v->_OB_setup(_ob_cobj);
        CORBA_Object_release(_ob_cobj);
    }
    else
        _ob_v = Plugin::_nil();
}

//
// IDL:Plugin/start:1.0
//
void
Plugin::_OB_op_start(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile, _ob_stub_impl->m_policies, "start", 5, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);



            if (OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }
            else
            {
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);
}

//
// IDL:Plugin/stop:1.0
//
void
Plugin::_OB_op_stop(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile, _ob_stub_impl->m_policies, "stop", 4, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);



            if (OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }
            else
            {
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);
}

void
operator<<=(CORBA::Any& any, Plugin_ptr* v)
{
    CORBA_Object cobj = CORBA_OBJECT_NIL;
    if (!CORBA::is_nil(*v))
    {
        cobj = (*v)->_OB_impl_nodup();
    }
    any.replace(_tc_Plugin, &cobj, true, (CORBA::Object_ptr)*v, &CORBA::Any::sm_any_content_destroyer_object);
}

void
operator<<=(CORBA::Any& any, Plugin_ptr v)
{
    Plugin_ptr val = Plugin::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, Plugin_ptr& v)
{
    if (any.check_type(_tc_Plugin))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.cpp_value();
        if (!CORBA::is_nil(val))
            v = dynamic_cast<Plugin_ptr>(val);
        else
        {
            CORBA_Object cobj = *(CORBA_Object*)any.value();
            if (cobj != CORBA_OBJECT_NIL)
            {
                Plugin* obj = new Plugin;
                obj->_OB_setup(cobj);
                v = obj;
                ((CORBA::Any&)any).cpp_value((CORBA::Object_ptr)obj, &CORBA::Any::sm_any_content_destroyer_object);
            }
            else
                v = Plugin::_nil();
        }

        return true;
    }
    else
        return false;
}

//
// IDL:Plugin/start:1.0
//
void
Plugin::start(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _OB_op_start(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();
}

//
// IDL:Plugin/stop:1.0
//
void
Plugin::stop(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _OB_op_stop(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();
}

//
// IDL:PluginManager:1.0
//
const char* PluginManager::ids_[] =
{
    "IDL:PluginManager:1.0",
    "IDL:CommandReceiver:1.0",
    0
};

void
OBDuplicate(PluginManager_ptr p)
{
    if(p)
        p -> _OB_incRef();
}

void
OBRelease(PluginManager_ptr p)
{
    if(p)
        p -> _OB_decRef();
}

PluginManager_ptr
PluginManager::_narrow(CORBA::Object_ptr p)
{
    if(!CORBA::is_nil(p))
    {
        PluginManager_ptr v = dynamic_cast<PluginManager_ptr>(p);
        if(v)
            return _duplicate(v);

        if(p -> _is_a(ids_[0]))
        {
            ::PluginManager* val = new ::PluginManager;
            val -> _OB_copyFrom(p);
            return val;
        }
    }

    return _nil();
}

const char**
PluginManager::_OB_staticIds()
{
    return ids_;
}

const char**
PluginManager::_OB_ids() const
{
    return ::PluginManager::ids_;
}

void
OBMarshal(
    PluginManager_ptr _ob_v,
    OBEC_OutputStreamImpl* _ob_out,
    CORBA_Environment* _ob_cev
)
{
    CORBA_Object _ob_cobj = NULL;
    if (_ob_v)
    {
        _ob_cobj = _ob_v->_OB_impl_nodup();
        assert(_ob_cobj != NULL);
    }
    OBEC_OutputStreamImpl_write_Object(_ob_out, _ob_cobj, _ob_cev);
}

void
OBUnmarshal(
    PluginManager_ptr& _ob_v,
    OBEC_InputStreamImpl* _ob_in,
    CORBA_Environment* _ob_cev
)
{
    PluginManager_var old = _ob_v;
    CORBA_Object _ob_cobj = OBEC_InputStreamImpl_read_Object(_ob_in, _ob_cev);

    if (_ob_cobj != NULL && _ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_v = new PluginManager;
        _ob_v->_OB_setup(_ob_cobj);
        CORBA_Object_release(_ob_cobj);
    }
    else
        _ob_v = PluginManager::_nil();
}

//
// IDL:PluginManager/load:1.0
//
void
PluginManager::_OB_op_load(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    const char* name,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_OutputStreamImpl* _ob_out;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile, _ob_stub_impl->m_policies, "load", 4, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            _ob_out = OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            OBEC_OutputStreamImpl_write_string(_ob_out, name, _ob_cev);
            if (_ob_cev->_major == CORBA_SYSTEM_EXCEPTION)
            {
                OBEC_DowncallImpl_marshalEx(&_ob_down, _ob_cev);
                break;
            }

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);



            if (OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }
            else
            {
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);
}

//
// IDL:PluginManager/create:1.0
//
::Plugin_ptr
PluginManager::_OB_op_create(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    const char* pclass,
    const char* name,
    const char* args,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::Plugin_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_OutputStreamImpl* _ob_out;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile, _ob_stub_impl->m_policies, "create", 6, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            _ob_out = OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            OBEC_OutputStreamImpl_write_string(_ob_out, pclass, _ob_cev);
            OBEC_OutputStreamImpl_write_string(_ob_out, name, _ob_cev);
            OBEC_OutputStreamImpl_write_string(_ob_out, args, _ob_cev);
            if (_ob_cev->_major == CORBA_SYSTEM_EXCEPTION)
            {
                OBEC_DowncallImpl_marshalEx(&_ob_down, _ob_cev);
                break;
            }

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }
            else
            {
                OBUnmarshal(_ob_r.inout(), _ob_in, _ob_cev);
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }

                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

//
// IDL:PluginManager/getPluginNames:1.0
//
::stringSeq*
PluginManager::_OB_op_getPluginNames(
    OBEC_MarshalStubImpl_ptr _ob_stub_impl,
    CORBA_Environment* _ob_cev
)
{
    CORBA::Boolean _ob_init;
    OBEC_Client_ptr _ob_client = NULL;
    OBEC_RefCountProfileInfo* _ob_profile = NULL;
    ::stringSeq_var _ob_r;

    OBEC_PROLOG(_ob_cev);

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__OB_bind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
    OBEC_MarshalStubImpl__OB_bind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif

    CORBA::Boolean _ob_success = 0;
    while (_ob_cev->_major == CORBA_NO_EXCEPTION && !_ob_success)
    {
        OBEC_DowncallImpl _ob_down;
        OBEC_InputStreamImpl* _ob_in;

        while (1)
        {
            _ob_init = 0;

            OBEC_DowncallImpl__init(&_ob_down, _ob_stub_impl->m_orb_instance, _ob_client, _ob_profile, _ob_stub_impl->m_policies, "getPluginNames", 14, OBEC_TRUE, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_init = 1;

            OBEC_DowncallImpl_preMarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            OBEC_DowncallImpl_request(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            _ob_in = OBEC_DowncallImpl_preUnmarshal(&_ob_down, _ob_cev);
            OBE_BREAK_EXCEPTION(_ob_cev);

            if (OBEC_DowncallImpl_userException(&_ob_down, _ob_cev))
            {
                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }
            else
            {
                _ob_r = new ::stringSeq;
                CORBA::ULong _ob_len0 = OBEC_InputStreamImpl_read_ulong(_ob_in, _ob_cev);
                _ob_r -> length(_ob_len0);
                char* * _ob_buf0 = _ob_r -> get_buffer();
                for(CORBA::ULong _ob_i0 = 0 ; _ob_i0 < _ob_len0 ; _ob_i0++)
                {
                    CORBA::string_free(_ob_buf0[_ob_i0]);
                    _ob_buf0[_ob_i0] = 0;
                    _ob_buf0[_ob_i0] = OBEC_InputStreamImpl_read_string(_ob_in, _ob_cev);
                }
                if (_ob_cev->_major != CORBA_NO_EXCEPTION)
                {
                    OBEC_DowncallImpl_unmarshalEx(&_ob_down, _ob_cev);
                    break;
                }

                OBEC_DowncallImpl_postUnmarshal(&_ob_down, _ob_cev);
                OBE_BREAK_EXCEPTION(_ob_cev);
            }

            OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            _ob_init = 0;
            OBE_BREAK_EXCEPTION(_ob_cev);
            _ob_success = 1;
            break;
        }

        if (!_ob_success)
        {
            if (_ob_cev->_major == OBEC_FAILURE_EXCEPTION)
            {
#ifdef HAVE_OBE_THREAD_POOL
                OBEC_MarshalStubImpl__OB_rebind(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#else
                OBEC_MarshalStubImpl__OB_rebind_nodup(_ob_stub_impl, &_ob_client, &_ob_profile, _ob_cev);
#endif
            }
            if (_ob_init)
            {
                OBEC_DowncallImpl__fini(&_ob_down, _ob_cev);
            }
        }
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_Client__release(_ob_client);
    OBEC_RefCountProfileInfo__release(_ob_profile);
#endif

    OBEC_EPILOG_EX(_ob_cev);

    return _ob_r._retn();
}

void
operator<<=(CORBA::Any& any, PluginManager_ptr* v)
{
    CORBA_Object cobj = CORBA_OBJECT_NIL;
    if (!CORBA::is_nil(*v))
    {
        cobj = (*v)->_OB_impl_nodup();
    }
    any.replace(_tc_PluginManager, &cobj, true, (CORBA::Object_ptr)*v, &CORBA::Any::sm_any_content_destroyer_object);
}

void
operator<<=(CORBA::Any& any, PluginManager_ptr v)
{
    PluginManager_ptr val = PluginManager::_duplicate(v);
    any <<= &val;
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, PluginManager_ptr& v)
{
    if (any.check_type(_tc_PluginManager))
    {
        CORBA::Object_ptr val = (CORBA::Object_ptr)any.cpp_value();
        if (!CORBA::is_nil(val))
            v = dynamic_cast<PluginManager_ptr>(val);
        else
        {
            CORBA_Object cobj = *(CORBA_Object*)any.value();
            if (cobj != CORBA_OBJECT_NIL)
            {
                PluginManager* obj = new PluginManager;
                obj->_OB_setup(cobj);
                v = obj;
                ((CORBA::Any&)any).cpp_value((CORBA::Object_ptr)obj, &CORBA::Any::sm_any_content_destroyer_object);
            }
            else
                v = PluginManager::_nil();
        }

        return true;
    }
    else
        return false;
}

//
// IDL:PluginManager/load:1.0
//
void
PluginManager::load(
    const char* name
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _OB_op_load(_ob_stub_impl, name, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();
}

//
// IDL:PluginManager/create:1.0
//
::Plugin_ptr
PluginManager::create(
    const char* pclass,
    const char* name,
    const char* args
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::Plugin_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_op_create(_ob_stub_impl, pclass, name, args, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}

//
// IDL:PluginManager/getPluginNames:1.0
//
::stringSeq*
PluginManager::getPluginNames(
)
{
    OB::Environment _ob_env;
    CORBA_Environment* _ob_cev = _ob_env.get_cenv();
    ::stringSeq_var _ob_r;
    CORBA_boolean _ob_retry = OBEC_TRUE;
    OBCORBA_Object_ptr _ob_obj = (OBCORBA_Object_ptr)_OB_impl_nodup();
    assert_nca(_ob_obj != CORBA_OBJECT_NIL, OBEC_NCANullValue);
    OBEC_MarshalStubImpl_ptr _ob_stub_impl;
#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex* _ob_mut = OBCORBA_Object__OB_mutex(_ob_obj, _ob_cev);
    JTCC_Mutex_lock_noenv(_ob_mut);
#endif

#ifdef HAVE_OBE_THREAD_POOL
    _ob_stub_impl = OBCORBA_Object__OB_bind(_ob_obj, _ob_cev);
#else
    _ob_stub_impl = OBCORBA_Object__OB_bind_nodup(_ob_obj, _ob_cev);
#endif

    while (_ob_cev->_major == CORBA_NO_EXCEPTION)
    {
        _ob_r = _OB_op_getPluginNames(_ob_stub_impl, _ob_cev);
        if (_ob_cev->_major == CORBA_NO_EXCEPTION)
        {
            break;
        }

#ifdef HAVE_OBE_THREAD_POOL
        _ob_stub_impl = OBCORBA_Object__OB_rebind(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#else
        _ob_stub_impl = OBCORBA_Object__OB_rebind_nodup(_ob_obj, _ob_stub_impl, _ob_cev, &_ob_retry);
#endif
    }

#ifdef HAVE_OBE_THREAD_POOL
    OBEC_MarshalStubImpl__release(_ob_stub_impl);
#endif

#ifndef HAVE_OBE_THREAD_POOL
    JTCC_Mutex_unlock_noenv(_ob_mut);
#endif

    _ob_env.raise();

    return _ob_r._retn();
}
