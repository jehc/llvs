// **********************************************************************
//
// Generated by the Orbix/E IDL-to-C++ Translator
//
// Copyright (c) 2003
// IONA Technologies, Inc.
// Waltham, MA, USA
//
// All Rights Reserved
//
// **********************************************************************

// Version: 2.2.0

#ifndef ___StereoVision_h__
#define ___StereoVision_h__

#include <common.h>
#include <visionsensor.h>

#ifndef OBEC_INTEGER_VERSION
#   error No Orbix/E version defined! Is <OBE/CORBA.h> included?
#endif

#ifndef OBEC_NO_VERSION_CHECK
#   if (OBEC_INTEGER_VERSION != 2020000L)
#       error Orbix/E version mismatch!
#   endif
#endif

class StereoVision;
typedef StereoVision* StereoVision_ptr;
typedef StereoVision* StereoVisionRef;
extern CORBA::TypeCode_ptr _tc_StereoVision;

 void OBDuplicate(StereoVision_ptr);
 void OBRelease(StereoVision_ptr);

 void OBMarshal(StereoVision_ptr, OBEC_OutputStreamImpl*, CORBA_Environment*);
 void OBUnmarshal(StereoVision_ptr&, OBEC_InputStreamImpl*, CORBA_Environment*);

#ifdef OBEA_DLL
#   ifndef HAVE_NO_EXPLICIT_TEMPLATES
template class  OB::ObjVar< StereoVision >;
#   endif
#endif
typedef OB::ObjVar< StereoVision > StereoVision_var;
#ifdef OBEA_DLL
#   ifndef HAVE_NO_EXPLICIT_TEMPLATES
template class  OB::ObjOut< StereoVision >;
#   endif
#endif
typedef OB::ObjOut< StereoVision > StereoVision_out;

//
// IDL:RangeMap:1.0
//
typedef OB::FixSeq< CORBA::Float, OBUnique_FloatBuffer > RangeMap;
typedef OB::SeqVar< OB::FixSeq< CORBA::Float, OBUnique_FloatBuffer > > RangeMap_var;
typedef OB::SeqOut< OB::FixSeq< CORBA::Float, OBUnique_FloatBuffer > > RangeMap_out;
extern CORBA::TypeCode_ptr _tc_RangeMap;

//
// IDL:StereoVision:1.0
//
class StereoVision : public OBCORBA::Object
{
    StereoVision(const StereoVision&);
    void operator=(const StereoVision&);

protected:

    static const char* ids_[];

public:

    StereoVision() { }
    virtual ~StereoVision() { }

    typedef StereoVision_ptr _ptr_type;
    typedef StereoVision_var _var_type;

    static inline StereoVision_ptr
    _duplicate(StereoVision_ptr p)
    {
        if (p)
            p -> _OB_incRef();
        return p;
    }

    static inline StereoVision_ptr
    _nil()
    {
        return 0;
    }

    static StereoVision_ptr _narrow(CORBA::Object_ptr);

    static const char** _OB_staticIds();
    virtual const char** _OB_ids() const;

    //
    // IDL:StereoVision/rbt2scmCalibStart:1.0
    //
    CORBA::Boolean rbt2scmCalibStart();

    //
    // IDL:StereoVision/rbt2scmCalibEnd:1.0
    //
    CORBA::Boolean rbt2scmCalibEnd();

    //
    // IDL:StereoVision/detectCrossMark:1.0
    //
    CORBA::Boolean detectCrossMark(const ::TransformQuaternion& robotHeadPos,
                                   const ::TransformQuaternion& robotHandPos);

    //
    // IDL:StereoVision/getObjectPosition:1.0
    //
    CORBA::Boolean getObjectPosition(const char* name,
                                     const ::TransformQuaternion& robotHeadPos,
                                     ::TransformQuaternion_out ObjectPosition);

    //
    // IDL:StereoVision/StartProcess:1.0
    //
    CORBA::Boolean StartProcess(const char* ProcessName);

    //
    // IDL:StereoVision/StopProcess:1.0
    //
    CORBA::Boolean StopProcess(const char* ProcessName);

    //
    // IDL:StereoVision/getImage:1.0
    //
    CORBA::Long getImage(CORBA::Long CameraID,
                         ::ImageData_out anImage,
                         char*& Format);

    //
    // IDL:StereoVision/getRangeMap:1.0
    //
    CORBA::Long getRangeMap(::RangeMap_out aRangeMap,
                            char*& Format);

protected:

    //
    // IDL:StereoVision/rbt2scmCalibStart:1.0
    //
    CORBA::Boolean
    _OB_op_rbt2scmCalibStart(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:StereoVision/rbt2scmCalibEnd:1.0
    //
    CORBA::Boolean
    _OB_op_rbt2scmCalibEnd(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:StereoVision/detectCrossMark:1.0
    //
    CORBA::Boolean
    _OB_op_detectCrossMark(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        const TransformQuaternion& robotHeadPos,
        const TransformQuaternion& robotHandPos,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:StereoVision/getObjectPosition:1.0
    //
    CORBA::Boolean
    _OB_op_getObjectPosition(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        const char* name,
        const TransformQuaternion& robotHeadPos,
        TransformQuaternion_out ObjectPosition,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:StereoVision/StartProcess:1.0
    //
    CORBA::Boolean
    _OB_op_StartProcess(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        const char* ProcessName,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:StereoVision/StopProcess:1.0
    //
    CORBA::Boolean
    _OB_op_StopProcess(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        const char* ProcessName,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:StereoVision/getImage:1.0
    //
    CORBA::Long
    _OB_op_getImage(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        CORBA::Long CameraID,
        ImageData_out anImage,
        char*& Format,
        CORBA_Environment* _ob_cev
    );

    //
    // IDL:StereoVision/getRangeMap:1.0
    //
    CORBA::Long
    _OB_op_getRangeMap(
        OBEC_MarshalStubImpl_ptr _ob_stub_impl,
        RangeMap_out aRangeMap,
        char*& Format,
        CORBA_Environment* _ob_cev
    );
};

//
// IDL:StereoVision:1.0
//
namespace CORBA
{

inline void
release(::StereoVision_ptr p)
{
    if (p)
        p -> _OB_decRef();
}

inline Boolean
is_nil(::StereoVision_ptr p)
{
    return p == 0;
}

} // End of namespace CORBA

void operator<<=(CORBA::Any&, StereoVision_ptr*);
void operator<<=(CORBA::Any&, StereoVision_ptr);
CORBA::Boolean operator>>=(const CORBA::Any&, StereoVision_ptr&);

inline void
operator<<=(CORBA::Any_var& any, StereoVision_ptr* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, StereoVision_ptr val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, StereoVision_ptr& val)
{
    return any.in() >>= val;
}

#endif
