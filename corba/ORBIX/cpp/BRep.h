// **********************************************************************
//
// Generated by the Orbix/E IDL-to-C++ Translator
//
// Copyright (c) 2003
// IONA Technologies, Inc.
// Waltham, MA, USA
//
// All Rights Reserved
//
// **********************************************************************

// Version: 2.2.0

#ifndef ___BRep_h__
#define ___BRep_h__

#include <common.h>

#ifndef OBEC_INTEGER_VERSION
#   error No Orbix/E version defined! Is <OBE/CORBA.h> included?
#endif

#ifndef OBEC_NO_VERSION_CHECK
#   if (OBEC_INTEGER_VERSION != 2020000L)
#       error Orbix/E version mismatch!
#   endif
#endif

//
// IDL:CBREP_Point:1.0
//
struct CBREP_Point;
typedef OB::FixVar< CBREP_Point > CBREP_Point_var;
typedef CBREP_Point& CBREP_Point_out;

struct CBREP_Point
{
    typedef CBREP_Point_var _var_type;

    CORBA::Long label;
    CORBA::Long n;
    CORBA::Long row;
    CORBA::Long col;
    CORBA::Float rowd;
    CORBA::Float cold;
    CORBA::Float Xr;
    CORBA::Float Yr;
    CORBA::Float x;
    CORBA::Float y;
    CORBA::Float z;
    CORBA::Float normals;
    CORBA::Float Normal[3];
    CORBA::Float Tangent[3];
    CORBA::Float curvature;
    CORBA::Float error;
    CORBA::Octet red;
    CORBA::Octet green;
    CORBA::Octet blue;

    void _OB_marshal(
        OBEC_OutputStreamImpl* _ob_out,
        CORBA_Environment* _ob_cev
    ) const;
    static void _OB_unmarshal(
        CBREP_Point& _ob_v,
        OBEC_InputStreamImpl* _ob_in,
        CORBA_Environment* _ob_cev
    );

    void
    _OB_convert_to(
        void* _ob_data
    ) const;

    static void
    _OB_convert_from(
        CBREP_Point& _ob_v,
        void* _ob_data
    );
};

extern CORBA::TypeCode_ptr _tc_CBREP_Point;

//
// IDL:CBREP_PointSeq:1.0
//
class OBUnique_CBREP_PointSeq { };

typedef OB::FixSeq< ::CBREP_Point, OBUnique_CBREP_PointSeq > CBREP_PointSeq;
typedef OB::SeqVar< OB::FixSeq< ::CBREP_Point, OBUnique_CBREP_PointSeq > > CBREP_PointSeq_var;
typedef OB::SeqOut< OB::FixSeq< ::CBREP_Point, OBUnique_CBREP_PointSeq > > CBREP_PointSeq_out;
extern CORBA::TypeCode_ptr _tc_CBREP_PointSeq;

//
// IDL:CBREP_Segment:1.0
//
struct CBREP_Segment;
typedef OB::VarVar< CBREP_Segment > CBREP_Segment_var;
typedef OB::VarOut< CBREP_Segment > CBREP_Segment_out;

struct CBREP_Segment
{
#ifdef OB_PURIFY_CLEAN
    CBREP_Segment();
#else
    CBREP_Segment() { }
#endif
    CBREP_Segment(const CBREP_Segment&);
    CBREP_Segment& operator=(const CBREP_Segment&);

    typedef CBREP_Segment_var _var_type;

    CORBA::Long label;
    CORBA::Long n;
    CORBA::Long npoint;
    CORBA::Float curvature;
    CORBA::Float error;
    CORBA::Float intensity_sigma;
    ::CBREP_PointSeq point;
    CORBA::Octet red;
    CORBA::Octet green;
    CORBA::Octet blue;

    void _OB_marshal(
        OBEC_OutputStreamImpl* _ob_out,
        CORBA_Environment* _ob_cev
    ) const;
    static void _OB_unmarshal(
        CBREP_Segment& _ob_v,
        OBEC_InputStreamImpl* _ob_in,
        CORBA_Environment* _ob_cev
    );

    void
    _OB_convert_to(
        void* _ob_data
    ) const;

    static void
    _OB_convert_from(
        CBREP_Segment& _ob_v,
        void* _ob_data
    );
};

extern CORBA::TypeCode_ptr _tc_CBREP_Segment;

//
// IDL:CBREP_SegmentSeq:1.0
//
class OBUnique_CBREP_SegmentSeq { };

typedef OB::VarSeq< ::CBREP_Segment, OBUnique_CBREP_SegmentSeq > CBREP_SegmentSeq;
typedef OB::SeqVar< OB::VarSeq< ::CBREP_Segment, OBUnique_CBREP_SegmentSeq > > CBREP_SegmentSeq_var;
typedef OB::SeqOut< OB::VarSeq< ::CBREP_Segment, OBUnique_CBREP_SegmentSeq > > CBREP_SegmentSeq_out;
extern CORBA::TypeCode_ptr _tc_CBREP_SegmentSeq;

//
// IDL:CBREP_Bound:1.0
//
struct CBREP_Bound;
typedef OB::VarVar< CBREP_Bound > CBREP_Bound_var;
typedef OB::VarOut< CBREP_Bound > CBREP_Bound_out;

struct CBREP_Bound
{
#ifdef OB_PURIFY_CLEAN
    CBREP_Bound();
#else
    CBREP_Bound() { }
#endif
    CBREP_Bound(const CBREP_Bound&);
    CBREP_Bound& operator=(const CBREP_Bound&);

    typedef CBREP_Bound_var _var_type;

    CORBA::Long label;
    CORBA::Long n;
    CORBA::Long nsegment;
    CORBA::Long npoint;
    ::CBREP_SegmentSeq segment;
    ::CBREP_PointSeq point;

    void _OB_marshal(
        OBEC_OutputStreamImpl* _ob_out,
        CORBA_Environment* _ob_cev
    ) const;
    static void _OB_unmarshal(
        CBREP_Bound& _ob_v,
        OBEC_InputStreamImpl* _ob_in,
        CORBA_Environment* _ob_cev
    );

    void
    _OB_convert_to(
        void* _ob_data
    ) const;

    static void
    _OB_convert_from(
        CBREP_Bound& _ob_v,
        void* _ob_data
    );
};

extern CORBA::TypeCode_ptr _tc_CBREP_Bound;

//
// IDL:CBREP_BoundSeq:1.0
//
class OBUnique_CBREP_BoundSeq { };

typedef OB::VarSeq< ::CBREP_Bound, OBUnique_CBREP_BoundSeq > CBREP_BoundSeq;
typedef OB::SeqVar< OB::VarSeq< ::CBREP_Bound, OBUnique_CBREP_BoundSeq > > CBREP_BoundSeq_var;
typedef OB::SeqOut< OB::VarSeq< ::CBREP_Bound, OBUnique_CBREP_BoundSeq > > CBREP_BoundSeq_out;
extern CORBA::TypeCode_ptr _tc_CBREP_BoundSeq;

//
// IDL:CBREP_Cnet:1.0
//
struct CBREP_Cnet;
typedef OB::FixVar< CBREP_Cnet > CBREP_Cnet_var;
typedef CBREP_Cnet& CBREP_Cnet_out;

struct CBREP_Cnet
{
    typedef CBREP_Cnet_var _var_type;

    CORBA::Long label;
    CORBA::Long n;
    CORBA::Long mapcol;
    CORBA::Long maprow;
    CORBA::Float Position[3];
    CORBA::Float Normal[3];
    CORBA::Octet red;
    CORBA::Octet green;
    CORBA::Octet blue;

    void _OB_marshal(
        OBEC_OutputStreamImpl* _ob_out,
        CORBA_Environment* _ob_cev
    ) const;
    static void _OB_unmarshal(
        CBREP_Cnet& _ob_v,
        OBEC_InputStreamImpl* _ob_in,
        CORBA_Environment* _ob_cev
    );

    void
    _OB_convert_to(
        void* _ob_data
    ) const;

    static void
    _OB_convert_from(
        CBREP_Cnet& _ob_v,
        void* _ob_data
    );
};

extern CORBA::TypeCode_ptr _tc_CBREP_Cnet;

//
// IDL:CBREP_CnetSeq:1.0
//
class OBUnique_CBREP_CnetSeq { };

typedef OB::FixSeq< ::CBREP_Cnet, OBUnique_CBREP_CnetSeq > CBREP_CnetSeq;
typedef OB::SeqVar< OB::FixSeq< ::CBREP_Cnet, OBUnique_CBREP_CnetSeq > > CBREP_CnetSeq_var;
typedef OB::SeqOut< OB::FixSeq< ::CBREP_Cnet, OBUnique_CBREP_CnetSeq > > CBREP_CnetSeq_out;
extern CORBA::TypeCode_ptr _tc_CBREP_CnetSeq;

//
// IDL:CBREP_Region:1.0
//
struct CBREP_Region;
typedef OB::VarVar< CBREP_Region > CBREP_Region_var;
typedef OB::VarOut< CBREP_Region > CBREP_Region_out;

struct CBREP_Region
{
#ifdef OB_PURIFY_CLEAN
    CBREP_Region();
#else
    CBREP_Region() { }
#endif
    CBREP_Region(const CBREP_Region&);
    CBREP_Region& operator=(const CBREP_Region&);

    typedef CBREP_Region_var _var_type;

    CORBA::Long label;
    CORBA::Long n;
    CORBA::Long nbound;
    CORBA::Long nsegment;
    CORBA::Long npoint;
    CORBA::Long ncnet;
    CORBA::Long area;
    CORBA::Long width;
    CORBA::Long type;
    CORBA::Float intensity;
    CORBA::Float std_deviation;
    ::CBREP_BoundSeq bound;
    ::CBREP_SegmentSeq segment;
    ::CBREP_PointSeq point;
    ::CBREP_CnetSeq cnet;

    void _OB_marshal(
        OBEC_OutputStreamImpl* _ob_out,
        CORBA_Environment* _ob_cev
    ) const;
    static void _OB_unmarshal(
        CBREP_Region& _ob_v,
        OBEC_InputStreamImpl* _ob_in,
        CORBA_Environment* _ob_cev
    );

    void
    _OB_convert_to(
        void* _ob_data
    ) const;

    static void
    _OB_convert_from(
        CBREP_Region& _ob_v,
        void* _ob_data
    );
};

extern CORBA::TypeCode_ptr _tc_CBREP_Region;

//
// IDL:CBREP_RegionSeq:1.0
//
class OBUnique_CBREP_RegionSeq { };

typedef OB::VarSeq< ::CBREP_Region, OBUnique_CBREP_RegionSeq > CBREP_RegionSeq;
typedef OB::SeqVar< OB::VarSeq< ::CBREP_Region, OBUnique_CBREP_RegionSeq > > CBREP_RegionSeq_var;
typedef OB::SeqOut< OB::VarSeq< ::CBREP_Region, OBUnique_CBREP_RegionSeq > > CBREP_RegionSeq_out;
extern CORBA::TypeCode_ptr _tc_CBREP_RegionSeq;

//
// IDL:CBREP:1.0
//
struct CBREP;
typedef OB::VarVar< CBREP > CBREP_var;
typedef OB::VarOut< CBREP > CBREP_out;

struct CBREP
{
#ifdef OB_PURIFY_CLEAN
    CBREP();
#else
    CBREP() { }
#endif
    CBREP(const CBREP&);
    CBREP& operator=(const CBREP&);

    typedef CBREP_var _var_type;

    CORBA::Long label;
    CORBA::Long n;
    CORBA::Long nregion;
    CORBA::Long nbound;
    CORBA::Long nsegment;
    CORBA::Long npoint;
    CORBA::Long ncnet;
    CORBA::Long colstart;
    CORBA::Long rowstart;
    CORBA::Long ncol;
    CORBA::Long nrow;
    ::CBREP_RegionSeq region;
    ::CBREP_BoundSeq bound;
    ::CBREP_SegmentSeq segment;
    ::CBREP_PointSeq point;
    ::CBREP_CnetSeq cnet;
    CORBA::Long CameraID;

    void _OB_marshal(
        OBEC_OutputStreamImpl* _ob_out,
        CORBA_Environment* _ob_cev
    ) const;
    static void _OB_unmarshal(
        CBREP& _ob_v,
        OBEC_InputStreamImpl* _ob_in,
        CORBA_Environment* _ob_cev
    );

    void
    _OB_convert_to(
        void* _ob_data
    ) const;

    static void
    _OB_convert_from(
        CBREP& _ob_v,
        void* _ob_data
    );
};

extern CORBA::TypeCode_ptr _tc_CBREP;

//
// IDL:CBREPSeq:1.0
//
class OBUnique_CBREPSeq { };

typedef OB::VarSeq< ::CBREP, OBUnique_CBREPSeq > CBREPSeq;
typedef OB::SeqVar< OB::VarSeq< ::CBREP, OBUnique_CBREPSeq > > CBREPSeq_var;
typedef OB::SeqOut< OB::VarSeq< ::CBREP, OBUnique_CBREPSeq > > CBREPSeq_out;
extern CORBA::TypeCode_ptr _tc_CBREPSeq;

//
// IDL:CBREP_Point:1.0
//
void operator<<=(CORBA::Any&, CBREP_Point*);
void operator<<=(CORBA::Any&, const CBREP_Point&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CBREP_Point*&);

inline void
operator<<=(CORBA::Any_var& any, CBREP_Point* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CBREP_Point& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CBREP_Point*& val)
{
    return any.in() >>= val;
}

//
// IDL:CBREP_PointSeq:1.0
//
void operator<<=(CORBA::Any&, CBREP_PointSeq*);
void operator<<=(CORBA::Any&, const CBREP_PointSeq&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CBREP_PointSeq*&);

inline void
operator<<=(CORBA::Any_var& any, CBREP_PointSeq* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CBREP_PointSeq& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CBREP_PointSeq*& val)
{
    return any.in() >>= val;
}

//
// IDL:CBREP_Segment:1.0
//
void operator<<=(CORBA::Any&, CBREP_Segment*);
void operator<<=(CORBA::Any&, const CBREP_Segment&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CBREP_Segment*&);

inline void
operator<<=(CORBA::Any_var& any, CBREP_Segment* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CBREP_Segment& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CBREP_Segment*& val)
{
    return any.in() >>= val;
}

//
// IDL:CBREP_SegmentSeq:1.0
//
void operator<<=(CORBA::Any&, CBREP_SegmentSeq*);
void operator<<=(CORBA::Any&, const CBREP_SegmentSeq&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CBREP_SegmentSeq*&);

inline void
operator<<=(CORBA::Any_var& any, CBREP_SegmentSeq* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CBREP_SegmentSeq& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CBREP_SegmentSeq*& val)
{
    return any.in() >>= val;
}

//
// IDL:CBREP_Bound:1.0
//
void operator<<=(CORBA::Any&, CBREP_Bound*);
void operator<<=(CORBA::Any&, const CBREP_Bound&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CBREP_Bound*&);

inline void
operator<<=(CORBA::Any_var& any, CBREP_Bound* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CBREP_Bound& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CBREP_Bound*& val)
{
    return any.in() >>= val;
}

//
// IDL:CBREP_BoundSeq:1.0
//
void operator<<=(CORBA::Any&, CBREP_BoundSeq*);
void operator<<=(CORBA::Any&, const CBREP_BoundSeq&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CBREP_BoundSeq*&);

inline void
operator<<=(CORBA::Any_var& any, CBREP_BoundSeq* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CBREP_BoundSeq& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CBREP_BoundSeq*& val)
{
    return any.in() >>= val;
}

//
// IDL:CBREP_Cnet:1.0
//
void operator<<=(CORBA::Any&, CBREP_Cnet*);
void operator<<=(CORBA::Any&, const CBREP_Cnet&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CBREP_Cnet*&);

inline void
operator<<=(CORBA::Any_var& any, CBREP_Cnet* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CBREP_Cnet& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CBREP_Cnet*& val)
{
    return any.in() >>= val;
}

//
// IDL:CBREP_CnetSeq:1.0
//
void operator<<=(CORBA::Any&, CBREP_CnetSeq*);
void operator<<=(CORBA::Any&, const CBREP_CnetSeq&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CBREP_CnetSeq*&);

inline void
operator<<=(CORBA::Any_var& any, CBREP_CnetSeq* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CBREP_CnetSeq& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CBREP_CnetSeq*& val)
{
    return any.in() >>= val;
}

//
// IDL:CBREP_Region:1.0
//
void operator<<=(CORBA::Any&, CBREP_Region*);
void operator<<=(CORBA::Any&, const CBREP_Region&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CBREP_Region*&);

inline void
operator<<=(CORBA::Any_var& any, CBREP_Region* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CBREP_Region& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CBREP_Region*& val)
{
    return any.in() >>= val;
}

//
// IDL:CBREP_RegionSeq:1.0
//
void operator<<=(CORBA::Any&, CBREP_RegionSeq*);
void operator<<=(CORBA::Any&, const CBREP_RegionSeq&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CBREP_RegionSeq*&);

inline void
operator<<=(CORBA::Any_var& any, CBREP_RegionSeq* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CBREP_RegionSeq& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CBREP_RegionSeq*& val)
{
    return any.in() >>= val;
}

//
// IDL:CBREP:1.0
//
void operator<<=(CORBA::Any&, CBREP*);
void operator<<=(CORBA::Any&, const CBREP&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CBREP*&);

inline void
operator<<=(CORBA::Any_var& any, CBREP* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CBREP& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CBREP*& val)
{
    return any.in() >>= val;
}

//
// IDL:CBREPSeq:1.0
//
void operator<<=(CORBA::Any&, CBREPSeq*);
void operator<<=(CORBA::Any&, const CBREPSeq&);
CORBA::Boolean operator>>=(const CORBA::Any&, const CBREPSeq*&);

inline void
operator<<=(CORBA::Any_var& any, CBREPSeq* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const CBREPSeq& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const CBREPSeq*& val)
{
    return any.in() >>= val;
}

#endif
