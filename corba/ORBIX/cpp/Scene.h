// **********************************************************************
//
// Generated by the Orbix/E IDL-to-C++ Translator
//
// Copyright (c) 2003
// IONA Technologies, Inc.
// Waltham, MA, USA
//
// All Rights Reserved
//
// **********************************************************************

// Version: 2.2.0

#ifndef ___Scene_h__
#define ___Scene_h__

#ifndef OBEC_INTEGER_VERSION
#   error No Orbix/E version defined! Is <OBE/CORBA.h> included?
#endif

#ifndef OBEC_NO_VERSION_CHECK
#   if (OBEC_INTEGER_VERSION != 2020000L)
#       error Orbix/E version mismatch!
#   endif
#endif

//
// IDL:DoubleMatrix:1.0
//
struct DoubleMatrix;
typedef OB::VarVar< DoubleMatrix > DoubleMatrix_var;
typedef OB::VarOut< DoubleMatrix > DoubleMatrix_out;

struct DoubleMatrix
{
#ifdef OB_PURIFY_CLEAN
    DoubleMatrix();
#else
    DoubleMatrix() { }
#endif
    DoubleMatrix(const DoubleMatrix&);
    DoubleMatrix& operator=(const DoubleMatrix&);

    typedef DoubleMatrix_var _var_type;

    CORBA::Long nrows;
    CORBA::Long ncols;
    class OBUnique_data { };
    typedef OB::FixSeq< CORBA::Double, OBUnique_data > _data_seq;
    _data_seq data;

    void _OB_marshal(
        OBEC_OutputStreamImpl* _ob_out,
        CORBA_Environment* _ob_cev
    ) const;
    static void _OB_unmarshal(
        DoubleMatrix& _ob_v,
        OBEC_InputStreamImpl* _ob_in,
        CORBA_Environment* _ob_cev
    );

    void
    _OB_convert_to(
        void* _ob_data
    ) const;

    static void
    _OB_convert_from(
        DoubleMatrix& _ob_v,
        void* _ob_data
    );
};

extern CORBA::TypeCode_ptr _tc_DoubleMatrix;

//
// IDL:IdentifierInformation:1.0
//
class OBUnique_IdentifierInformation { };

typedef OB::FixSeq< CORBA::Octet, OBUnique_IdentifierInformation > IdentifierInformation;
typedef OB::SeqVar< OB::FixSeq< CORBA::Octet, OBUnique_IdentifierInformation > > IdentifierInformation_var;
typedef OB::SeqOut< OB::FixSeq< CORBA::Octet, OBUnique_IdentifierInformation > > IdentifierInformation_out;
extern CORBA::TypeCode_ptr _tc_IdentifierInformation;

//
// IDL:SceneFeature:1.0
//
struct SceneFeature;
typedef OB::VarVar< SceneFeature > SceneFeature_var;
typedef OB::VarOut< SceneFeature > SceneFeature_out;

struct SceneFeature
{
#ifdef OB_PURIFY_CLEAN
    SceneFeature();
#else
    SceneFeature() { }
#endif
    SceneFeature(const SceneFeature&);
    SceneFeature& operator=(const SceneFeature&);

    typedef SceneFeature_var _var_type;

    ::DoubleMatrix y;
    ::DoubleMatrix Pyy;
    CORBA::Long label;
    CORBA::Boolean SuccessfulMeasurementFlag;
    CORBA::Boolean SelectedFlag;
    ::DoubleMatrix h;
    ::DoubleMatrix z;
    ::DoubleMatrix S;
    ::IdentifierInformation Identifier;

    void _OB_marshal(
        OBEC_OutputStreamImpl* _ob_out,
        CORBA_Environment* _ob_cev
    ) const;
    static void _OB_unmarshal(
        SceneFeature& _ob_v,
        OBEC_InputStreamImpl* _ob_in,
        CORBA_Environment* _ob_cev
    );

    void
    _OB_convert_to(
        void* _ob_data
    ) const;

    static void
    _OB_convert_from(
        SceneFeature& _ob_v,
        void* _ob_data
    );
};

extern CORBA::TypeCode_ptr _tc_SceneFeature;

//
// IDL:SceneFeatureSeq:1.0
//
class OBUnique_SceneFeatureSeq { };

typedef OB::VarSeq< ::SceneFeature, OBUnique_SceneFeatureSeq > SceneFeatureSeq;
typedef OB::SeqVar< OB::VarSeq< ::SceneFeature, OBUnique_SceneFeatureSeq > > SceneFeatureSeq_var;
typedef OB::SeqOut< OB::VarSeq< ::SceneFeature, OBUnique_SceneFeatureSeq > > SceneFeatureSeq_out;
extern CORBA::TypeCode_ptr _tc_SceneFeatureSeq;

//
// IDL:SceneObject:1.0
//
struct SceneObject;
typedef OB::VarVar< SceneObject > SceneObject_var;
typedef OB::VarOut< SceneObject > SceneObject_out;

struct SceneObject
{
#ifdef OB_PURIFY_CLEAN
    SceneObject();
#else
    SceneObject() { }
#endif
    SceneObject(const SceneObject&);
    SceneObject& operator=(const SceneObject&);

    typedef SceneObject_var _var_type;

    ::SceneFeatureSeq Features;
    ::DoubleMatrix xv;
    ::DoubleMatrix Pxx;
    CORBA::Long NoFeatures;
    CORBA::Long NoSelected;

    void _OB_marshal(
        OBEC_OutputStreamImpl* _ob_out,
        CORBA_Environment* _ob_cev
    ) const;
    static void _OB_unmarshal(
        SceneObject& _ob_v,
        OBEC_InputStreamImpl* _ob_in,
        CORBA_Environment* _ob_cev
    );

    void
    _OB_convert_to(
        void* _ob_data
    ) const;

    static void
    _OB_convert_from(
        SceneObject& _ob_v,
        void* _ob_data
    );
};

extern CORBA::TypeCode_ptr _tc_SceneObject;

//
// IDL:DoubleMatrix:1.0
//
void operator<<=(CORBA::Any&, DoubleMatrix*);
void operator<<=(CORBA::Any&, const DoubleMatrix&);
CORBA::Boolean operator>>=(const CORBA::Any&, const DoubleMatrix*&);

inline void
operator<<=(CORBA::Any_var& any, DoubleMatrix* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const DoubleMatrix& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const DoubleMatrix*& val)
{
    return any.in() >>= val;
}

//
// IDL:IdentifierInformation:1.0
//
void operator<<=(CORBA::Any&, IdentifierInformation*);
void operator<<=(CORBA::Any&, const IdentifierInformation&);
CORBA::Boolean operator>>=(const CORBA::Any&, const IdentifierInformation*&);

inline void
operator<<=(CORBA::Any_var& any, IdentifierInformation* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const IdentifierInformation& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const IdentifierInformation*& val)
{
    return any.in() >>= val;
}

//
// IDL:SceneFeature:1.0
//
void operator<<=(CORBA::Any&, SceneFeature*);
void operator<<=(CORBA::Any&, const SceneFeature&);
CORBA::Boolean operator>>=(const CORBA::Any&, const SceneFeature*&);

inline void
operator<<=(CORBA::Any_var& any, SceneFeature* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const SceneFeature& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const SceneFeature*& val)
{
    return any.in() >>= val;
}

//
// IDL:SceneFeatureSeq:1.0
//
void operator<<=(CORBA::Any&, SceneFeatureSeq*);
void operator<<=(CORBA::Any&, const SceneFeatureSeq&);
CORBA::Boolean operator>>=(const CORBA::Any&, const SceneFeatureSeq*&);

inline void
operator<<=(CORBA::Any_var& any, SceneFeatureSeq* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const SceneFeatureSeq& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const SceneFeatureSeq*& val)
{
    return any.in() >>= val;
}

//
// IDL:SceneObject:1.0
//
void operator<<=(CORBA::Any&, SceneObject*);
void operator<<=(CORBA::Any&, const SceneObject&);
CORBA::Boolean operator>>=(const CORBA::Any&, const SceneObject*&);

inline void
operator<<=(CORBA::Any_var& any, SceneObject* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const SceneObject& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const SceneObject*& val)
{
    return any.in() >>= val;
}

#endif
